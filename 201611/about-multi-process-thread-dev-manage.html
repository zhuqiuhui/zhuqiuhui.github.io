<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>浅谈多进程程序的进程控制和管理方式 | 桃子的博客铭</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="多线程程序、多进程程序是当前单机应用常用并行化的手段，线程是可以直接被CPU调度的执行单元，虽然多进程程序中每个进程也可以是多线程的，但是本文主要讨论的多进程程序默认是每个进程都有一个单独线程的情况。多线程程序和多进程程序，涉及到的线程间和进程间的通信、同步原语基本都是相同的，所以两者的开发在一定程度上有着高度的相似性，但同时差异化也十分的明显，所以高性能程序使用多线程还是多进程实现常常也是争">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈多进程程序的进程控制和管理方式">
<meta property="og:url" content="https://taozj.org/201611/about-multi-process-thread-dev-manage.html">
<meta property="og:site_name" content="桃子的博客铭">
<meta property="og:description" content="多线程程序、多进程程序是当前单机应用常用并行化的手段，线程是可以直接被CPU调度的执行单元，虽然多进程程序中每个进程也可以是多线程的，但是本文主要讨论的多进程程序默认是每个进程都有一个单独线程的情况。多线程程序和多进程程序，涉及到的线程间和进程间的通信、同步原语基本都是相同的，所以两者的开发在一定程度上有着高度的相似性，但同时差异化也十分的明显，所以高性能程序使用多线程还是多进程实现常常也是争">
<meta property="og:image" content="https://taozj.org/post_images/images/201611/22fcba011a0b363f047b1d5cc28e75f9.jpg">
<meta property="og:image" content="https://taozj.org/post_images/images/201611/e1d0cda50c4a1d7c54969d6895805fa6.gif">
<meta property="og:updated_time" content="2017-02-05T07:45:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈多进程程序的进程控制和管理方式">
<meta name="twitter:description" content="多线程程序、多进程程序是当前单机应用常用并行化的手段，线程是可以直接被CPU调度的执行单元，虽然多进程程序中每个进程也可以是多线程的，但是本文主要讨论的多进程程序默认是每个进程都有一个单独线程的情况。多线程程序和多进程程序，涉及到的线程间和进程间的通信、同步原语基本都是相同的，所以两者的开发在一定程度上有着高度的相似性，但同时差异化也十分的明显，所以高性能程序使用多线程还是多进程实现常常也是争">
<meta name="twitter:image" content="https://taozj.org/post_images/images/201611/22fcba011a0b363f047b1d5cc28e75f9.jpg">
  
    <link rel="alternative" href="/atom.xml" title="桃子的博客铭" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/iconfont.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">taozj</a></h1>
        </hgroup>

        
        <p class="header-subtitle">高性能、高可用服务端开发</p>
        
        <br>
        
        <p class="header-subtitle">淡泊明志，宁静致远！</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">文章归档</a></li>
                        
                            <li><a href="https://album.taozj.org">个人相册</a></li>
                        
                            <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                        
                            <li><a href="/about">请你读我</a></li>
                        
                            <li><a href="/search.html">搜索本站</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作/">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构架/">构架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">taozj</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">taozj</a></h1>
            </hgroup>
            
            <p class="header-subtitle">高性能、高可用服务端开发</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="https://album.taozj.org">个人相册</a></li>
                
                    <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                
                    <li><a href="/about">请你读我</a></li>
                
                    <li><a href="/search.html">搜索本站</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-about-multi-process-thread-dev-manage" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201611/about-multi-process-thread-dev-manage.html" class="article-date">
      <time datetime="2016-11-07T14:38:42.000Z" itemprop="datePublished">2016-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅谈多进程程序的进程控制和管理方式
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/运维/">运维</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>　　多线程程序、多进程程序是当前单机应用常用并行化的手段，线程是可以直接被CPU调度的执行单元，虽然多进程程序中每个进程也可以是多线程的，但是本文主要讨论的多进程程序默认是每个进程都有一个单独线程的情况。多线程程序和多进程程序，涉及到的线程间和进程间的通信、同步原语基本都是相同的，所以两者的开发在一定程度上有着高度的相似性，但同时差异化也十分的明显，所以高性能程序使用多线程还是多进程实现常常也是争论的焦点。<br>　　虽然自己之前开发的程序基本都是基于pthreads和C++ std::thread的多线程程序，但是多进程程序还是有它相应的用武之地的，比如大名鼎鼎的Nginx中master和worker机制就是采用多进程的方式实现的，所以这里也对多进程和多线程程序的区别联系整理一下，最后顺便看看Nginx中master和worker进程的管理和实现机制，在后续开发多进程程序的时候可以直接借鉴使用。</p>
<h1 id="一、多线程和多进程程序">一、多线程和多进程程序</h1><p>　　Linux中有一句耳熟能详的话——线程被认为是轻量级的进程，在现代操作系统的概念中，进程被认为是资源管理的最小单元，而线程被认为是程序执行的最小单元，所以多线程和多进程之间的差异基本体现在执行单元之间对资源耦合度的差异。虽然对于用户空间而言，最为广为使用的pthreads线程库提供了自己一套线程创建和管理、线程间同步接口，其实在Linux下面创线程和创建进程都是使用clone()系统调用实现的，只是在调用参数(flags)上不同，导致创建的执行单元具有不一样的资源共享情况，从而造就了线程和进程实质上的差异。<br><img src="/post_images/images/201611/22fcba011a0b363f047b1d5cc28e75f9.jpg" alt="线程和进程"></p>
<h2 id="1-1_多线程的特点_multi-threaded">1.1 多线程的特点 multi-threaded</h2><p>　　从上面的图中看出，同一个进程中的多个线程，跟执行状态相关的资源都是独立的，比如：运行栈、优先级、程序计数器、信号掩码等都是独立的，而打开的文件描述符(包含套接字)、地址空间(除了函数中的自动变量属于栈管理，还有新提出来的线程局部变量，其它基本都是共享的)都是共享的。这里还设计到信号处理句柄、信号掩码等，因为在多线程中信号的问题比较的复杂，后面单独列出来解释。<br>　　共享相同的地址空间、文件描述符给程序的开发带来了极大的便利，创建多线程的开销要小的多，而且在运行中任务切换损失也很小，很多的缓存都维持有效的，还有比如负责套接字listen的线程和工作线程之间可以方便的传递网络连接创建的套接字，生产线程和消费线程可以方便的用队列进行数据交换，程序设计也可以特化出日志记录、数据落盘等工作线程各司其职。但是天下没有免费的午餐，任何的便利都是需要付出代价的，多个执行单元可以访问资源意味着共享资源必须得到保护和同步，这是多线程程序设计不可回避的问题：<br>　　(1). 多个线程可以安全的访问只读的资源，但是哪怕只有一个修改者也是不安全的，额外说一句，我们说的保护是保护的资源，而不是行为；<br>　　(2). 传统很多库函数都不是线程安全的，这些函数当初设计的时候没有考虑到多线程的问题，所以使用了大量的全局变量和静态局部变量，这些函数是不可重入的。所以在你调用库函数、链接别人库的时候，一定要看看有没有”_r”后缀的版本；<br>　　(3). 还要就是之前不断被提到的内存模型，因为同个进程中的多个线程可能会并行的执行，这时候如果在线程之间有高速度的数据同步需求的时候，必须让资源的更新能够及时地被别的线程感知到；<br>　　(4). 多线程程序正因为线程之间共享的资源太多，所以如果一个线程出现严重的问题，其余的线程也会被杀死。遥想当年在TP-LINK的时候，所有的服务功能都以线程的形式被包裹在一个用户进程中，某个模块出现问题都可能导致上不了网需要重启，所以现在看来稳定运行的TP-LINK路由器不得不说是一个奇迹~ <a id="more"></a></p>
<h2 id="1-2_多进程的特点_multi-process">1.2 多进程的特点 multi-process</h2><p>　　多进程程序之间保证了资源的高度隔离，只在创建出来的父子进程之间有少量的联系，进程组、回话等就不在此讨论了。<br>　　这个时候需要共享的资源必须显式共享，虽然操作系统优化机制可以让他们的只读数据(比如执行代码)物理上共享，进程间的资源共享或者通过关联到文件系统的某个路径或者文件，或者通过全局字符串名字方式，通过以某个进程首先创建资源，其他进程打开资源的方式共享。由于历史原因，Linux进程间通信通常包含SYS V和Posix两套接口，其种类和功能大同小异，但是个人的实际感受Posix的操作接口要更加的好用一些。<br>　　Linux进程间通信通常用到的方法有：匿名管道、命名管道、信号、消息队列、共享内存、信号量和套接字，其中匿名管道只用于有亲属关系的父子进程之间的一种单功通信方式，在fork()创建进程之前创建匿名管道。其中个人用的最多的是命名管道、共享内存和信号量：命名管道由于返回的文件描述符，可以十分方便的融合到现有的select/poll/epoll框架下面去；信号量主要用于模拟进程间互斥的行为；共享内存用于进程间大规模的数据共享。陈硕的一句名言就是“在多进程之间共享内存无异于掩耳盗铃”，其实多进程间通过共享内存的方式共享数据弊端和限制确实很多：首先共享内存中不能共享指针，而指向共享内存段本身的指针也最好用便宜的方式退化指针；如果共享内存的数据经常会被修改，那更是个灾难。当然简单只读数据是可以的，比如Nginx的缓存也使用了共享内存。<br>　　多进程程序的好处，就是消除了进程之间的耦合度后，操作系统的保护机制可以让多个进程更加的独立可靠，而且分成多个进程之后管理进程比管理线程方便灵活的多；同时，多进程程序可以实现进程的特异化管理，比如在Nginx设计中master process是特权进程，可以读取配置文件、修改数重要数据等关键操作，而worker process是普通权限进程，只负责业务方面的处理，符合系统管理中的最小化权限原则；再有就是多进程程序可以进行业务的热更新平滑升级，下面的Nginx算是将这一功能使用的淋漓尽致啊。<br>　　但是多进程的程序也有个问题，就是很多共享的资源、同步的手段都是命名全局的，很有可能进程意外退出后这些资源都得不到回收，补救的办法只能是重启操作系统，汗~</p>
<h2 id="1-3_多线程程序和信号">1.3 多线程程序和信号</h2><p>　　感觉信号一直是Linux平台下开发比较头疼的问题，尤其对于多线程情况下的程序，信号的处理将更加的复杂。</p>
<h3 id="1-3-1_单线程程序中信号的处理方式">1.3.1 单线程程序中信号的处理方式</h3><p>　　Linux中的信号的处理方式可以是SIG_IGN、SIG_DFL以及自己通过sigaction设置自定义处理函数，进程创建的时候信号都有默认的处理方式，而用户可以后续选择忽略、默认处理方式、自定义处理这些信号(SIGKILL、SIGSTOP两个信号只能默认处理方式，不能被忽略或者重定义处理)，当进程接收到信号的时候就会转向信号处理历程去执行。<br>　　信号可以在某些情况下被系统发送(比如触发段错误)，或者被别的进程使用kill发送，或者进程自己调用kill、raise系统调用触发信号。进程可以通过signal mask去block某些信号，默认情况下是没有信号被block的，此时如果被block的信号发送过来了，将会被设置为pending的，然后一旦该进程unblock了该信号，pending的信号将会立即被传递。</p>
<h3 id="1-3-2_pthreads库多线程环境对信号处理的方式">1.3.2 pthreads库多线程环境对信号处理的方式</h3><p>　　pthreads库多线程中信号处理的方式，和信号的种类、各个线程对信号的mask状态共同决定的。<br>　　Linux中多线程环境下信号的种类可以分为同步(Synchronously)信号和异步(Asynchronously)信号：同步信号是针对某个线程的，比如某个线程执行过程中除以零(SIGFPE)、访问非法地址(SIGSEGV)、使用了broken的管道(SIGPIPE)，这些信号都根某个特定的线程特定的执行上下文有关，还有就是同个进程中线程之间通过pthread_kill显式发送信号的情况；异步信号主要是其他进程向该进程通过kill向这个进程(而非其中的线程)发送信号，并不跟某个特定的线程相关联的情况。<br>　　pthreads库中多线程之间共享sigaction结构但是不共享sig_mask结构，这意味所有的线程共享相同的信号处理方式，而不论信号处理方式是谁设置的。进程在最初fork()后创建的第一个线程继承了其signal mask，而通过pthread_create创建的其他线程也继承了这个信号mask，后续可以通过pthread_sigmask接口控制本线程对某些信号的block或者unblock。<br>　　有了上面的知识，信号在多线程下的行为就可以被确定了：<br>　　(1). 所有的线程共享相同的sigaction，所以所有进程对某个信号的处理方式是完全相同的；<br>　　(2). 同步信号是针对某个特定线程的，该线程是否接收处理这个信号看其signal mask设置情况；<br>　　(3). 异步信号是针对这个进程的，当这种信号到达的时候，进程会从没有block这个信号的线程集合中随机选出一个出来处理这个信号，如果所有的线程都block该信号，那么这个信号将被pending起来，直到有线程unblock这个信号，就将其发送给那个线程处理。</p>
<h2 id="1-4_其他">1.4 其他</h2><p>　　由于在Linux下面创线程和创建进程是通过不同的参数使用clone()系统调用来实现的，Linux的线程本质上就是采用进程的方式实现的。在task_struct结构中就涉及到以下域：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1592</span>         <span class="keyword">pid_t</span> pid;</div><div class="line"><span class="number">1593</span>         <span class="keyword">pid_t</span> tgid;</div></pre></td></tr></table></figure></p>
<p>　　pid是内核自己维护的进程号，tgid是用户空间可见的进程号，通过gettid()调用可以返回pid，而getpid()调用返回的是tgid。在clone()系统调用中，通过传递CLONE_THREAD参数，新进程的tgid会被设置成父进程的tgid，否则新进程的tgid会设为其自身的pid。<br>　　这就说明内核自己通过pid的方式，把用户看来的线程当作进程来管理；而同个进程的各个线程通过相同的tgid被逻辑上形成一个整体——线程组。</p>
<h1 id="二、master管理多个worker进程">二、master管理多个worker进程</h1><p>　　在Nginx的配置文件中有个条目worker_processes，其用于指定master进程可以产生几个worker进程，默认情况下是CPU执行单元的数目。在Linux下实验发现，当kill掉worker进程的时候，master进程会自动再次启动worker进程，但是当kill掉master进程的时候，worker进程仍然活着并向外提供服务，这种方式或许是对于常驻服务最好的处理语义：master进程存在的时候会保证设定数目的工作进程存在，而master进程挂掉的时候worker进程仍然继续服务，不会存在单点故障导致服务立即停止的情况。<br>　　其基本原理也很简单，这源于在Linux平台下，当子进程退出的时候，内核会向父进程发送SIGCHLD信号，父进程可以捕获这个信号，并通过wait系统调用搜集子进程退出的相关信息，此后子进程的资源会被相应的释放掉。因此，父进程可以通过接收信号的方式异步得到子进程退出的消息，并且适当安排创建工作者进程。<br>　　当然，这仅仅是一个小trick，探究一下，发现Nginx的设计中，尤其是多进程服务端程序的开发维护中，大有学问可以借鉴！同时还有一个跟Nginx关系十分密切，估计也是使用相同master-worker方式构建的多进程的构架的，那就是php-fpm。之所以说关系密切，就是因为Apache本身支持php的解析，而Nginx只能通过外挂的方式，而挂件最常见的恰巧就是php-fpm了，通过ps查看，其也像是master-worker的结构，不过没看代码尚且不敢断定。<br><img src="/post_images/images/201611/e1d0cda50c4a1d7c54969d6895805fa6.gif" alt="NginxExt"></p>
<h2 id="2-1_跟踪环境的配置">2.1 跟踪环境的配置</h2><p>　　不知道啥时候，自己都快成了代码控了，GitHub上面一些感兴趣的项目代码都会clone下来并不断pull跟踪，nginx就是其中之一啊。调试环境设置很简单，只是有些点需要额外注意一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@srv:~/nginx<span class="comment"># apt-get install libpcre3-dev zlib1g-dev</span></div><div class="line">root@srv:~/nginx<span class="comment"># auto/configure --with-debug</span></div><div class="line">root@srv:~/nginx<span class="comment"># make</span></div></pre></td></tr></table></figure></p>
<p>　　上面configure的时候一定要添加–with-debug参数，这个时候可以让可执行程序支持生成debug的log信息，同时如果是MacOS的系统的话，还需要事先用homebrew安装gcc，然后添加–with-cc=/usr/local/bin/gcc-5指定使用gcc编译器(后面有时间说是要折腾一下Clang的，而苹果xcode默认就是用的这货)，不过MacOS底层用的是kqueue而不是epoll，你应该知道我要说什么；make编译之后会在objs目录下面生成nginx可执行程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@srv:~/nginx<span class="comment"># mkdir logs</span></div><div class="line">root@srv:~/nginx<span class="comment"># objs/nginx -p .</span></div></pre></td></tr></table></figure></p>
<p>　　通过-p参数，可以避免使用默认系统路径的权限问题，以及对现有环境的干扰。此时进程全部转到后台执行了，更要命的是IDE的调试环境此处被断开失连了，所以需要在nginx.c中将系统初始化过程的ngx_daemon()注释起来，就可以正常断点跟踪了。<br>　　到此，Nginx的调试跟踪环境设置完成，设置conf/nginx.conf中log级别error_log  logs/error.log  debug;然后通过tail -f logs/error.log所有运行调试日志尽收眼底。</p>
<h2 id="2-2_多进程服务端程序设计">2.2 多进程服务端程序设计</h2><p>　　通过官网Nginx文档大致了解了一下他的构架，看的真是让人拍案叫绝大快人心，请待我慢慢道来。</p>
<h3 id="2-2-1_多进程下的套接字">2.2.1 多进程下的套接字</h3><p>　　传统上Nginx在启动开始的时候就bind一个地址进行listen，后续在fork()创建worker process的时候，这些进程是共享这个侦听套接字的，这个在linux fork()的手册中明确地被表示出了(PS:这里需要注意shutdown和close的区别，前者会主动进行拆链请求，后者会降低引用计数，shutdown在拆链后如果还有其他进程使用，那么读会返回EOF，写会引发SIGPIPE)</p>
<blockquote>
<p>The  child  inherits  copies  of the parent’s set of open file descriptors.  Each file descriptor in the child refers to the same open file description (see open(2)) as the corresponding file descriptor in the parent. The child inherits copies of the parent’s set of open message queue descriptors, open directory streams.</p>
</blockquote>
<p>　　所以master process创建出来的所有worker process都是可以accept()客户端请求的，当多个进程对同一个socket调用accept()接收连接的时候，他们都会把自己放到这个套接字的等待队列上面去，然后一旦有客户发起连接请求，这个队列上面等待的进程就会被唤醒，这个过程在之前分析epoll的时候就介绍过了，但是在较早的epoll版本中，上面的唤醒过程会产生惊群(Thundering Herd)的问题：即使只有一个连接请求到来，也会唤醒在这个共享侦听套接字上所有等待的进程，而所有进程争抢这个连接只有一个能获得连接，其他所有进程都无功而返，所以新版的epoll添加了EPOLLEXCLUSIVE这么一个新的flag，通过在EPOLL_CTL_ADD的时候使用，保证在事件就绪的时候不会产生惊群的问题。<br>　　Nginx对于共享accept套接字惊群问题的处理，有三个方法：<br>　　(1). accept_mutex = on<br>　　当这个选项打开的时候，worker process在其任务循环的时候，会首先通过ngx_trylock_accept_mutex去获得一个进程间的ngx_accept_mutex互斥锁，而该锁通常是使用文件锁来实现的。在持有这个锁的时候，首先收集底层就绪的事件，同时执行accept的所有回调，然后释放该锁，处理一般的非accept事件。<br>　　(2). accept_mutex = off<br>　　这个设置在较新版本的Nginx已经是默认关闭的，主要考虑到的是：一来通过EPOLLEXCLUSIVE、下面的SO_REUSEPORT等新技术可以避免accept的时候惊群的问题；另一方面Nginx采用基于事件的处理方式，worker process只有很少的几个，而不像Apache的技术Prefork很多的子进程，所以即使发生惊群对系统造成的影响也极为有限。<br>　　(3). reuseport<br>　　在Linux内核3.9的时候，内核Socket支持了SO_REUSEPORT选项，而Nginx在1.9版本中引入了这个选项，这样每个worker process都可以同时侦听同一个IP:Port地址，内核会发现哪些listener可用，从而自动将连接请求分配给给定的worker process，消除了Nginx传统上通过用户态采用accept_mutex互斥锁而带来的性能损耗问题。<br>　　上面三种方式的性能对比在官方也给出了<a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="external">测试结果</a>。</p>
<h3 id="2-2-2_基于事件的异步模型">2.2.2 基于事件的异步模型</h3><p>　　异步模型是新一代http服务器Nginx和老牌Apache最大的不同之处：<br>　　Apache采用的是Prefork技术，服务启动之后预先启动一定数目的子进程，当服务器压力增大的时候不断增加子进程的数目，而当服务器空闲后自动关闭一些子进程，虽然这种弹性常驻子进程比One Child per Client的模型要进步很多，但是经过这么久的多进程、协程开发技术的熏陶可知，子进程的增加只在一定范围内可以增加服务能力，同时子进程在进程切换、内存等方面会对服务器带来很大的压力，如果当连接客户达到C10K的时候其占用的资源是不可估量的。不过Apache 2.4版本具有线程、事件等特性，试图减少进程带来的巨额开销。<br>　　但是Apache毕竟是老牌的Web服务器，其扩展模块非常的多，可以直接解析执行各种脚本，而不需要CGI/FastCGI这类额外的支持，而且性机可能更好，所以常见的情况就是Apache做后端服务器，而Nginx做前端反向代理的设计模式。<br>　　Nginx采用的是基于事件驱动的模型来解决C10K问题，所以通常Nginx只需要启动很少(通常CPU执行单元个数)的worker process就可以同时服务大量连接，以至于越来越多的http服务器迁移到Nginx平台上面。其工作流程主要是：<br>　　当master process通过fork()创建出几个worker process的时候，worker process进程主执行函数为ngx_worker_process_cycle()，这里面除了检查各种状态标识(比如接受到父进程发送的信号后，设置ngx_terminate、ngx_quit、ngx_reopen等标识)作出特定行为外，其正事主要是通过ngx_process_events_and_timers处理事件：<br>　　此时如果accept_mutex==on，而当ngx_trylock_accept_mutex抢锁失败则直接返回，否则就会设置NGX_POST_EVENTS这个标识，表示事件的回调延后执行。因为我们要把持锁的临界区降低，所以在持锁的过程中，通过ngx_process_events(实质乃是ngx_epoll_module_ctx.actions)检查底层侦听套接字就绪的事件，根据epoll特性可以快速的收集就绪事件并添加到ngx_posted_accept_events和ngx_posted_events队列上去，执行ngx_posted_accept_events队列回调后释放锁，最后执行一般的事件回调操作。<br>　　如果accept_mutex==off，那么在ngx_process_events的过程中，事件的回调将会在搜集就绪事件的过程中同步执行。</p>
<h2 id="2-3_Nginx配置文件和二进制程序平滑升级">2.3 Nginx配置文件和二进制程序平滑升级</h2><p>　　Nginx中多进程之间将信号运用的活灵活现(Windows平台下没用借用信号的方式，而是用其特有的Event事件进行的通信)，使得Nginx可以在不间断服务的情况下进行配置文件，甚至是二进制文件的平滑升级操作，信号的含义可以参见ngx_config.h，信号处理参见ngx_process.c:ngx_signal_handler，在信号处理文件中其实也只是设置一些状态变量，然后在进程的时间循环中去执行相应的操作，比如向worker process发送特定信号、启动worker process等。</p>
<h3 id="2-3-1_Nginx配置文件平滑升级">2.3.1 Nginx配置文件平滑升级</h3><p>　　通过nginx –s reload或者直接kill -SIGHUP向Nginx master process发送信号，当master process接受到SIGHUP信号的时候：<br>　　a. 检查配置文件，然后打开新的listen socket和日志文件，如果失败则让old nginx继续执行，否则<br>　　b. 创建新的worker process，同时向old worker process发送信息，让他们graceful关闭，old worker process会关闭侦听套接字，服务已经连接的客户，当所有连接客户服务完了之后退出</p>
<h3 id="2-3-2_Nginx二进制程序平滑升级">2.3.2 Nginx二进制程序平滑升级</h3><p>　　将新的二进制文件拷贝覆盖原二进制执行文件，然后向master process发送SIGUSR2信号，当master process接收到该信号的时候：<br>　　a. 将pid文件重新命名为nginx.pid.oldbin<br>　　b. 执行新的可执行文件，按照常规的路径会产生new master process和new worker process，此时新老进程全部并存，并且全部正常工作——接受客户端连接请求和服务客户端<br>　　c. 向old master process发送SIGWINCH，其将会把自己所有的old master workers关闭，注意此时old master process的侦听套接字仍然工作的，必要时候还是会自动产生自己的worker process。调试新版本升级是否正常：如果正常就向old master process发送SIGQUIT，加上之前SIGWINCH工作所有的old process清理完毕；如果不正常，向old master process发送SIGHUP产生worker process，同时向new master process发送SIGTERM信号立即清理所有的new worker process，然后使用SIGKILL杀死new master process</p>
<h2 id="2-4_其它">2.4 其它</h2><p>　　Nginx这样的设计策略，在某些情况下也可能会出问题。<br>　　在Linux系统有一个重要参数/proc/sys/vm/overcommit_memory，当其值=0的时候表示采用启发式的内存管理，进程可以申请比当前空闲内存更多的内存需求，这主要是出于进程申请的内存很多情况下不会立即被使用，甚至在进程的整个生命周期也不会被用到，通过这种overcommit机制实际上是对内存资源最大化利用的一种优化，但是当进程的内存在需要使用的时候(兑现)可能会出现Out Of Memory的情况，此时操作系统就有这么一个机制：通过杀死一些普通进程来释放内存，以维持基本系统和大多数业务的正常运转，也是在极端情况下“弃车保帅、李代桃僵”的无奈之举，这种行为被称为OOM-killer。<br>　　此时需要牺牲哪个进程呢？内核有一套评分标准，进程的得分可以通过/proc/<pid>/oom_score来访问，针对这个分数的计算有两套标准：<br>　　<strong>早期内核</strong><br>　　早期内核会把进程内存空间大小(p-&gt;mm-&gt;total_vm)作为起始分数，然后通过进程的CPU使用时间(tms_utime+tms_stime)、进程的运行时间(jiffies - p-&gt;start_time)、进程的优先级调整值(nice)、进程的权限(root)、进程是否直接访问硬件(direct hardware access)来对这个points进行修正，以实现这样的一种选择模型：对已经完成的工作损失最小、可以获得大量的空闲内存、不会杀死虽然大量使用内存但是无辜的进程、尽量最小化牺牲进程的数目(最好是1个)。<br>　　内核采用/proc/<pid>/oom_adj接口来实现对最终badness的调整，实际是对badness()计算的结果采用bitshift移位的方式进行，其取值范围是-16~+15(-17表示将当前进程完全排除在kill候选之外)，当oom_adj&gt;0时，则badness&lt;&lt;=oom_adj，否则badness&gt;&gt;=-(oom_adj)。<br>　　<strong>当前内核</strong><br>　　当前内核对point的计算进行了简化重写，以实现更简单、更可预测性的启发式功能。其初始point值就是进程对应的RSS(Resident Set Size)+pagetable+swap space，然后通过进程的权限进行调整后就可以用了。这种方式得到的值采用原来oom_adj类似指数型的调整就不合适，所以内核提供了/proc/<pid>/oom_score_adj的接口进行线型调整，其取值范围为-1000~1000。<br>　　在父进程创建子进程的时候，前面的adj会被继承下去。</pid></pid></pid></p>
<p>　　在了解到上面的背景后，<a href="http://mogu.io/159-159" target="_blank" rel="external">文章</a>提到的现象也是可以理解的，Nginx创建的worker进程是非特权进程(运行时间短、内存消耗多)，很有可能在OOM情况下被牺牲，而master进程得知工作进程退出后，会尝试重建worker进程，于是上演了上面这么一出。</p>
<p>本文完！</p>
<h1 id="参考">参考</h1><ul>
<li><a href="https://github.com/nginx/nginx" target="_blank" rel="external">GitHub Nginx</a></li>
<li><a href="http://blogs.datalogics.com/2013/09/25/threads-vs-processes-for-program-parallelization/" target="_blank" rel="external">THREADS VS. PROCESSES FOR PROGRAM PARALLELIZATION</a></li>
<li><a href="http://elinux.org/images/1/1c/Ben-Yossef-GoodBadUgly.pdf" target="_blank" rel="external">On Threads, Processes and Co-Processes</a></li>
<li><a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html" target="_blank" rel="external">POSIX thread (pthread) libraries</a></li>
<li><a href="https://docs.oracle.com/cd/E19455-01/806-5257/6je9h033a/index.html" target="_blank" rel="external">Extending Traditional Signals</a></li>
<li><a href="http://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_40.html" target="_blank" rel="external">Pthreads Programming Chapter 5 - Pthreads and UNIX Threads and Signals </a></li>
<li><a href="/201604/server-prog-port-from-windows-to-linux.html">Windows服务端程序向Linux平台移植事项</a></li>
<li><a href="http://blog.csdn.net/21aspnet/article/details/7420091" target="_blank" rel="external">深刻理解Linux进程间通信（IPC）</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="external">Inside NGINX: How We Designed for Performance &amp; Scale</a></li>
<li><a href="http://www.aosabook.org/en/nginx.html" target="_blank" rel="external">The Architecture of Open Source Applications – NGINX</a></li>
<li><a href="http://nginx.org/en/docs/control.html" target="_blank" rel="external">Controlling nginx</a></li>
<li><a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="external">Socket Sharding in NGINX Release 1.9.1</a></li>
<li><a href="http://linuxgazette.net/129/saha.html" target="_blank" rel="external">Issues In Concurrent Server Design on Linux Systems - Part I</a></li>
<li><a href="https://anturis.com/blog/nginx-vs-apache/" target="_blank" rel="external">Nginx vs Apache</a></li>
<li><a href="http://mogu.io/159-159" target="_blank" rel="external">Linux内核分析： OOM杀掉nginx后导致的系统hang问题</a></li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/201611/about-multi-process-thread-dev-manage.html">浅谈多进程程序的进程控制和管理方式</a></p>
        <p><span>最后更新:</span>2017-02-05, 15:45:39</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/201611/about-multi-process-thread-dev-manage.html" title="浅谈多进程程序的进程控制和管理方式">https://taozj.org/201611/about-multi-process-thread-dev-manage.html</a>
            <span class="copy-path" data-clipboard-text="原文: https://taozj.org/201611/about-multi-process-thread-dev-manage.html　　作者: taozj" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 请勿以任何形式转载文章完整正文
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/201611/learn-note-of-distributed-system-(1)-abstraction-and-2PC-3PC.html">
                    分布式系统入门笔记（一）：分布式系统基本概念和两三阶段提交
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/201611/transform-work-env-to-mac-os.html">
                    macOS新平台工作环境的设置和迁移
                </a>
            </div>
        
    </nav>


  
  
     <! -- 添加捐赠图标 -->

    

    <div class ="post-donate">
      <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="Donate 打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
           
            欣赏此文？赏份狗粮！
                     
        </span>
        <br>
      </div>  
  
      <div id="donate_guide" class="donate_bar center hidden">
        
          <a href="/post_images/resources/alipay.png" title="支付宝打赏" class="fancybox" rel="article0"       style="float:left;margin-left:25%;margin-right:2px;">
          <img src="/post_images/resources/alipay.png" title="支付宝打赏" height="164px" width="164px">
          </a> 
          

      
       <a href="/post_images/resources/weixin.png" title="微信打赏" class="fancybox" rel="article0">
         <img src="/post_images/resources/weixin.png" title="微信打赏" height="164px" width="164px">
       </a>
      
    
      </div>
  
      <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
          $('#donate_board').addClass('hidden');
          $('#donate_guide').removeClass('hidden');
        }
      </script>
    </div>

    

<! -- 添加捐赠图标 -->


  
</article>





    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="201611/about-multi-process-thread-dev-manage.html" data-title="浅谈多进程程序的进程控制和管理方式" data-url="https://taozj.org/201611/about-multi-process-thread-dev-manage.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"freesign"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        <!-- ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//127.0.0.1:4000/js/embed.js'; -->
        ds.src = '/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/201611/learn-note-of-distributed-system-(1)-abstraction-and-2PC-3PC.html" title="上一篇: 分布式系统入门笔记（一）：分布式系统基本概念和两三阶段提交">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/201611/transform-work-env-to-mac-os.html" title="下一篇: macOS新平台工作环境的设置和迁移">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(5)-message-queue.html">后台开发那些常用技术再次小结（五）：消息队列</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(4)-cache.html">后台开发那些常用技术再次小结（四）：缓存部分</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/cmake-cheatsheet.html">CMake工具使用手册</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(3)-storage.html">后台开发那些常用技术再次小结（三）：存储部分</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(2)-web-service.html">后台开发那些常用技术再次小结（二）：Web服务层</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(1)-front.html">后台开发那些常用技术再次小结（一）：前端部分</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/little-thoughts-at-the-begin-of-2017.html">2017年春节返途中的两三思考</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/gnu-gdb-debug.html">GNU GDB调试手册</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/https-principle.html">HTTPS原理简单介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/rpc-principle-and-tips.html">RPC设计和使用中的一些杂谈</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/learn-note-of-distributed-system-(6)-application.html">分布式系统入门笔记（六）：基于ZooKeeper的分布式系统的应用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/learn-note-of-distributed-system-(5)-zab-consensus.html">分布式系统入门笔记（五）：ZooKeeper之ZAB一致性协议</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/blog-collection.html">【置顶】博客资源收录大全</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/linux-performance-basic.html">Linux服务器的那些性能参数指标</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/cmd-tools-sed-awk.html">文本处理利器sed与awk使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/install-gentoo-root-zfs-on-macbookpro-2015-early.html">MacbookPro上基于ZFS的Gentoo双系统安装</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/learn-note-of-distributed-system-(4)-raft-consensus.html">分布式系统入门笔记（四）：Raft一致性算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/read-note-of-amazon-dynamo.html">Amazon Dynamo论文阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/consistent-hashing.html">一致性hashing的原理解析</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/nginx-load-balancing.html">基于Nginx的软件负载均衡实现解读</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/study-conclusion-stage.html">【置顶】个人阶段性学习和规划总结(技能树)</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/design-patterns-(3)-behavioral.html">设计模式整理总结（三）：行为型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/design-patterns-(2)-structural.html">设计模式整理总结（二）：结构型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/http2-spec.html">HTTP/2协议规范和特性解读</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/learn-note-of-google-grpc.html">Google gRPC框架学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/tcp-connection-keep-alive.html">网络开发中客户端连接保鲜机制的实现方法</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/design-patterns-(1)-creational.html">设计模式整理总结（一）：创建型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/forkp-mulit-process-manage-framework.html">forkp多进程程序管理库的轮子</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-distributed-system-(3)-see-paxos-from-phxpaxos.html">分布式系统入门笔记（三）：从PhxPaxos中再看Paxos协议工程实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-tencent-libco-coroutine.html">腾讯libco协程库学习使用笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/libto-coroutine-library-base-on-boost-context2.html">基于Boost.Context2库的协程库轮子libto的设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-distributed-system-(2)-paxos-algorithm.html">分布式系统入门笔记（二）：Paxos算法介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-distributed-system-(1)-abstraction-and-2PC-3PC.html">分布式系统入门笔记（一）：分布式系统基本概念和两三阶段提交</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/about-multi-process-thread-dev-manage.html">浅谈多进程程序的进程控制和管理方式</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/transform-work-env-to-mac-os.html">macOS新平台工作环境的设置和迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/introduction-of-boost-context-and-new-coroutine-library.html">Boost.Context库简介及Boost.Coroutine协程使用方式</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(4)-sort.html">数据结构和算法（四）：主流内排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(3)-rbtree.html">数据结构和算法（三）：红黑二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(2)-avl.html">数据结构和算法（二）：AVL自平衡二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(1)-hash.html">数据结构和算法（一）：hash散列容器</a></li><li class="post-list-item"><a class="post-list-link" href="/201610/talk-about-singleton.html">说说设计模式中的单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/basics-of-boost-asio-(3)-strand.html">Boost-Asio网络开发基础知识（三）：Strand序列化执行用户回调</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/basics-of-boost-asio-(2)-overview-of-the async-framework.html">Boost.Asio网络开发基础知识（二）：异步框架总览</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/basics-of-boost-asio-(1)-read-the-docs.html">Boost.Asio网络开发基础知识（一）：读读文档</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/cpp11-atomic-and-memory-model.html">C++11标准中的Atomic原子操作和内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/lockless-in-multi-thread.html">多线程开发中无锁队列的设计和实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/talk-about-io-seperation-design.html">开发中IO分离设计的重构杂谈</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/learn-note-of-protobuf.html">Google Protobuf数据交换格式的使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/read-(linux-mulit-thread-server-develop).html">《Linux多线程服务端编程》读摘</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/usage-of-boost-coroutine.html">Boost.Coroutine协程库的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/201608/feeling-of-cpp-11-and-two-ticks.html">C++11新标准阶段性学习心得及两个小轮子分享</a></li><li class="post-list-item"><a class="post-list-link" href="/201608/some-refined-and-modification-this-site.html">关于近来本站点的一些修改和设置</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/learn-note-of-boost-(1)-smart-ptr-memory-pool.html">Boost库学习笔记(一)：智能指针和内存池</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/simple-digit-recong-base-on-tesseract.html">基于Tesseract的数字识别程序</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/construct-running-close-of-tcp.html">TCP链接的建立和关闭过程</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/design-and-impl-of-minicached-base-on-memcached.html">基于memcached原理实现的单机轻量级通用缓存库</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/learn-note-of-libevent-(3)-internel-impl-and-framework.html">Libevent学习笔记（三）：内部实现原理初探</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(4)-dns-proxy-support.html">基于Libevent转发的内网端口暴露（四）：添加DNS代理的功能</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/read-(the-art-of-sober-thinking).html">读《清醒思考的艺术》感</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/personalized-reading-based-on-content-recommendation-(2)-svd-impl.html">基于内容推荐的个性化阅读实现（二）：基于SVD的推荐算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(3)-ss5-proxy-support.html">基于Libevent转发的内网端口暴露（三）：添加SS5代理功能</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(2)-refined-and-improvement.html">基于Libevent转发的内网端口暴露（二）：优化重构</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(1)-basic-impl.html">基于Libevent转发的内网端口暴露（一）：基本实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/personalized-reading-based-on-content-recommendation-(1)-general-impl.html">基于内容推荐的个性化阅读实现（二）：基本实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/principle-of-oauth2.html">互联网OAuth 2.0开放授权原理</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/data-type-and-index-of-mysql-database.html">MySQL数据类型整理和索引介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/auto-answer-recommend-conclusion.html">答案自动推荐模块项目小结</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/learn-note-of-libevent-(2)-thread-pool-in-memcached.html">Libevent学习笔记（二）：Memcached中Libevent和线程池使用初探</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/fastcgi-support-for-http-server-libmicrohttpd.html">对libmicrohttpd添加FastCGI协议支持</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/learn-note-of-libevent-(1)-basic-usage.html">Libevent学习笔记（一）：基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/usage-of-apache-lucy-fulltext-index.html">Apache Lucy的全文检索引擎的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/fulltext-search-based-on-lsi-lda.html">基于LSI/LDA的文本检索的原理和操作步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/linux-env-program-(2)-difference-select-poll-epoll.html">Linux环境开发（二）：IO复用之select/poll/epoll之原理和差异分析</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/linux-env-program-(1)-async-blocking-io-model.html">Linux环境开发（一）：同异步、阻塞的IO模型相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/oversee-of-http-based-on-libmicrohttpd.html">基于libmicrohttpd的HTTP服务器初探</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/server-prog-port-from-windows-to-linux.html">Windows服务端程序向Linux移植经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/recommend-system-algorithm.html">推荐系统常用的推荐算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/recommend-system-cases.html">推荐系统的典型推荐案例</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/how-to-calc-svd.html">SVD的数学计算步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/conclusion-of-machine-learning-algorithm.html">不带公式的机器学习算法整理</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/random-sampling-method.html">随机采样方法</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/statistics-frequency-bayesian.html">统计学之边角料——频率派和贝叶斯派</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-spark-(3)-relative-modules.html">Spark学习手册（三）：Spark模块学习摘读</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-spark-(2)-read-official-doc.html">Spark学习手册（二）：Spark官方手册读摘</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-spark-(1)-construct-spark-hdfs.html">Spark学习手册（一）：HDFS支撑的Spark环境搭建与尝试</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-pro-git.html">Pro Git速查笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/interesting-cases-of-machine-learning.html">深度学习的那些有趣案例</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/how-to-love-dog.html">我的养狗笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/one-year-old-of-my-zaizai.html">我们仔仔快要一岁啦</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/how-to-survive-from-info-ocean.html">面对越来越多的信息我们是怎么了</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/encrypt-safe-your-file-and-email-gpg.html">请善用GPG安全你的邮件和文件</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/blog-site-under-https.html">我的博客用上HTTPS啦</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/learn-note-of-numpy.html">NumPy科学计算库学习记录</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/leave-tp-link-at-2015.html">2015年工作总结——离开TP之路</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/read-(i-am-in-taobao-these-ten-years).html">读《淘宝技术这十年》感</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/usage-and-optimize-of-zfs.html">终极文件系统ZFS的使用与优化技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/setup-dev-env-for-pebble-smartphone.html">Pebble嵌入式开发环境搭建和开发测试样例</a></li><li class="post-list-item"><a class="post-list-link" href="/201601/read-(the-mystery-of-silicon-valley).html">读《硅谷之谜》感</a></li><li class="post-list-item"><a class="post-list-link" href="/201601/conclusion-of-machine-learning.html">机器学习中自然语言处理之总结</a></li><li class="post-list-item"><a class="post-list-link" href="/201601/gentoo-overlay-and-software-recommend.html">我的Gentoo Overlay和Linux软件推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/201510/docker-examples.html">Docker容器技术使用实例</a></li><li class="post-list-item"><a class="post-list-link" href="/201510/mail-server-based-on-postfix-dovecot.html">搭建基于Postfix和Dovecot的邮件服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/201509/rpmbuild-package-example-(2).html">RedHat系列软件打包实例（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/201509/rpmbuild-package-example-(1).html">RedHat系列RPM软件打包实例（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/201509/generate-makefile-through-autotools.html">利用autotools自动生成项目的Makefile</a></li><li class="post-list-item"><a class="post-list-link" href="/201508/keepass-pass-save.html">开源的个人密码管理器软件KeePass</a></li><li class="post-list-item"><a class="post-list-link" href="/201508/learning-and-debug-linux-kernel-under-windows.html">在Windows下通过虚拟机搭建Linux内核的学习和调试环境</a></li></ul>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2017 taozj
            </div>
            <div class="footer-right">
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">
                    <img src="/post_images/icons/icp_min.png" alt="粤ICP备17002382号-1">粤ICP备17002382号-1
                </a>
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258402767'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1258402767%26online%3D2' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>, theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a>  enhanced by Nicol <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>
<script src="/js/search.js"></script> 


    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>


   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</script>

  </div>
</body>
</html>