<?xml version="1.0" encoding="utf-8"?>
<search>
    <entry>
        <title>
            <![CDATA[Github博客搭建过程]]>
        </title>
        <url>https://zhuqiuhui.github.io/2017/03/github-blog-setup.html</url>
        <content type="html">
            <![CDATA[<h1 id="一、基本环境配置">一、基本环境配置</h1>
                            <h2 id="1-1_Github账号注册">1.1 Github账号注册</h2>
                            <p>　　如果你没有<a href="https://github.com/" target="_blank">Github账号</a>，旁边空地上做1000个蹲起先，Github账号已经成为了一个高素质程序员的ID，具体怎么注册，怎么使用自己好好摸索一下（个人认为要深入理解Git的原理是很有好处的，目前大部分公司都采用的是Git分支开发流程）。
                                <br>　　有了Github账号，首先clone下自己喜欢的主题（见本文参考部分），把结构（下节讲）熟悉下后就可以自己反复地commit就行了，其实就是这么简单，比较花费时间的是排版格式问题（排版成自己喜欢的样式或者结构）。
                            </p>
                            <h2 id="1-2_Jekyll本地安装">1.2 Jekyll本地安装</h2>
                            <p>　　Jekyll集成了一个开发用的服务器，可以让你使用浏览器在本地进行预览。读者可以根据自己本地的电脑环境来安装jekyll，安装流程可以参考<a href="http://jekyll.com.cn/" target="_blank">jekyll官方主页</a>，你可能在安装过程中遇到过很多问题（我的是mac，遇到过很多问题），具体解决方案比较全面的可以参考文章<a href="https://segmentfault.com/a/1190000007243257" target="_blank">《Jekyll搭建个人博客》</a>。
                            </p>
                            <h1 id="二、Github网站结构">二、Github网站结构</h1>
                            <p>　　以本网站的代码结构为例，见下图：<br>
                            <img src="/post_images/images/2017/03/blog_file_folder.png" title="我的代码结构" /><br>
                            <ul>
                                <li>tags：里面存放的是博文的标签，根据不同的标签把博文的title信息放到相应的标签文件夹中</li>
                                <li>post_images：里面存放的是博文中的图片</li>
                                <li>page：初次跳到网站主面对就的分页内容</li>
                                <li>need_html：存放一些小需求的html</li>
                                <li>categories：存放的是不同类别博客下的title信息</li>
                                <li>Blogs：里面存放的是完整的博文，根据不同的时间把博文放到相应的时间文件夹中</li>
                                <li>archives：以年份的形式把本年度所写博客的title信息列表出来</li>
                                <li>about：与博主有关的相关信息</li>
                            </ul>
                            明白以上代码结构，再加上不断地熟悉，并尝试新建一篇，便很快能掌握，喜欢的或者不明白的请在下面留言（及时回复），谢谢大家！
                            </p>
                            <p>本文完！</p>
                            <h1 id="参考">参考</h1>
                            <ul>
                                <li><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a></li>
                                <li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档主页</a></li>
                                <li><a href="https://github.com/zhuqiuhui" target="_blank" rel="external">我的Github主页</a></li>
                                <li><a href="http://huangxuan.me/" target="_blank" rel="external">参见博客主题一</a></li>
                                <li><a href="http://baixin.io/" target="_blank" rel="external">参见博客主题二</a></li>
                                <li><a href="http://www.ezlippi.com/" target="_blank" rel="external">参见博客主题三</a></li>
                                <li><a href="http://moxfive.xyz/" target="_blank" rel="external">参见博客主题四</a></li>
                            </ul>
]]></content>
    </entry>
    <entry>
        <title>
            <![CDATA[基于WebMagic的CSDN博客爬虫]]>
        </title>
        <url>https://zhuqiuhui.github.io/2017/03/webmagic-csdn-crawler.html</url>
        <content type="html">
            <![CDATA[<h1 id="一、基本jar包">一、基本jar包</h1>
                            <p>　　本文用到的是pom文件，自动导入jar包，可参考<a href="http://webmagic.io/docs/zh/posts/ch2-install/with-maven.html">pom包</a>，如果不使用pom.xml构建，可导入相应的jar包就可以了，参见<a href="http://webmagic.io/docs/zh/posts/ch2-install/without-maven.html">不使用pom构建</a>。
                            </p>
                            <h1 id="二、CSDN爬取博客信息示例">二、CSDN爬取博客信息示例</h1>
                            <p>　　本例测试了<a href="http://blog.csdn.net/zhuqiuhui">zhuqiuhui的专栏</a>下博客title信息的爬取例子，代码参见<a href="https://github.com/zhuqiuhui/CrawlerTest">Github代码</a>。
                            </p>
                            <h1 id="二、pdf电子书爬取示例">二、pdf电子书爬取示例</h1>
                            <p>　　本例测试了爬取电子书的测试例子，相关代码用到了cookie(写爬虫时遇到登录情况必须要使用到cookie)，代码参见<a href="https://github.com/zhuqiuhui/CrawlerTest">Github代码</a>。
                            </p>
                            <p>喜欢的或者不明白的请在下面留言（及时回复），谢谢大家！本文完！</p>
                            <h1 id="参考">参考</h1>
                            <ul>
                                <li><a href="http://webmagic.io" target="_blank" rel="external">Web Magic</a></li>
                                <li><a href="http://blog.csdn.net/qq598535550/article/details/51287630" target="_blank" rel="external">基于WebMagic写的一个csdn小爬虫</a></li>
                            </ul>
]]></content>
    </entry>
    <entry>
        <title>
            <![CDATA[MySQL日志文件配置]]>
        </title>
        <url>https://zhuqiuhui.github.io/2017/03/mysql-log-configuration.html</url>
        <content type="html">
            <![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;开发过程中遇到的sql问题，总想看下数据库执行的日志，便研究了下怎么看sql操作日志的方法，特分享如下，看了很多资料，都写的不是太全，总结了一下，希望支持。</p>
                            <h1 id="my.cnf文件查找">一、my.cnf文件查找</h1>
                            <p>&nbsp;&nbsp;&nbsp;&nbsp;不同的操作系统my.cnf放的位置是不一样的。</p>
                            <p>
                                <ol>
                                    <li>windows下mysql配置文件存放在“C:/Program Files/MySQL/MySQL Server 5.5/my.ini”下。</li>
                                    <li>Mac OS X中默认是没有my.cnf文件的，需要对mysql进行定制的（定制过程见第二节）。</li>
                                    <p>
                                        验证Mac下没有my.cnf文件，可使用命令:
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">sudo find / -name my.cnf</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        <br> 进行搜索一下，搜索结果什么也没有，便得以验证。也可以使用命令：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">sudo mysql --help | grep my.cnf</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        来查看下有关my.cnf的help信息，该命令在mac上的搜索结果如下：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td>
                                                    <td class="code"><pre><div class="line">Default options are read from the following files in the given order:</div><div class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        官方的解释是：
                                        <br><code>You can now check for files using the above output at /etc/my.cnf, then /etc/mysql/my.cnf and so on. If there isn't one at one of those locations, you can create one and know MySQL will use it.</code>
                                        <br>意思是在上述路径中没有找到my.cnf的话，你就可以新建一个my.cnf了。
                                    </p>
                                </ol>
                            </p>
                            <h1 id="my.cnf定制及日志文件配置">二、my.cnf定制及日志文件配置</h1>
                            <p>
                                <ol>
                                    <li>首先登录上mysql，查看日志服务是否开启（MySQL默认状态下是未开启日志服务的，即OFF状态）：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">show variables like 'log_bin'</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                    </li>
                                    <li>
                                        开启日志服务（为ON状态就不用开启了，本文针对于OFF状态）。由于mac下没有my.cnf文件，所以可以从目录
                                        <br><code>/usr/local/mysql/support-files/my-medim.cnf</code>
                                        <br>或者
                                        <br><code>/usr/local/opt/mysql/support-files/my-default.cnf</code>
                                        <br>下拷贝任意一个.cnf文件到“/etc”目录下，并且重命名为my.cnf。
                                    </li>
                                    <li>更改my.cnf权限，并添加日志路径配置。使用命令
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">chmod 755 /etc/my.cnf</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        修改my.cnf权限，可读可写权限。然后打开my.cnf文件，找到“[mysqld]”，其下面添加以下内容：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td>
                                                    <td class="code"><pre><div class="line">[mysqld]</div><div class="line"># binlog 配置</div><div class="line">log-bin = /usr/local/var/mysql/logs/mysql-bin.log</div><div class="line">expire-logs-days = 14</div><div class="line">max-binlog-size  = 500M</div><div class="line">server-id        = 1</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        当然，里面的参数可以自己配置，包括路径等。配置完成后，重启mysql服务（mac下本文用brew安装的mysql，可使用mysql.server start/stop启动或者关闭mysql服务），重新登录mysql，重新执行：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">show variables like 'log_bin'</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        已经处于开启“ON”状态。
                                    </li>
                                    <li>查看日志。进行一系列mysql操作后，在上述配置的日志文件目录下查看，便存在了以下文件：
                                        <br><code>mysql-bin.000001   mysql-bin.000002    mysql-bin.index</code>
                                        <br>其中 mysql-bin.index 文件中存放的是日志文件的索引，日志文件如“mysql-bin.000002”可以用shell命令mysqlbinlog来查看，即 “mysqlbinlog mysql-bin.000002”。
                                        <br><code>备注：binlog，即二进制日志,它记录了数据库上的所有改变，改变数据库的SQL语句执行结束时,将在binlog的末尾写入一条记录,同时通知语句解析器,语句执行完毕。查看可使用sql命令“show binlog events in 'mysql-bin.000002';”</code>
                                    </li>
                                </ol>
                            </p>
                            <p><strong>喜欢的或者不明白的请在下面留言（及时回复），谢谢大家！</strong></p>
                            <!--
                            <h1 id="参考">参考</h1>
                            <ul>
                                <li><a href="http://webmagic.io" target="_blank" rel="external">Web Magic</a></li>
                                <li><a href="http://blog.csdn.net/qq598535550/article/details/51287630" target="_blank" rel="external">基于WebMagic写的一个csdn小爬虫</a></li>
                            </ul>-->
                        </div>
                    </div>
]]>
        </content>
    </entry>
    <entry>
        <title>
            <![CDATA[Git基本用法]]>
        </title>
        <url>https://zhuqiuhui.github.io/2017/03/git-usage.html</url>
        <content type="html">
            <![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;Git真是一个强大的工具，由于开发需要，本文特别总结了git的一些常用命令和基本配置，如Git与账户绑定、怎么新建项目和一些Git基本使用命令。</p>
                            <h1 id="Git账户绑定">一、Git账户绑定</h1>
                            <p>&nbsp;&nbsp;&nbsp;&nbsp;在使用Git前要首先进行账户绑定（配置一次就可以了，以后就不用配置了），绑定的时候需要key值，可使用下面命令生成key值：
                                <figure class="highlight bash">
                                    <table>
                                        <tr>
                                            <td class="gutter"><pre><div class="line">1</div></pre></td>
                                            <td class="code"><pre><div class="line">ssh-keygen -t rsa -C "your_email@youremail.com"</div></pre></td>
                                        </tr>
                                    </table>
                                </figure>
                                验证是否配置成功，使用命令：
                                <figure class="highlight bash">
                                    <table>
                                        <tr>
                                            <td class="gutter"><pre><div class="line">1</div></pre></td>
                                            <td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td>
                                        </tr>
                                    </table>
                                </figure>
                            </p>
                            <h1 id="Git下新建项目">二、Git下新建项目</h1>
                            <p>建立项目与Git之间的联系步骤：
                                <ol>
                                    <li>在自己Github主页上新建仓库，如取名：TestGit.git</li>
                                    <li>进入要上传的本地代码主文件夹中（git初始化）：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">git init</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                    </li>
                                    <li>添加远程地址（你要推送到的远程仓库的地址）：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">git remote add origin git@github.com:zhuqiuhui/TestGit.git</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                    </li>
                                    <li> ~ 开发 ~ 开发 ~ 开发 ~</li>
                                    <li>把本地代码存到暂存区：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">git add .</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                    </li>
                                    <li>把本地代码存到本地仓库（最好加上注释）：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">git commit -m "注释"</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                    </li>
                                    <li>把本地代码推送到远程仓库(本测试用例用的是master分支)：
                                        <figure class="highlight bash">
                                            <table>
                                                <tr>
                                                    <td class="gutter"><pre><div class="line">1</div></pre></td>
                                                    <td class="code"><pre><div class="line">git push origin master</div></pre></td>
                                                </tr>
                                            </table>
                                        </figure>
                                        <code>备注：第一次push的话，可能会出现“reject”错误，那是因为远程仓库与本地仓库版本不一致的原因，所以你先执行“git pull origin master”(先拉一下，把远程代码拉到本地)，但在拉的过程中还可能会出现“fatal: refusing to merge unrelated histories”错误，你重新执行下“git pull origin master --allow-unrelated-historie”就可以了，然后再push代码，这样就ok了。</code>
                                    </li>
                                </ol>
                            </p>
                            <h1 id="常用Git命令">三、常用Git命令</h1>
                            <h2 id="基本Git命令">3.1 基本Git命令</h2>
                            <p>
                                <ul>
                                    <li>查看远程分支：git branch -a</li>
                                    <li>查看本地分支：git branch</li>
                                    <li>从当前分支创建b1分支：git branch b1</li>
                                    <li>从当前分支创建b1分支，并切换到b1分支：git checkout -b b1</li>
                                    <li>从master分支创建b1分支，并切换到b1分支：git checkout -b b1 master</li>
                                </ul>
                            </p>
                            <h2 id="Git修改提交注释">3.2 Git修改提交注释</h2>
                            <p>
                                <ul>
                                    <li>修改最后一次提交的信息：git commit --amend</li>
                                    <li>修改前三次历史提交注释信息：git rebase -i head~3
                                        <br><code>备注：显示后把你想要改的第几次前面“pick”改成“edit”，然后接着git commit --amend，改完的话执行git rebase --continue退出即可</code>
                                    </li>
                                </ul>
                            </p>
                            <h2 id="git stash用法">3.3 git stash用法</h2>
                            <p>
                                <ul>
                                    <li>保存当前的修改工作：git stash save "注释内容" （不加注释直接git stash）
                                        <br><code>备注：备份当前工作内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致，同时，将当前的工作区内容保存到Git栈中。</code></li>
                                    <li>恢复最近修改的工作：git stash pop
                                        <br><code>备注： 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。</code></li>
                                    <li>显示Git栈内的所有备份：git stash list</li>
                                    <li>进入指定的stash：git stash apply stash@{2}</li>
                                    <li>移除指定的stash：git stash drop stash@{2}</li>
                                    <li>清空Git栈：git stash clear</li>
                                    <p><strong>具体使用案例：我在develop分支中开发新功能，这时候master分支中有bug急需修改。</strong>
                                        <ol>
                                            <li>git stash （备份当前工作内容）</li>
                                            <li>git checkout master （切换master）</li>
                                            <li>修改提交完master中bug后， git checkout develop (切回develop)</li>
                                            <li>git stash pop (从Git栈中读取最近一次保存的内容，恢复工作区的相关内容)</li>
                                        </ol>
                                    </p>
                                </ul>
                            </p>
                            <h2 id="git reset用法">3.4 git reset用法</h2>
                            <p>首先理解几个概念：
                                <ul>
                                    <li>working directory：工作目录</li>
                                    <li>staging(或称为index) area：暂存区域</li>
                                    <li>git directory(repository)：本地仓库</li>
                                </ul>
                                相关的reset命令：
                                <ul>
                                    <li>git reflog：查看所有分支的所有操作记录（包括commit、reset的操作、已经被删除的commit记录）</li>
                                    <li>git log：查看当前分支的提交日志，但不能察看已经删除了的commit记录</li>
                                    <li>git reset --hard 0254ea7(对应的操作ID)：reset到ID对应的时间点</li>
                                    <li>git reset --hard head~1：reset到最新一次提交之前</li>
                                    <code>备注：
                                    <ul>
                                        <li>--hard参数：重设index和working directory，自从commit以来在working directory中的任何改变都被丢弃，并把HEAD指向commit。</li>
                                        <li>--soft参数：index和working directory中的内容不作任何改变，仅仅把HEAD指向commit。这个模式的效果是，执行完毕后，自从commit以来的所有改变都会显示在git status的"Changes to be committed"中（应用场景：当提交了之后，你又发现代码没有提交完整，或者你想重新编辑一下提交的commit）。</li>
                                    </ul>
                                    </code>
                                </ul>
                            </p>
                            <h2 id="git给远程库添加多个url地址">3.5 git给远程库添加多个url地址</h2>
                            <p><strong>场合：</strong>你可能想要把你的本地的git库，既push到github上，又push到开源中国的Git@OSC上或者coding net上，怎么解决呢？有人可能会用两个甚至多个远程库，即再添加一个远程库git remote add origin2;这个方法很低效，因为你要git push 两次才能完成push到两个库。
                                <br><strong>解答原理：</strong>git的一个远程库可以对应多个地址。
                                <br><strong>基本命令：</strong>
                                <ol>
                                    <li>在本地仓库创建一个指向远程仓库url的链接别名name，可以任意命名：git remote add name url (name可以为origin、both等等自定义的名字)</li>
                                    <li>增加一个远程库地址：git remote set-url --add --push origin url1</li>
                                    <li>再增加一个远程库地址：git remote set-url --add --push origin url2</li>
                                    <li>删除url链接别名name：git remote rm name （常见的为origin）</li>
                                    <li>显示当前所有远程库的详细信息，显示格式为:远程库名字 url连接(类型)，命令：git remote -v</li>
                                    <li>查看config文件，里面可以看到添加的地址，位于当前工程.git/config中，可使用命令：git config -e</li>
                                    <li>推送时只需要执行命令：git push name master，其中name就是url的链接别名，master是推送的分支，要保证几个推送仓库的分支命名是一样的。</li>
                                </ol>
                            </p>
                            <p><strong>未完待续，喜欢的或者不明白的请在下面留言（及时回复），谢谢大家！</strong></p>
                            <!--
                            <h1 id="参考">参考</h1>
                            <ul>
                                <li><a href="http://webmagic.io" target="_blank" rel="external">Web Magic</a></li>
                                <li><a href="http://blog.csdn.net/qq598535550/article/details/51287630" target="_blank" rel="external">基于WebMagic写的一个csdn小爬虫</a></li>
                            </ul>-->
                        </div>
                    </div>
]]></content>
    </entry>
    <entry>
        <title>
            <![CDATA[大数据技能必备]]>
        </title>
        <url>https://zhuqiuhui.github.io/2017/03/big-data-tech.html</url>
        <content type="html">
            <![CDATA[<h1 id="基础篇">一、基础篇</h1>
                            <p>
                                <ol>
                                    <li>几本书参考《Introduction to Data Mining》，这本书很浅显易懂，没有复杂高深的公式，很合适入门的人。另外可以用这本书做参考《Data Mining : Concepts and Techniques》，第二本比较厚，也多了一些数据仓库方面的知识。如果对算法比较喜欢，可以再阅读《Introduction to Machine Learning》。当然，还有《机器学习：实用案例解析》。</li>
                                    <li>实现经典算法，有几个部分：
                                        <ol>
                                            <li>关联规则挖掘 (Apriori, FPTree, etc.)</li>
                                            <li>分类 (C4.5, KNN, Logistic Regression, SVM, etc.)</li>
                                            <li>聚类 (Kmeans, DBScan, Spectral Clustering, etc.)</li>
                                            <li>降维 (PCA, LDA, etc.) </li>
                                            <li>推荐系统 (基于内容的推荐，协同过滤，如矩阵分解等) </li>
                                        </ol>
                                        然后在公开数据集上测试，看实现的效果，可以在下面的网站找到大量的公开数据集：UCI Machine Learning Repository/ 。
                                    </li>
                                    <li>熟悉几个开源的工具: Weka，LibSVM，scikit-learn，Shogun。</li>
                                    <li>到 Kaggle: Go from Big Data to Big Analytics/ 上参加几个101的比赛，学会如何将一个问题抽象成模型，并从原始数据中构建有效的特征 (Feature Engineering)。</li>
                                </ol>
                            </p>
                            <h1 id="进阶篇">二、进阶篇</h1>
                            <p>
                                <ol>
                                    <li>读书，下面几部都是大部头，但学完进步非常大。
                                    <ul>
                                        <li>《Pattern Recognition and Machine Learning》</li>
                                        <li>《The Elements of Statistical Learning》</li>
                                        <li>《Machine Learning: A Probabilistic Perspective》</li>
                                        <code>备注：第一本比较偏Bayesian；第二本比较偏Frequentist；第三本在两者之间，但我觉得跟第一本差不多，不过加了不少新内容。当然除了这几本大而全的，还有很多介绍不同领域的书，例如《Boosting Foundations and Algorithms》，《Probabilistic Graphical Models Principles and Techniques》；以及理论一些的《Foundations of Machine Learning》，《Optimization for Machine Learning》等等。这些书的课后习题也非常有用，做了才会在自己写Paper的时候推公式。</code>
                                    </ul>
                                    </li>
                                    <li>读论文。包括几个相关会议：KDD，ICML，NIPS，IJCAI，AAAI，WWW，SIGIR，ICDM；以及几个相关的期刊：TKDD，TKDE，JMLR，PAMI等。跟踪新技术跟新的热点问题。当然，如果做相关research，这一步是必须的。例如我们组的风格就是上半年读Paper，暑假找问题，秋天做实验，春节左右写/投论文。
                                    </li>
                                    <li>跟踪热点问题。例如最近几年的Recommendation System，Social Network，Behavior Targeting等等，很多公司的业务都会涉及这些方面。以及一些热点技术，例如现在很火的Deep Learning。
                                    </li>
                                    <li>学习大规模并行计算的技术，例如MapReduce、MPI，GPU Computing。基本每个大公司都会用到这些技术，因为现实的数据量非常大，基本都是在计算集群上实现的。</li>
                                    <li>参加实际的数据挖掘的竞赛，例如KDDCUP，或 Kaggle: Go from Big Data to Big Analytics/ 上面的竞赛。这个过程会训练你如何在一个短的时间内解决一个实际的问题，并熟悉整个数据挖掘项目的全过程。
                                    </li>
                                    <li>参与一个开源项目，如上面提到的Shogun或scikit-learn还有Apache的Mahout，或为一些流行算法提供更加有效快速的实现，例如实现一个Map/Reduce平台下的SVM。这也是锻炼Coding的能力。
                                    </li>
                                </ol>
                            </p>
]]></content>
    </entry>
    <entry>
        <title>
            <![CDATA[Guava简介]]>
        </title>
        <url>https://zhuqiuhui.github.io/2017/03/guava-api-collect.html</url>
        <content type="html">
            <![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;Guava 是一个 Google 的基于 java1.6的类库集合的扩展项目，包括 collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O 等等，这些高质量的 API 可以使你的JAVa代码更加优雅，更加简洁，让你工作更加轻松愉悦。</p>
                            <h1 id="Guava简介">一、Guava简介</h1>
                            <p>
                                <ul>
                                    <li>com.google.common.annotations：普通注解类型。</li>
                                    <li>com.google.common.base：基本工具类库和接口。 </li>
                                    <li>com.google.common.cache：缓存工具包，非常简单易用且功能强大的JVM内缓存。</li>
                                    <li>com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类，这里你会发现很多好玩的集合。</li>
                                    <li>com.google.common.eventbus：发布订阅风格的事件总线。</li>
                                    <li>com.google.common.hash： 哈希工具包。</li>
                                    <li>com.google.common.io：I/O工具包。</li>
                                    <li>com.google.common.math：原始算术类型和超大数的运算工具包。</li>
                                    <li>com.google.common.net：网络工具包。</li>
                                    <li>com.google.common.primitives：八种原始类型和无符号类型的静态工具包。</li>
                                    <li>com.google.common.reflect：反射工具包。</li>
                                    <li>com.google.common.util.concurrent：多线程工具包。</li>
                                </ul>
                            </p>
                            <h1 id="常用集合类">二、常用集合类</h1>
                            <p>
                                <ul>
                                    <li><strong>Multimap接口：可以存放一个key值对应多个value实体，</strong>其子接口有ListMultimap、SetMultimap、SortedSetMultimap，实现类有ArrayListMultimap, ForwardingListMultimap, ForwardingMultimap, ForwardingSetMultimap, ForwardingSortedSetMultimap, HashMultimap, ImmutableListMultimap, ImmutableMultimap, ImmutableSetMultimap, LinkedHashMultimap, LinkedListMultimap, TreeMultimap。</li>
                                    <li><strong>BiMap接口：存放key和value均唯一的实体，其父接口是Map接口，</strong>实现类有：EnumBiMap（key和valu都是enum类型）, EnumHashBiMap, HashBiMap（key和value都有HashMap实现）, ImmutableBiMap（不可修改的BiMap）。</li>
                                    <li><strong>Multiset接口：能存放相同的元素，且元素之间的顺序是无序的。</strong>常用的实现类有：HashMultiSet(元素存放于HashMap中)、LinkedHashMultiset(元素存放于LinkedHashMap中)、TreeMultiset（元素被排序存放于TreeMap中）、EnumMultiset（元素是enum类型）、ImmutableMultiset（不可修改的Multiset）。</li>
                                    <li><strong>Immutable类集合：该类集合里面存放的是不可变对象，好处是保证线程安全、可以作为常量等，</strong>常用的有ImmutableCollection、ImmutableList、ImmutableSet、ImmutableSortedSet、ImmutableMap、ImmutableSortedMap、ImmutableMultiset、ImmutableSortedMultiset、ImmutableMultiMap、ImmutableListMultiMap、ImmutableSetMultiMap、ImmutableBiMap、ImmutableTable等。</li>
                                    <li><strong>Range：该类提供了和区间计算相关的数据结构及操作。</strong></li>
                                    <li><strong>RangeSet接口：用来处理一系列不连续，非空的range。</strong>当添加一个range到一个RangeSet之后，任何有连续的range将被自动合并，而空的range将被自动去除。其实现类有：ImmutableRangeSet、TreeRangeSet。</li>
                                    <li><strong>RangeMap接口：它将不相交、且不为空的Range(作为key)映射给一个值（value）</strong>，其实现类有ImmutableRangeMap、TreeRangeMap。</li>
                                    <li><strong>Preconditions：工具类base中，用于提供参数检验，</strong>其方法均为static类型的，可使用如：Preconditions.checkNotNull(student)。</li>
                                    <li><strong>Splitter：从输入的字符串中抽取不重复的子串，通常是分析给定的分割序列。</strong></li>
                                    <li><strong>Lists类：主要提供了对List类的子类构造以及操作的静态方法，其方法都是静态的。</strong></li>
                                    <li><strong>Iterators类：提供了返回Iterator类型的对象或者对Iterator类型对象操作的方法。</strong></li>
                                    <li><strong>HashBiMap：实现了BiMap接口，继承了Abstract类，存储的键值都唯一。</strong></li>
                                    <li><strong>ArrayListMultimap：Multimap接口的ArrayList方法实现的类。</strong></li>
                                    <li><strong>SetMultimap接口：实现了Multimap接口，子类实例中同一个key不能存储相同的value，</strong>实现类有：ForwardingSetMultimap, ForwardingSortedSetMultimap, HashMultimap, ImmutableSetMultimap, LinkedHashMultimap, TreeMultimap。</li>
                                    <li><strong>AbstractSetMultimap：抽象类，实现SetMultimap接口，其具体实现都是调用了AbstractMapBasedMultimap类中的相应实现，只是将AbstractMapBasedMultimap类中返回类行为collection改为Set。</strong></li>
                                    <li><strong>SortedSetMultimap接口：其实现类中key对应的value是有序的。</strong></li>
                                    <li><strong>TreeMultimap：实现了Multimap接口，其中的key和value都是根据默认的自然排序或者用户指定的排序规则排好序的。</strong></li>
                                </ul>
                            </p>
]]></content>
    </entry>
    <search/>
</search>
