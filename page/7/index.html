<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>桃子的博客铭</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="淡泊明志，宁静致远！">
<meta property="og:type" content="website">
<meta property="og:title" content="桃子的博客铭">
<meta property="og:url" content="https://taozj.org/page/7/index.html">
<meta property="og:site_name" content="桃子的博客铭">
<meta property="og:description" content="淡泊明志，宁静致远！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="桃子的博客铭">
<meta name="twitter:description" content="淡泊明志，宁静致远！">
  
    <link rel="alternative" href="/atom.xml" title="桃子的博客铭" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/iconfont.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">taozj</a></h1>
        </hgroup>

        
        <p class="header-subtitle">高性能、高可用服务端开发</p>
        
        <br>
        
        <p class="header-subtitle">淡泊明志，宁静致远！</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">文章归档</a></li>
                        
                            <li><a href="https://album.taozj.org">个人相册</a></li>
                        
                            <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                        
                            <li><a href="/about">请你读我</a></li>
                        
                            <li><a href="/search.html">搜索本站</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作/">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构架/">构架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">taozj</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">taozj</a></h1>
            </hgroup>
            
            <p class="header-subtitle">高性能、高可用服务端开发</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="https://album.taozj.org">个人相册</a></li>
                
                    <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                
                    <li><a href="/about">请你读我</a></li>
                
                    <li><a href="/search.html">搜索本站</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-port-expose-based-on-libevent-(3)-ss5-proxy-support" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/port-expose-based-on-libevent-(3)-ss5-proxy-support.html" class="article-date">
      <time datetime="2016-06-21T10:13:55.000Z" itemprop="datePublished">2016-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/port-expose-based-on-libevent-(3)-ss5-proxy-support.html">基于Libevent转发的内网端口暴露（三）：添加SS5代理功能</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　比较好奇Shadowsocks代理是怎么工作的：为什么这么流行这么火？而且实际用起来的速度比vpn、https等代理的速度快的多！查了一下，其是基于sockets5（后面简称ss5）的代理，而ss5的规范文档RFC1928/RFC1929就两三页，算是我看到的最简短的RFC文件了。实际数据流上，就是ss_client告诉服务器自己要访问的主机和端口，然后把本地请求的数据发到ss_server，ss_server再请求目标服务器并将得到的结果返回回来。卧槽！这不就是我sshinner做的事情么！！！<br>　　所以在现有的设计上，添加代理支持应该是很简单的：我只需要保证本地应用程序和ss_client通信满足ss5协议之规定，而ss_client和ss_server通信格式完全可以用自己原先设计的一套就好了。其实开始本来想着客户端和服务器的协议也进行模拟，这样就可以直接用Shadowsocks的多个跨平台客户端了，但是后面还是放弃了，因为需要改动的东西太多了。<br>　　如果想要了解ss5协议，除了有上面两个RFC可供参考之外，可以使用wireshark抓包分析（Windows居然没法抓回环网口的包，差评！！！），此外Shadowsocks早期代码也很具有参考价值，只是后来作者引入了Eventloop异步机制，项目显得比较复杂，同时Shadowsocks-libev是基于Libev实现的，我觉得其最强大的是集成了大量的加密解密算法，牛逼啊！</p>
<p><img src="/post_images/images/201606/3835a8737168091573fc0932cae0dd96.jpg" alt="sshinner"></p>
<h1 id="一、概况">一、概况</h1><p>　　前面已经说到了，创建ss5代理比之前我的端口暴露处理在链路上还简单一些，但也有一些挑战。<br>　　端口暴露的程序比如ssh或者mysql，基本都是长链接，所以一旦链路建成就会比较稳定，后面就是不断的数据转发了。<br>　　ss5代理的操作，当我用chrome做测试客户端的时候，发现链接特别多，而且连接拆建特别活跃。这也好理解，因为根据ss5代理协议的规定，在代理之前需要把目标主机和端口号提供给服务器，现在的前端复杂的要死，即使chrome优化的再好：每一个ip:port在所有资源请求完后再关闭连接，也还是会有很多ss5代理的不断建立和释放，而且chrome的请求是多线程并发的，代理请求十分的迅猛。<br>　　这种情况下，对程序的稳定性是一个很大的考验：数据结构操作必须正确，没有严重的内存泄露，没有竞争条件等，不然过不了多久服务就会被拖垮挂掉；客户端也必须由之前的单线程改为多线程的，否则根本发挥不了异步的优势。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/port-expose-based-on-libevent-(3)-ss5-proxy-support.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-port-expose-based-on-libevent-(2)-refined-and-improvement" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/port-expose-based-on-libevent-(2)-refined-and-improvement.html" class="article-date">
      <time datetime="2016-06-16T03:35:34.000Z" itemprop="datePublished">2016-06-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/port-expose-based-on-libevent-(2)-refined-and-improvement.html">基于Libevent转发的内网端口暴露（二）：优化重构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　上面一篇文章发了之后，做了一些稍微的改进：添加了会话起始时候帐户信息加密传输，以及服务端线程池初始化的时候等待完成。然后现在清醒的思考了一下（建议效率低的时候不要写BUG），发现最初的设计过于的简单化，将所有的控制包和数据转发都通过客户端和服务端所建立的唯一连接传输，这样的设计不可避免的会带来一些问题：<br>　　(1) 每次传输需要把包头读出来进行解析，找到目标地址、数据包长度以及本地客户端的映射表然后转发，这个过程中数据会被多次的拷贝，所以效率会很低；<br>　　(2) 所有的数据都走一条链路，那么总体的吞吐量是有限的，尤其当数据量大了的时候对交互软件响应极为不利；<br>　　(3) 对于服务端来说，一个客户会话只有一对bufferevent，那么采用的Libevent/epoll的长处根本没发挥出来，可能这样做的效率还不如长连接；<br>　　(4) 所有鸡蛋都放在一个篮子里面，万一这条线路挂了，那么所有的端口都无法工作，对整个系统的可靠性也不利；<br>　　(5) 最要命的是，原先的设计每个侦听端口映射只能建立一条连接，硬伤啊！</p>
<p><img src="/post_images/images/201606/3835a8737168091573fc0932cae0dd96.jpg" alt="sshinner"></p>
<p>　　对于没有经验的“狗驾驶”来说，重构是再所难免的。</p>
<p><img src="/post_images/images/201606/fedc1532e711f526fc2e757f73e72e74.jpg" alt="日了狗了"><br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/port-expose-based-on-libevent-(2)-refined-and-improvement.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-port-expose-based-on-libevent-(1)-basic-impl" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/port-expose-based-on-libevent-(1)-basic-impl.html" class="article-date">
      <time datetime="2016-06-12T05:39:08.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/port-expose-based-on-libevent-(1)-basic-impl.html">基于Libevent转发的内网端口暴露（一）：基本实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　在写这个程序的时候，报道TeamViewer的服务器被攻陷，黑客借此操控用户的电脑以盗取用户的数据，乃至操控用户的资金账户等敏感信息，然后TeamViewer官方出来辟谣，说是用户自己的弱口令导致的安全漏洞。怎么说呢，TeamViewer用起来确实很方便，而且几乎是全平台支持，不过我不满意的是Linux平台貌似是Wine的，安装的时候还需要安装一大堆的32位的依赖库，作为Gentoo的洁癖佬让我对此无法忍受，所以必要的时候，我愿意用KVM启动一个Windows的虚拟机来应急；而来在Linux上宣称图形界面，浪费带宽，暴殄天物啊！<br>　　内网主机要可以被外网访问，通常实现的路径有：(1)配置内网出口的端口映射表，让内网特定主机的端口暴露出来；(2)在外网主机架设VPN，然后需要通信的主机连接VPN后就在同一个网段了；(3)借助TeamViewer这类的方式，用外网的主机进行数据中转。在现实使用中，(1)比较的难办，除非你在公司很牛逼，或者和网管有非一般的亲密关系才行；(2)用的是比较多的，很多企业WFH(Work From Home)就是这么办的，但是一旦连上VPN，就是一个可信的网段，对于多用户共享十分不安全；于是，(3)这种方式算是最经济最高效的实现方式了。<br>　　其实自己之前写了一个local_forward的小程序来实现这个功能的。现在看看，当时写的真是简单、幼稚啊。正好前面一段时间学了一下Libevent<a href="/201605/learn-note-of-libevent-%281%29-basic-usage.html">Libevent学习笔记（一）：基本使用</a>以及<a href="/201605/learn-note-of-libevent-%282%29-thread-pool-in-memcached.html），这家伙的高效是出了名的，不仅封装了IO复用的细节，而且封装了bufferevent/evbuffer这类数据接口和操作接口，对于网络数据转发正是其用武之地了，于是就谋划着用Libevent这个库写一个通用一点的端口转发框架程序。今天基本完成了，测试FTP(21">Libevent学习笔记（二）：Memcached中Libevent和线程池使用初探</a>、MySQL(3306)工作很好，SSH(22)终端可以工作，但是比较卡顿，而且控制字符异常，80端口用浏览器异常，尚未跟踪结果。</p>
<p><img src="/post_images/images/201606/3835a8737168091573fc0932cae0dd96.jpg" alt="sshinner"></p>
<h1 id="1-_基本原理">1. 基本原理</h1><p>　　整个程序包括SRV/CLT_DAEMON/CLT_USR三个角色，代码由server/client两个部分，配置文件为运行目录下的settings.json，下面模拟场景来说明吧。<br>　　(1) 要下班了，首先在远程服务器192.3.90.76端运行SRV，其读取本地的settings.json文件，决定自己监听在8900端口；<br>　　(2) 把公司内网的电脑启动client -D作为为CLT_DAEMON角色，程序读取settings.json，发现服务器地址为192.3.90.76:8900，读取配置文件中的username、userid，以及本机的mach-uuid信息，连接服务器并发送这些信息；<br>　　(3) 服务器接收到该请求，然后读取数据头和数据体，解析后将该请求添加到某个线程的处理队列，并向该线程发送通知信息；处理线程被激活后检查该会话是否存在，然后建立相应的数据结构和事件侦听；然后向CLT_DAEMON发送OK确认信息；<br>　　(4) CLT_DAEMON接收到服务器确认消息后，就处于等待SRV数据/命令的状态；<br>　　(5) 你吃过饭回家了，想连一下公司的电脑，这时候启动client程序作为CLT_USR，这时候电脑萌逼了，我怎么知道你要跟哪台电脑通信呢？所以你在公司启动的时候，会打印出mach-uuid，你需要把这个记录下来，写到本地的配置文件中再启动；<br>　　(6) CLT_USR带着要会话的mach-uuid连接到服务器。服务器会检查这个mach-uuid是否已经就绪了，如果就绪了就分配到对应的线程，创建bufferevent侦听事件，于是就行成了USR/DAEMON端都被侦听的双工通信管道；接着工作线程向CLT_USR发送OK确认；<br>　　(7) CLT_USR接下来会对每个本地感兴趣的端口都建立listen侦听事件了，然后就默默的“看着你”——你想要做甚？<br>　　(8) 此时的你华丽丽地带端口运行FTP/MySQL/SSH，就会触发USR端的listen事件，在这个时间中会对你连接的套接字添加读事件侦听，同时沿着USR-&gt;SRV-&gt;DAEMON端发送一个特殊的控制帧’T’，触发DAEMON端连接本地的服务，并创建读事件侦听；<br>　　(9) Enjoy yourself。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/port-expose-based-on-libevent-(1)-basic-impl.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-personalized-reading-based-on-content-recommendation-(1)-general-impl" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/personalized-reading-based-on-content-recommendation-(1)-general-impl.html" class="article-date">
      <time datetime="2016-06-01T03:25:53.000Z" itemprop="datePublished">2016-06-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/personalized-reading-based-on-content-recommendation-(1)-general-impl.html">基于内容推荐的个性化阅读实现（二）：基本实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　这一直是本人想做的一个项目，缘由是现在的信息越来越多，越来越廉价，所以我必须想办法能自动挑出我感兴趣的文章，而不是一打开订阅邮箱堆积着好多好多的订阅文章，想要消化这些文章又不知哪里下手。其实以前好像看到说，Twitter已经着手研究这类问题，今后可能Twitter信息将按照用户的喜好程度，而不是时间排序展列了，国内低效著称的某浪不知道有没有着手这方面的研究，还是坐等着山寨呢？<br>　　同时，国内的今日头条算是当前最大的移动端信息聚合平台了，之前使用见他每个文章都有好几个TAG，所以不知道他的推荐算法是不是简单基于标签计算的。之前的<a href="/201604/recommend-system-algorithm.html">推荐算法介绍</a>中，新闻播客类的推荐应该是基于用户的协同推荐比较合适，奈何没有用户群行为数据，所以也就只能考虑基于内容的推荐方式了。</p>
<p><img src="/post_images/images/201606/18e1c5d3f143d1e224cad1484ff8e34f.png" alt="注册界面"></p>
<h1 id="1-_项目的构成">1. 项目的构成</h1><p>　　该项目算是信息聚集分发类，按照信息流程涉及到抓取、存储、分析、分发等功能。信息源目前是提交feed然后服务器定时抓取，用户行为数据包括用户对消息的喜恶评价，并基于用户历史的行为数据，对当时的每条信息计算出一个喜好程度作为推荐。<br>　　整个项目是使用Python搭建的，具体涉及到的库有：</p>
<ul>
<li>http: <a href="http://www.tornadoweb.org/en/stable/">Tornado</a></li>
<li>mysql: <a href="http://torndb.readthedocs.io/en/latest/">torndb</a></li>
<li>feed: <a href="https://github.com/kurtmckee/feedparser">feedparser</a></li>
<li>科学计算: <a href="http://www.nltk.org/">NLTK</a></li>
<li>BeautifulSoup: <a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/">bs4</a></li>
<li>wordcut: <a href="https://github.com/fxsjy/jieba">Jieba</a>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/personalized-reading-based-on-content-recommendation-(1)-general-impl.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-principle-of-oauth2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/principle-of-oauth2.html" class="article-date">
      <time datetime="2016-05-23T10:44:38.000Z" itemprop="datePublished">2016-05-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/principle-of-oauth2.html">互联网OAuth 2.0开放授权原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　OAuth 2.0是一个开放授权协议，是1.0的更新替代版，据说是比1.0简化方便了许多。这个协议是用于授权访问开放资源的，但我觉得对自己最大的方便的是很多网站支持的话，可以方便地用授权账号登陆，而免除注册-激活-登陆这些繁琐的步骤。<br><img src="/post_images/images/201605/6fbb1434f91f270e3d798810f9dc4057.png" alt="OAuth 2.0 图标"></p>
<h1 id="1-_OAuth_2-0_协议介绍">1. OAuth 2.0 协议介绍</h1><h2 id="1-1_OAuth_2-0_授权过程概述">1.1 OAuth 2.0 授权过程概述</h2><p>　　下面，以客户端Web应用程序请求资源的例子(最常见的Authorization Code认证类型)，描述一下OAuth 2.0 授权请求的过程，想必使用过的人(作为Resource Owner)一定很熟悉吧。<br>　　当用户访问这个客户端Web应用程序的时候，会提示选用通过Facebook/Google/Twitter方式登陆；用户点击对应的登陆按钮，然后用户会被导向对应登陆界面，完成登陆后提示是否允许客户端Web应用程序访问自己的某些数据，用户选择允许；接着认证程序将用户导向到redirect URI并附加一个授权码(authentication code)，redirect URI是客户端Web应用注册时候提供的地址，注册时候认证程序会给注册的客户端Web应用client id和client password；用户访问redirect URI，在底层客户端Web应用会将client id，client password和授权码回传给服务器，成功后认证程序返回access token。<br>　　自此，当客户端程序得到了access token，就可以用这个令牌访问申请的资源信息了。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议/">协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/principle-of-oauth2.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-data-type-and-index-of-mysql-database" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/data-type-and-index-of-mysql-database.html" class="article-date">
      <time datetime="2016-05-21T14:34:56.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/data-type-and-index-of-mysql-database.html">MySQL数据类型整理和索引介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <blockquote>
<p>问：数据库有没有建过索引？<br>答：没有。<br>问：居然没有建过索引，查询难道不用索引么！！！<br>答：下一题~~~</p>
</blockquote>
<p>　　数据库的数据库索引对程序员来说是透明的，意味着数据库建立索引之前和之后，你的SQL语句都可以正常运行，索引的运用只是数据库引擎工作时候的优化手段。但是，这不是意味着数据库索引仅仅是数据库设计和运维者的事情，对于一个程序员如果对数据库已有的索引有所了解，还是可以大大优化程序员数据库的查询和修改语句执行效率的，以免你的低效查询语句称为拖累整个系统性能的Black Sheep。<br>　　本文对MySQL/MariaDB数据类型和索引建立、优化进行整理，现在数据库引擎默认都是InnoDB的，而且目前MySQL/MariaDB应用于生产环境时候，应该都是用的这个引擎吧。</p>
<h1 id="一、MySQL的数据类型">一、MySQL的数据类型</h1><h2 id="1-1_数字类型和时间类型">1.1 数字类型和时间类型</h2><p>　　数字类型算是最简单的了，主要差异在于各个类型的取值范围大小限制，和对存储空间字节数的需求。数字类型当然是在满足情况的条件下越短越好，一方面MySQL每行有65535字节长度的限制，同时更宽的数据类型意味着对CPU、内存、磁盘I/O带来压力。</p>
<h3 id="1-1-1_MySQL支持的定点数字类型和占用字节数分别是">1.1.1 MySQL支持的定点数字类型和占用字节数分别是</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYINT</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">SMALLINT</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMINT</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">INTEGER</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">BIGINT</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p>　　在数据库设计的时候，常常看到这些整形有个前缀长度，其实这对其类型本身的存储长度和精度没有影响，只会关系到某些交互式工具显示出来的字符个数。</p>
<h3 id="1-1-2_MySQL支持的浮点（实数）类型和占用字节数为">1.1.2 MySQL支持的浮点（实数）类型和占用字节数为</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">FLOAT(p) [0,24]</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">FLOAT(p) [25,53]</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE,REAL</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>　　计算机的浮点运算都是不精确的，如果要实现精确浮点运算，就需要使用DECIMAL类型。</p>
<h3 id="1-1-3_时间类型">1.1.3 时间类型</h3><p>　　常被使用的是DATE、DATETIME和TIMESTAMP类型，其表示的范围为：</p>
<blockquote>
<p>DATE：’1000-01-01’ to ‘9999-12-31’<br>DATETIME：’1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’<br>TIMESTAMP：’1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC</p>
</blockquote>
<p>　　TIMESTAMP存储的范围比DATETIME要小，但是空间利用率也最高。MySQL支持的时间精度最高为1s，如果更精确的存储，就必须自己定义存储格式了。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/data-type-and-index-of-mysql-database.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-auto-answer-recommend-conclusion" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/auto-answer-recommend-conclusion.html" class="article-date">
      <time datetime="2016-05-21T14:34:39.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/auto-answer-recommend-conclusion.html">答案自动推荐模块项目小结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　这段时间一直在写一个小模块，功能上来说，就是根据客服和用户之间的对话记录进行在线记录(原谅我还不敢用在线学习这么专业的术语，因为目前的实现中确实没有用专业的学习算法，只用到信息检索的技术)，为用户的新问题自动推荐答案。目前在线调测的差不多了，不知道上线试用会是怎么样。借此休息的机会，想对项目做个总结，由于还是自己单干，也希望有经验的伙伴能不吝赐教。</p>
<h1 id="1-_权限最小化选择">1. 权限最小化选择</h1><p>　　　其实权限最小化对各方都有积极的意义：对于整个系统来说，权限最小化可以降低系统出错的风险，而对于个人来说，最小的权限也就意味着可以担当最低的责任，目前这个生产的系统已经连续运行了600多天了，很不容易啊。由于个人的检索模块用的是Lucy，并且依赖于Clownfish，而这两个库都比较小众，各大发行版基本都没收录，所以就只能下载代码本地编译，然后将头文件和链接/运行库放到项目本地，修改Makefile编译参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-I./include/ApacheLucy -I/home/taozj/root/share/clownfish -L/home/taozj/root/lib/ -llucy -lcfish</div></pre></td></tr></table></figure></p>
<p>　　这样，我的服务如果不是要绑定到1024一下的特权端口，这个服务完全就可以普通用户运行了。</p>
<h1 id="2-_积累代码，统一风格">2. 积累代码，统一风格</h1><p>　　开发的过程是要积累的，这不但包含只是经验的积累，还有自己编写调试好的模块也是。自己之前使用的代码都放到<a href="https://github.com/taozhijiang/st_utils">st_utils</a>里面了，这次链表、红黑树、数据库连接池等模块都直接拿来使用了。当然，可能觉得项目集成更好的方式是git submodule，但是这不算是个功能特定的模块，所以此处还是不太合适。<br>　　而外就是个人代码的风格需要一致、统一。就像C函数，有些返回非0表示成功，返回0表示失败；有些返回0表示成功，返回-1表示失败，如果自己的风格不统一的话，很可能写写之后自己都把自己搞晕了。所以模仿Libmicrohttpd的方式，用自己定义的放回类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> RET_TYPE &#123;</div><div class="line">    RET_YES = <span class="number">1</span>,</div><div class="line">    RET_NO  = <span class="number">0</span>,</div><div class="line">&#125; RET_T;</div></pre></td></tr></table></figure></p>
<p>　　这样，自己约定RET_YES正常返回，RET_NO异常返回；而当返回值不表示函数调用的成败，而是具体的计算结果的时候，再用int类型来作为返回类型。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/auto-answer-recommend-conclusion.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-libevent-(2)-thread-pool-in-memcached" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/learn-note-of-libevent-(2)-thread-pool-in-memcached.html" class="article-date">
      <time datetime="2016-05-12T10:58:07.000Z" itemprop="datePublished">2016-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/learn-note-of-libevent-(2)-thread-pool-in-memcached.html">Libevent学习笔记（二）：Memcached中Libevent和线程池使用初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　这些天想弄一下缓存，减少程序查询数据库的压力，而这方面的王者基本就是memcached和redis了。克隆了一份memcached的源码，发现是基于Libevent+线程池的实现方式，大致看了一下感觉很有启发。正好前两天看的Libevent手册，而且相比自己写的<a href="https://github.com/taozhijiang/st_utils">线程池模型</a>，也很好奇企业级线程模型的实现方式，就顺着memcached初始化的流程了解梳理一下了。</p>
<p><img src="/post_images/images/201605/3ff7aa1a8af4a62f0483e7d955872118.jpg" alt="memcached"></p>
<h1 id="1-_main_[memcached-c]">1. main [memcached.c]</h1><p>　　memcached启动时候执行memcached.c中的main函数，在加载了好长的初始化配置之后，定义并初始化event_base；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> event_base *main_base;</div><div class="line">main_base = event_init();</div></pre></td></tr></table></figure></p>
<p>　　然后通过调用memcached_thread_init，创建工作者线程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">memcached_thread_init(settings.num_threads, main_base);</div></pre></td></tr></table></figure></p>
<p>　　创建定时器clock_handler(0, 0, 0);，这个基于Libevent创建的定时器每一秒钟执行一次，用以更新current_time这个表示自从进程启动后的时间长度。<br>　　然后针对服务端参数指定的侦听(ip:port/unix socket)类型，分别调用server_socket_unix/server_sockets函数，绑定指定地址，并为创建的socket添加connect事件，核心代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// unix socket</span></div><div class="line">listen_conn = conn_new(sfd, conn_listening, EV_READ | EV_PERSIST, <span class="number">1</span>,</div><div class="line">                                 local_transport, main_base)))</div><div class="line"><span class="comment">// tcp</span></div><div class="line">listen_conn_add = conn_new(sfd, conn_listening, EV_READ | EV_PERSIST, <span class="number">1</span>,</div><div class="line">                                             transport, main_base))</div></pre></td></tr></table></figure></p>
<p>　　这个conn_new不仅仅在这里用以侦听套接字分配资源、创建事件侦听，之后所有客户端连接的套接字也会用这个函数。这个函数最终回调的响应函数是event_handler，然后最终调用一个碉堡了名字的函数drive_machine，这个函数内部是一个复杂的有限状态机，会处理所有与套接字相关的连接、关闭、读写等操作。<br>　　listen套接字当接收到客户请求的时候，如果连接OK，并且没有超过最大连接数目，就调用dispatch_conn_new接收请求。这个函数中，会轮询选择要添加的工作线程，然后创建一个等待item，并添加到对应线程的new_conn_queue队列上去，然后向这个线程的读取队列里面写入’c’一个字节表明有一个新的请求，然后对应线程管道读事件就会被触发，执行处理回调函数。<br>　　主线ain_base进入Libevent事件循环中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* enter the event loop */</span></div><div class="line"><span class="keyword">if</span> (event_base_loop(main_base, <span class="number">0</span>) != <span class="number">0</span>) &#123;</div><div class="line">	retval = EXIT_FAILURE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/learn-note-of-libevent-(2)-thread-pool-in-memcached.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-fastcgi-support-for-http-server-libmicrohttpd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/fastcgi-support-for-http-server-libmicrohttpd.html" class="article-date">
      <time datetime="2016-05-12T08:45:54.000Z" itemprop="datePublished">2016-05-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/fastcgi-support-for-http-server-libmicrohttpd.html">对libmicrohttpd添加FastCGI协议支持</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　在以前的<a href="/201604/oversee-of-http-based-on-libmicrohttpd.html">《基于libmicrohttpd的HTTP服务器初探》</a>中，libmicrohttpd是可以返回文件系统中的静态网页的，所以挂GitHub Pages的静态博客是没有问题的，但是对于PHP这类动态网页就无能为力了。今天逛V2ex就看见一个家伙把自己简短实现的PHP Web Server挂上来求Star。乍一看用C代码处理HTTP协议，不是很感冒，但是通过FastCGI支持PHP还是挺合寡人口味的。<br><img src="/post_images/images/201605/6c34d4fb192041d50c6d246d1a8e8d90.jpg" alt="FastCGI"><br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议/">协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作/">工作</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/构架/">构架</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/运维/">运维</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/fastcgi-support-for-http-server-libmicrohttpd.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-libevent-(1)-basic-usage" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/learn-note-of-libevent-(1)-basic-usage.html" class="article-date">
      <time datetime="2016-05-10T10:55:55.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/learn-note-of-libevent-(1)-basic-usage.html">Libevent学习笔记（一）：基本使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、前言">一、前言</h1><p>　　其实，现在高性能网络服务器基本都是异步I/O模式构建的，而Libevent就是对select/poll/epoll这类异步模式接口的封装，通过设置回调函数的方式，在监听文件描述符和套接字读写事件的同时，还兼任定时器和信号接收的管理工作。所以这货对高性能服务器后台开发、跨平台开发、网络开发都具有很大的参考学习价值。官方主页显示很多的项目都用到了Libevent库，而且还可作为主机内部进程间通信和数据交互。这货也考虑到pthread线程模型的同步问题，保证关键数据结构在多线程并行下的数据安全，但是如果能够封装一个线程池模型就更爽了！<br>　　更正：现代服务端的开发，线程池不一定是最合适的服务端模型，像Nginx的实现上，几个进程(当然也可以几个线程)在异步模式下就可以撑起很大的并发量了，协程也是近年来开发的热点，相对来说异步事件的支持下，线程的代价还是略显高了。<br>　　深入了解的第一步就是先学会用它。其实Libevent的主要维护者Nick的博客有一本很好的教程<a href="http://www.wangafu.net/~nickm/libevent-book/">libevent book</a>，看完它后再加上Libevent本身附赠的HTTP和DNS服务器的例子sample（Libevent本身封装了evhttp和evdns），基本就可以耍起来啦。看过后会发现，如果对网络开发本身比较熟悉，Libevent还是比较容易理解和上手的。除此之外，Libevent还有一个比较特色的东西，就是封装产生了Bufferevent和evbuffer结构类型，而两者的关系呢，算是Bufferevent是基于evbuffer封装了I/O事件、I/O调度等内容，而evbuffer则是Bufferevent底层的数据承载。<br>　　需要注意的是由于手册的作者就是维护者，所以手册的内容十分的新，有些手册内容在稳定发布版本2.0.22是没有的，代码切换到稳定分支可以使用git branch stable release-2.0.22-stable建立一个稳定分支。<br><img src="/post_images/images/201605/4ba4cf01515ad01fd5f9403f6460d578.png" alt="libevent"></p>
<h1 id="二、服务端使用步骤">二、服务端使用步骤</h1><p>　　这里通过手册描述的过程，对Libevent整个使用过程进行一个梳理。其实，实际使用很多步骤是不用考虑的，因为Libevent在设计上还算是比较智能——当你没有提供参数或者设置的时候，系统会自动给你一个最优的或者常用的配置，比如底层的异步模式。</p>
<h2 id="2-1_配置系统，产生event_base对象">2.1 配置系统，产生event_base对象</h2><p>　　event_base算是Libevent最基础、最重要的对象，因为修改配置、添加事件等，基本都需要将它作为参数传递进去。<br>　　event算是Libevent最常用的元素，对于event在其生命周期有initialized、pending、active这几种状态，当通过event_new创建了事件并关联到event_base上之后，其状态是initialized；然后通过event_add之后，这个事件便是pending的状态，开始侦听了；然后当条件满足之后，其变为active状态，对应的callback函数被调用。<br>　　这个对象通过event_base_new创建，在创建之前还可以设定某些参数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> event_config *cfg;</div><div class="line"><span class="keyword">struct</span> event_base *base;</div><div class="line"></div><div class="line">cfg = event_config_new();</div><div class="line">event_config_avoid_method(cfg, <span class="string">"select"</span>);   <span class="comment">//避免使用低效率select</span></div><div class="line">event_config_require_features(cfg, EV_FEATURE_ET);  <span class="comment">//使用边沿触发类型</span></div><div class="line"><span class="comment">//event_config_set_flag(cfg, EVENT_BASE_FLAG_PRECISE_TIMER);</span></div><div class="line"><span class="comment">//event_base_new(void); 为简单版本，会根据系统选择最快最合适的类型</span></div><div class="line">base = event_base_new_with_config(cfg);</div><div class="line">event_config_free(cfg);</div><div class="line"><span class="comment">//显示当前使用的异步类型</span></div><div class="line">st_d_print(<span class="string">"Current Using Method: %s"</span>, event_base_get_method(base)); <span class="comment">// epoll</span></div><div class="line"></div><div class="line"><span class="comment">//可选设置优先级数目，然后通过event_priority_set设置事件的优先级</span></div><div class="line"><span class="comment">//0为最高，n_priority-1为最低，此后创建的事件默认优先级为中间优先级</span></div><div class="line">event_base_priority_init(base, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/learn-note-of-libevent-(1)-basic-usage.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2017 taozj
            </div>
            <div class="footer-right">
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">
                    <img src="/post_images/icons/icp_min.png" alt="粤ICP备17002382号-1">粤ICP备17002382号-1
                </a>
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258402767'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1258402767%26online%3D2' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>, theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a>  enhanced by Nicol <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>
<script src="/js/search.js"></script> 


    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>


   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</script>

  </div>
</body>
</html>