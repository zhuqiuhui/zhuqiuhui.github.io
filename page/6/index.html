<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>桃子的博客铭</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="淡泊明志，宁静致远！">
<meta property="og:type" content="website">
<meta property="og:title" content="桃子的博客铭">
<meta property="og:url" content="https://taozj.org/page/6/index.html">
<meta property="og:site_name" content="桃子的博客铭">
<meta property="og:description" content="淡泊明志，宁静致远！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="桃子的博客铭">
<meta name="twitter:description" content="淡泊明志，宁静致远！">
  
    <link rel="alternative" href="/atom.xml" title="桃子的博客铭" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/iconfont.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">taozj</a></h1>
        </hgroup>

        
        <p class="header-subtitle">高性能、高可用服务端开发</p>
        
        <br>
        
        <p class="header-subtitle">淡泊明志，宁静致远！</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">文章归档</a></li>
                        
                            <li><a href="https://album.taozj.org">个人相册</a></li>
                        
                            <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                        
                            <li><a href="/about">请你读我</a></li>
                        
                            <li><a href="/search.html">搜索本站</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作/">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构架/">构架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">taozj</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">taozj</a></h1>
            </hgroup>
            
            <p class="header-subtitle">高性能、高可用服务端开发</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="https://album.taozj.org">个人相册</a></li>
                
                    <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                
                    <li><a href="/about">请你读我</a></li>
                
                    <li><a href="/search.html">搜索本站</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-feeling-of-cpp-11-and-two-ticks" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201608/feeling-of-cpp-11-and-two-ticks.html" class="article-date">
      <time datetime="2016-08-30T09:45:45.000Z" itemprop="datePublished">2016-08-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201608/feeling-of-cpp-11-and-two-ticks.html">C++11新标准阶段性学习心得及两个小轮子分享</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　突然发现，自己的博客好久都没更新了。<br>　　主要缘由是这段时间忙于学习C++11和Boost的开发，同时公司也有一个小项目正在设计开发之中，所以工作成果都转换成笔记和代码了。<br>　　说来自己学习C++11已经一月有余了，之所以称之为学习而非温习，是感觉C++11和C++98的差异实在是太大了，体现的不仅是小特性的改进，而感觉是一个质的飞跃。V2ex上人家调侃说十几年前自己学了一门语言叫做C++，现在那个语言还是叫C++，只是我已经不认识他了。当初也有个朋友说，如果C++11早一点出来，那么Google也不会推Go语言了，而现在的开发语言的格局也会大有不同，至少说不准如当下Java大行其道作为绝大多数公司服务端开发的主力语言了。无可厚非，服务端的高性能开发的极致非C/C++莫属，所以C++是一门低碳环保的语言，而C++11的右值引用、移动操作等无不在最求性能的极致。<br>　　下面就着这段时间的学习心得体会和耳濡目染，介绍一些关于C++11的新认识。同时，在工作和学习之余，自己也模仿着造了两个小轮子，已经托管到GitHub上面了——虽然简单，也很不专业，但是对C++11的新特性都覆盖了不少，算是在学习中动手、在实践中改进吧。</p>
<h1 id="一、C++11新语言">一、C++11新语言</h1><h2 id="1-1_C++11">1.1 C++11</h2><h3 id="1-1-1_RAII和标准库">1.1.1 RAII和标准库</h3><p>　　以前学C和C++，在C/C++中的堆内存的动态分配，以往都是教条式的强调malloc/free、new/delete、new[]/delete[]一定要匹配使用！千万不要忘记！而且不能free/delete多次！者虽然不是什么技术问题，但是人毕竟是人，难免不出错。而RAII的技巧，就是利用stack上的临时对象生命期的性质，当临时对象超过作用域的时候析构函数会被自动调用，于是利用程序自动管理的这一特点，可以将资源的释放操作封装在一个临时对象中自动销毁，改变以往的手动申请和释放的模式。在C++11中，几乎绝大多数类型，通过一些技巧或者包装，都可以保证其到达作用域结束的时候被正确的析构掉，而且是异常安全的。所以理论上，通过C++11标准的程序，理想状态下不需要new/delete方式来管理对象了，使用智能指针、智能锁等工具重新组织你的工程，从资源管理的泥淖中解脱出来。<br>　　其次，据说C++新标准中有2/3的篇幅是关于容器和算法库。当然有人一直争论这些容器和算法库不应当作为一个语言的标准这种形式存在，否则语言的标准将会不断的膨胀。但是作为实用主义来说，这些标准容器和标准库的存在可以大大增加开发进度，同时别人调试好的数据结构和算法也更容易开发出稳定的程序来。</p>
<h3 id="1-1-2_Boost库">1.1.2 Boost库</h3><p>　　前面说过，Boost库算是C++标准的试验田，诸位C++大牛都会把特性想法在这里开发，然后好的东西会被C++标准委员会吸纳进正式标准，比如C++11中智能指针就是从Boost中引入的。但是如陈硕老师所言，Boost库规模庞大，但也不能盲目尽信之，好的东西譬如如智能指针、noncopyable等可以直接用，免去自己制造垃圾轮子，而且可以借鉴取其实现思路和方法，以增长功力。但是也有些库用到的技术晦涩难懂，和实际使用有所脱节，而且可能效率很低。当然这些甄别取舍也是门技术，惭愧自己到达那份功力还路途遥远。<br>　　还有需要注意的是，很多的东西在Boost和C++11标准中都有一份，虽然大体功能相似，但是还是有些差异，比如：std::unique_ptr可以传递deleter函数，但是boost::scoped_ptr却不支持。看个人感觉吧，但是建议不要混用，因为即使std::shared_ptr和boost::shared_ptr等价，但是函数调用参数却不这么认为。</p>
<h3 id="1-1-3_编译速度非常慢">1.1.3 编译速度非常慢</h3><p>　　C++的运行速度不慢，但是由于现在的库中引入了大量的模板类，而模板的解析、实例化、编译等很很需要计算量。一个十来个文件的小项目在笔记本上要干一分多钟，实在忍受不了。网上搜罗的解决方式有：<br>　　(1). PCH预编译头部<br>　　照网上的说法是建立一个头文件xxx.hpp，包含在项目中常用稳定的头文件，然后编译这个头文件生成同名xxx.gch的预编译头结果，后续在项目中包含xxx.hpp就会直接使用xxx.gch预编译结果，从而减少编译时间。我照着做了，没效果，在stackoverflow上面问了好久<a href="http://stackoverflow.com/questions/39049853/about-g-not-working-with-pre-compiled-headers-pch">About g++ not working with pre-compiled headers pch</a>，也没人鸟我。<br>　　不知道是GCC的BUG还是我的姿势不对，后面试试Clang吧。我觉得这种预编译头还是挺有用的，如果有预编译结果会得到优化，如果没有也能正常编译，可惜这里暂时不能用。<br>　　(2). ccache缓冲<br>　　问了罗剑锋，他说ccache应该可以优化编译效率，不过我还没试。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201608/feeling-of-cpp-11-and-two-ticks.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-some-refined-and-modification-this-site" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201608/some-refined-and-modification-this-site.html" class="article-date">
      <time datetime="2016-08-14T03:01:00.000Z" itemprop="datePublished">2016-08-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201608/some-refined-and-modification-this-site.html">关于近来本站点的一些修改和设置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>　　经过这么半年多的运营，博客积累了50多篇博文了。虽然其内容不如<a href="http://coolshell.cn" target="_blank" rel="external">CoolShell</a>那么有深度，数量也不如<a href="http://www.williamlong.info" target="_blank" rel="external">月光博客</a>那么高产，但是自我感觉收获还是比较多的：<br>　　(1)首先，感觉自己记性是比较差的，同时也没有写日记的习惯，所以这篇博客算是自己在技术路线上的日记了，当然偶尔有心情情趣了还会写点杂感体验啥的，若干年后自己回首看看，感受下自己怎么滴从幼稚无知走向成熟(希望是这么个路线)，想必也会别有一番风味；<br>　　(2)其次，还是自己记性差，所以很多的学习折腾经验还是记下来比较靠谱，平常也可以翻开来既可以做到温故而知新，还可以避免以前的坑点和弯路——以史为鉴，可以知兴替嘛；<br>　　(3)再则，程序员的交际能力普遍比较差，所以自己写点东西，算是对自己表达能力和组织能力的一种锻炼吧，还有就是比如看书看文档，看起来你不会发觉，但当笔记记录下来时候，很多细节的问题就会被发现，可以帮助你加深对事物的认识。<br>　　(4)提高自己的毅力。万事贵不在难，在于坚持。大家都说个人博客是程序员的标配，但是很多人都是开头兴致勃勃的买服务器打环境，写了几篇之后博客就长草了，所以我觉得这也是最能锻炼我的地方。还有就是，把自己所学所感记下来，会让自己觉得是真正积累(即使在脑袋中可能会忘记)，激发后学学习的动力和勇气。</p>
<p>　　个人读书的时候就写过不少博客，这次重启博客项目之后，觉得之前的东西都比较幼稚，所以就没有再导入近来，包括这个博客的折腾经历啥的，在博文<a href="/201603/blog-site-under-https.html">我的博客用上HTTPS啦</a>也有介绍。</p>
<p>　　然后，这篇博文其实我想说的是：<br>　　国外搭建博客的平台很多，静态的有GitHub、Bitbucket以及国内的codeing.net，动态的有OpenShift等，而且是都是免费的。OpenShift依托Red Hat强大的研发实例和Amazon强大的基础数据中心，算是国外最理想、最稳定可靠的动态建站环境，但是国内的访问速度不忍直视，用360测速几乎都是红的，访问速度严重影响了网站的用户体验，而且最大的隐患就是突然有一天根据某些法律让你的网站从地球上“消失”。GitHub以及稍微小众的Bitbucket短期内应该不会被封掉(感觉GitHub在某些事情上向某些政府妥协了)，但是访问速度也是慢的很，然后常常挂代理访问GitHub反而比直接访问GitHub还要快，想必其中的原因大家都心知肚明吧。还有就是coding.net，算是GitHub本土化产品，也可以搭建博客，出于规避法律的因素把服务器设置到了香港，不过速度还是不错的，但是一样的不支持HTTPS，算是没有办法中比较好的备选吧。<br>　　当然，如果你的域名是备案的，是可以用国内免费或者付费的CDN，而且即使付费的话博客访问的流量估计一个月也就几块钱，访问速度应该会有很大的改善。如果域名没有备案，就不用找了，国内没有任何一家公司敢帮你挂站或者缓存的。<br>　　同时。我本人现在博客、相册、Wiki的选型都倾向于不用数据库的。虽然LNMP是经典的架站模型，性能不错，但是挂着个数据库备份、维护都很不方便。所以如果免数据库都是文件的话，可以在GitHub托管开源版或者在Bitbucket托管闭源版本，然后本地备份再加上Dropbox同步备份，你的数据就是相当安全的，即使有一天你的网站因为某些告人或者不可告人的原因被“消失”掉了，你还可以零成本、零丢失地重新部署，很诱人吧！<br>　　上面提到WiKi，是我觉得之前很多技术类的读书笔记放在博客中，查阅不是很方便，于是想到放到WiKi中查找和更新都会比较直接，此外还有的原因是WiKi的字体比较小，界面比较简洁所以界面甚是喜欢。一搜大家都是推荐MediaWiki，但是又是一个PHP+MySQL的，然后又发现<a href="https://www.dokuwiki.org/dokuwiki#" target="_blank" rel="external">dokuwiki</a>还不错，跟我的相册一样也是PHP加文件系统的形式，备份很方便。虽然还需要学一下wiki syntax，但好在比较简单，推荐大家使用。同时也希望大家多多收藏和关注<a href="https://wiki.taozj.org/doku.php" target="_blank" rel="external">Nicol’s Wiki Page</a>。<br>　　我现在的网站是挂在阿里云的，是我的一个朋友的服务器，我帮他做运维，他借给我托管个人网站。由于我的域名没有备案，所以80端口不让访问，广大童鞋访问的时候要记得添加https哦，如果懒的输的话，这里是<a href="https://www.taozj.org" target="_blank" rel="external">我的主页</a>，点击就可以了，欢迎收藏。</p>
<p>　　OK，八月的第一篇水文就此完工！</p>
<p>　　PS: 2017-01-04已经将域名taozj.org提交到<a href="https://hstspreload.org" target="_blank" rel="external">Google HSTS preload list</a>中，以后该域名和所有子域名都会被硬编码到Google Chrome浏览器中以强制https方式访问！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/运维/">运维</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博客/">博客</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-boost-(1)-smart-ptr-memory-pool" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201607/learn-note-of-boost-(1)-smart-ptr-memory-pool.html" class="article-date">
      <time datetime="2016-07-28T10:04:45.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201607/learn-note-of-boost-(1)-smart-ptr-memory-pool.html">Boost库学习笔记(一)：智能指针和内存池</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、前言">一、前言</h1><p>　　这篇是这个系列的开篇第一作，所以还是想简单说点题外话。<br>　　以前上学的时候学过C++，所谓经典的《 C++ Premier Plus》、《 C++ Premier》、《C++ Templates》三本书也都看过，那些诡异的语法、隐晦的潜规则也曾啃过，但是到现在基本都忘了。我想，究其原因：一方面是C++实在是过于的复杂，复杂到据说，当时一个公司的团队，打算用C++新开发一个项目，到后来整个团队跑题去研究C++语言本身了；另一方面如同自己之前所说的，缺少C++的项目经验，教科书基本就是一个点一个例子零散的教你，没有像样的大型项目训练很难深刻理解和掌握之。刚好前段时间对异步研究的比较多，然后沿着boost::asio，了解到boost C++开发库，比较出名而且在正式项目中用的比较多，觉得以此为切入点还是不错的。<br>　　还有，至于为啥要干C++。虽然现在Python、go这些语言火的如日中天，但觉得后台底层开发基本还是C，C++，Java三分天下的局面：Java在中间件中用的比较多，而且Apache旗下一大堆的分布式组件和算法库也都是Java实现的，可谓前途广阔；C作为现代编程语言的鼻祖，Linux内核项目证明了C完全是可以开发大型项目的，但是之前自己写的几个小程序，感觉C的确也是年世已高了，语法简洁但是缺乏上层抽象，很多东西需要自己造轮子，或者不断的选库集成；C++做后台是很多的，比如自己以前实习的移动通信核心网，就是C++写的，C++的模板特性，再加上C++标准不断的吸纳新的数据结构、算法等内容，让C++不断地被丰富完善，以适应现代大型项目快速开发的需求。从个人感觉上来说，Java开发最省心，这也是GC(垃圾回收)类语言的最大优势，但是不是说Java性能慢么？C语言简洁优雅而又直白，给定一个代码，可以很明确的分析其预测结果，但是正因为简洁优雅，很多高级编程的抽象需要底层去实现，开发效率算是最低吧。而C++估计是最复杂的语言了，隐含的规则很多，常常代码需要推理一下才知道可能的结果，而且如果对C++了解不深入的话，感觉更容易照成内存泄漏，其远没有C的malloc/free这么简单！<br>　　关于boost的历史缘由，以及跟C++标准的关系，这里就不再整理了，网上一搜全部都是。可以说boost库是C++新特性的实验基地吧，在boost中比较好的库，很有可能会成为后续C++的标准，所以boost也会被冠以“C++准标准”的美誉。<br><img src="/post_images/images/201607/60d27a9097df68f72fdad62133efbfe4.png" alt="Boost"><br>　　刚买了一本新的《C++ Premier》第五版，书中着重强调是一本依据C++11标准更新改写的，初步瞭阅一下，感觉不错，希望C++11和boost能给我带来新的成长。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201607/learn-note-of-boost-(1)-smart-ptr-memory-pool.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-simple-digit-recong-base-on-tesseract" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201607/simple-digit-recong-base-on-tesseract.html" class="article-date">
      <time datetime="2016-07-25T09:19:35.000Z" itemprop="datePublished">2016-07-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201607/simple-digit-recong-base-on-tesseract.html">基于Tesseract的数字识别程序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、前言">一、前言</h1><p>　　这算是一个临时空降的任务，项目背景就懒描述了，先期目的就是从电表的照片中，自动识别出电表的读数出来。如果透过现象看本质，这显然就是一个OCR的任务，而OCR无非就是先期的图片预处理，以及后期的实际OCR识别任务两个阶段。<br>　　说到OCR，就不得不提到大名鼎鼎的Google Tesseract了(虽然这个项目最初是由惠普开发，后面交由Google维护)，几乎绝大多数的开源OCR项目，都是用它作为识别引擎的。Tesseract是开源的，而且本身就包含了很多种语言模型的训练结果，如果不是有特别的需求（比如手写的不规则字体），几乎就是开箱就用的效果。我们这里电表的读数都是8段LCD的字体，作为一类最常见的标准字体，我想自己训练也不见得模型有所提升，把精力花在第一步图像的处理方面，会得到更加显著的效果。<br>　　当然，这暂时也不是我的兴趣所在，也没有什么深入研究和体会，只是借助上面的项目搭建了个可以工作的模型，所以干货是没有的干活~</p>
<h1 id="二、EasyPR开源车牌">二、EasyPR开源车牌</h1><p>　　对于OCR，经过Google之后，我不得不推荐一个项目<a href="https://github.com/liuruoze/EasyPR">EasyPR</a>，其原因不仅仅在于它是开源的，而是作者十分的用心，将整个<a href="http://www.cnblogs.com/subconscious/p/3979988.html">项目流程</a>的原理、思路和实现细节介绍的十分详细，可以说是手把手教你做车牌识别的，而这无论对于准备入坑的工程师，还是在校学生灌水发论文或者毕业设计，都具有很好的指导入门作用。现在这个项目已经更新到v1.5版本了，引入了MSER等算法用于目标定位等操作，如果想跟着上面作者教程的思路，建议切换到v1.3分支查看。<br>　　参阅作者的教程，总结下来实现流程是这样的：</p>
<h2 id="2-1_图像预处理过程">2.1 图像预处理过程</h2><p>　　这个过程可以总结为抠图过程——就是在一副图像中，提取出车牌号的那一块出来，这纯粹就是个图像处理的过程；对于抠出来的图片，还通过SVM判断器分析是否是车牌图像，可以在减少后续OCR操作的同时，也增加了识别的准确率。<br>(1) 高斯模糊化，可以平滑滤除小的变化细节，保留车牌边沿这些大的细节；<br>(2) 图片灰度化；<br>(3) 对图像X轴方向做Sobel计算（等于是个求导操作），求取图像变化特征，至于为何只求水平方向而不求垂直方向，作者用实验的方法表明，水平方向Sobel足以获得足够的特征用于后续求取轮廓，而垂直Sobel计算往往对最终结果有害无益；<br>(4) OTSU法自适应对图像进行二值化（一看就是日本名字，经典啊）；<br>(5) 进行形态学的膨胀腐蚀操作，滤除小的噪声点，同时获取相应的连通区域；<br>(6) 求取Contours轮廓，同时对轮廓进行粗筛选（比如角度、大小、长宽比等）；<br>(7) SVM判别器分析图像块是否为含车牌图像；</p>
<h2 id="2-2_OCR过程">2.2 OCR过程</h2><p>　　OCR作者是使用的MLP神经网络实现的，而神经网络/深度学习对于手写数字的识别率达到98%以上，这个领域可谓神经网络的应用之典范，所以作者选此也不足为奇。<br>　　此外，OpenCV本身集成了MLP库，所以这边集成使用起来也更为的方便。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/杂七杂八/">杂七杂八</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201607/simple-digit-recong-base-on-tesseract.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-construct-running-close-of-tcp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201607/construct-running-close-of-tcp.html" class="article-date">
      <time datetime="2016-07-12T11:57:57.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201607/construct-running-close-of-tcp.html">TCP链接的建立和关闭过程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　TCP/IP是现代互联网的基础，而TCP/IP三次握手似乎也是经久不衰的问题。这次就着抓包，把TCP/IP建立连接和拆除连接抓了个包，仔细看看到底是怎么回事儿。</p>
<p>　　Windows下面数据流量太多了，于是滚到Linux下面，命令行curl url后用Wireshark抓包，就得到了下面一张图（默认Wireshark显示的序列号是相对序列号）。<br><img src="/post_images/images/201607/a098ae3ff7d1b002631fc2c8a77a8214.png" alt="TCP-IP"><br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201607/construct-running-close-of-tcp.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-design-and-impl-of-minicached-base-on-memcached" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201607/design-and-impl-of-minicached-base-on-memcached.html" class="article-date">
      <time datetime="2016-07-07T10:57:57.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201607/design-and-impl-of-minicached-base-on-memcached.html">基于memcached原理实现的单机轻量级通用缓存库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、前言">一、前言</h1><p>　　之前拜读过淘宝子柳的《淘宝技术这十年》之大作，深知缓存技术在系统优化中起着一个举足轻重的作用。无论是文件系统静态文件，数据库的访问，乃至网络数据的请求，只要是与内存访问速度相差较大的，都能显著减少IO操作，提高系统的响应速度和吞吐量。<br>　　在企业环境中，memcached和Redis算是最成熟的缓存解决方案，而国内外大型企业将其修改扩展成分布式结构的案例也是相当之很多，memcached出现的事件比较早，相对简单但是方案成熟，而Redis算是在memcached之后开发的后起之秀，改进优化了很多方面。</p>
<h1 id="二、memcached工作原理">二、memcached工作原理</h1><p>　　目前Redis还没有涉及了解过，memcached之前涉及过一点。memcached通常是作为一个单独服务进程启动的，监听来自TCP/UDP/Socket的请求，一般采用ascii协议进行通信。无可厚非，采用网络的方式进行进程间通信，其扩充简单灵活，但是总感觉相对于一般的单机小型程序来说，还是有点杀鸡用牛刀的感觉。如果能有一个微小型的通用缓存库，就可以联合编译链接到应用程序内部，进程间的通信效率提高了，部分数据都可以做到零拷贝了，数据通信协议、同步问题也都很好解决，岂不乐哉？<br><img src="/post_images/images/201607/e02d73dcff1fe8f2afdbeae75a8eacbf.jpg" alt="minicached"><br>　　当然，自己在一个小项目中，用的是libmicrohttpd接收POST请求数据，在不用默认的posthandler的时候，就需要自己手动申请内存，然后供接收数据使用。于是就通过建立一个postbuff的对象池，每当请求来的时候，就阻塞申请对象，用完之后在request_complete回调函数中标记为空闲，供下次使用，这样应该可以大大降低内存的碎片化。不过这个不通用，也没有缓存对象的生命周期、淘汰等特性，这也是本项目的实现目的。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201607/design-and-impl-of-minicached-base-on-memcached.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-libevent-(3)-internel-impl-and-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/learn-note-of-libevent-(3)-internel-impl-and-framework.html" class="article-date">
      <time datetime="2016-06-30T04:33:59.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/learn-note-of-libevent-(3)-internel-impl-and-framework.html">Libevent学习笔记（三）：内部实现原理初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　Libevent确实方便了开发人员，对于定时器、信号处理、关心的文件或者套接字，只需要挂载到event_base上面，设置好对应的回调函数和参数就可以了，当对应的事件发生时，Libevent会自动调度相应的回调函数进行处理。<br>　　本文就按照之前在<a href="https://github.com/taozhijiang/sshinner">sshinner</a>中使用Libevent的过程，以这些接口函数作为突破点，沿着代码走了一朝，尝试探究一下Libevent的内部工作流程是怎样的。由于本人能力有限，有些东西可能不够详尽或者准确，还望不吝指出。<br><img src="/post_images/images/201605/4ba4cf01515ad01fd5f9403f6460d578.png" alt="libevent"></p>
<h1 id="一、创建event_base">一、创建event_base</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> event_base * main_base = event_base_new(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>　　主要是根据参数，创建event_base结构体，然后初始化一些数据，如果对默认的参数不满意需要个性化配置的话，可以先创建event_config，然后调用event_base_new_with_config来创建。其中在eventops这个变量中，按照优先级顺序排序罗列了常见的IO复用模型，比如kqueue、epoll、poll、select等，由于Libevent是跨平台的，这些IO复用在有些平台可能是不可用的，同时你还可以在event_config中选择过滤某些不想要的模型。<br>　　当选定了某个IO复用模型之后，其操作结构eventop就被添加到base-&gt;evsel中，然后调用其特定的init初始化函数。这些操作跟文件系统file_operations结构极为的类似。<br>　　那我们接着跟下去，看看大名鼎鼎的epoll类提供了哪些操作吧：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> eventop epollops = &#123;</div><div class="line">    <span class="string">"epoll"</span>,</div><div class="line">    epoll_init,</div><div class="line">    epoll_nochangelist_add,</div><div class="line">    epoll_nochangelist_del,</div><div class="line">    epoll_dispatch,</div><div class="line">    epoll_dealloc,</div><div class="line">    <span class="number">1</span>, <span class="comment">/* need reinit */</span></div><div class="line">    EV_FEATURE_ET|EV_FEATURE_O1|EV_FEATURE_EARLY_CLOSE,</div><div class="line">    <span class="number">0</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在初始化函数epoll_init当中，基本就类似epoll使用时候标准化的准备工作：首先调用epoll_create创建epfd，然后预先创建INITIAL_NEVENT(32)个空间用于存放epoll_event，如果使用了timerfd，则再调用timerfd_create创建对应的timerfd。最后这些fd以及epoll_event都存放在struct epollop当中，然后作为epoll_init函数的返回保存在base-&gt;evbase上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> epollop &#123;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events;    <span class="comment">//数组</span></div><div class="line">    <span class="keyword">int</span> nevents;</div><div class="line">    <span class="keyword">int</span> epfd;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USING_TIMERFD</span></div><div class="line">    <span class="keyword">int</span> timerfd;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在创建event_base的最后，还调用了event_base_priority_init进行了一个初始化操作，如果有多个优先级，就有对应的多个等待队列挂靠在base-&gt;activequeues上面，而base-&gt;nactivequeues记录了优先级的数目。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/learn-note-of-libevent-(3)-internel-impl-and-framework.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-port-expose-based-on-libevent-(4)-dns-proxy-support" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/port-expose-based-on-libevent-(4)-dns-proxy-support.html" class="article-date">
      <time datetime="2016-06-28T09:27:42.000Z" itemprop="datePublished">2016-06-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/port-expose-based-on-libevent-(4)-dns-proxy-support.html">基于Libevent转发的内网端口暴露（四）：添加DNS代理的功能</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　之前所说，这应当是这个项目最后一个功能了，到此我觉得个人PC端上网的解决方案都弄完了。<br><img src="/post_images/images/201606/3835a8737168091573fc0932cae0dd96.jpg" alt="sshinner"></p>
<p>　　其实，国内上网环境可以用极度恶劣来形容：DNS投毒、域名劫持、网页串改等，这种环境如果在不走代理的情况下想安心点上网，那么干净的DNS和HTTPS算是可以在基本面上得到一些保证。其实国家一直号召宽带中国、光纤入户，但实际让大家的感受就是上网变得越来越慢，越来越难。<br>　　之前个人上网的DNS使用的是<a href="https://github.com/jedisct1/dnscrypt-proxy">dnscrypt-proxy</a>的解决方法，在Linux和Windows平台下都可用，其原理就是在本地建立DNS代理服务器侦听#53号端口，然后把本机的DNS服务器设置成127.0.0.1，代理服务一旦接受到DNS解析请求，就会向远程主机请求解析结果，然后返回给本地。毫无疑问，这个过程中的数据是加密传输的(用的叫什么libsodium库，不过寡人还没怎么听说过)，以此保证你得到的DNS解析结果是干净的。当然个人感觉这也会有缺点，比如大流量网站都会有CDN做优化，根据你访问地址帮你解析到更快的服务器IP，而DNS代理的方式估计享受不到这种优化吧，其利弊全靠个人取舍。<br>　　然后我又有想法了:其实大部分人用8.8.8.8，8.8.4.4这种国外知名的DNS服务器就可以了，但是你在国内直接这样设置到电脑上，由于UDP协议的特性，解析速度和返回的结果都得不到保证。为此，那么我侦听本地#53端口，把本地所有DNS请求的UDP数据包内容进行封装加密发送到国外服务器，远端服务器解析后再将结果加密返回回来，本地代理程序解密后再转成UDP包返回给客户端不就行了？？？<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/port-expose-based-on-libevent-(4)-dns-proxy-support.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-read-(the-art-of-sober-thinking)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/read-(the-art-of-sober-thinking).html" class="article-date">
      <time datetime="2016-06-24T01:13:35.000Z" itemprop="datePublished">2016-06-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/read-(the-art-of-sober-thinking).html">读《清醒思考的艺术》感</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　这本书最早是在简书上一篇题为《建立逻辑思维，我推荐的三本书》上发现的。其实在文章评论留下邮箱后，作者也把电子版的书发给我了。看着豆瓣的评分不错，书也不贵，于是还是在狗东买了本纸质版的。<br><img src="/post_images/images/201606/ea643e73606a4543bdd3f2c8ec702e89.jpg" alt="清醒思考的艺术"><br>　　看完之后，感触很多，算是直撮痛点吧，第一次让我感触到人性有这么多缺陷，思维有这么多误区。如果说论语是一本道德楷模，像一个温文尔雅的儒仕教你如何去做人处事的话，那么这本书更像一个手持教鞭的教官，毫不保留的指出你的思维缺陷，引导你如何正确看待身边的事事物物。同时，我觉得这本书应该时常带在身边，因为人不仅仅是身体上，思维上也有惰性，许多的视野、逻辑和观点已经习以为常了，如果不曾真正的痛过，是很难留下记忆去修正他的，更何况有些已经随着人类的繁衍持续了成千上万年，深入骨髓了。此外，本书的副标题也很有意思：“你最好让别人去犯的52种思维错误”，其实完全没必要啦，因为大多数人或多或少都有书中罗列的这52条毛病！</p>
<p>　　其实在漫漫进化的长河中，生物体行为无论是先天条件反射还是后天习得，都是让生物体本着趋利避害的方向发展，因为那些大多数不合理的事物，都被大自然所抛弃了，有些由低级神经中枢负责，有些后天由高级神经中枢学习和加强。设想在野外听见狼叫或者熊叫等声音，大多数人第一反应就是躲避或者逃跑，而不是考量对方是什么、会不会对自己造成威胁和伤害等因素，或许那些在这种情况下冷静爱思考的祖先都被吃掉了吧，同时虽然我们没有经历到这些，但是这类思想还是被不断灌输和传承下来。而对于一朝被蛇咬，十年怕井绳，就更不必说了。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/读书/">读书</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/read-(the-art-of-sober-thinking).html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-personalized-reading-based-on-content-recommendation-(2)-svd-impl" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201606/personalized-reading-based-on-content-recommendation-(2)-svd-impl.html" class="article-date">
      <time datetime="2016-06-24T01:13:18.000Z" itemprop="datePublished">2016-06-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201606/personalized-reading-based-on-content-recommendation-(2)-svd-impl.html">基于内容推荐的个性化阅读实现（二）：基于SVD的推荐算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、前言">一、前言</h1><p>　　SVD前面已经说了好多次了，先不论其信息检索被宣称的各种长处如何如何，在此最主要的作用是将稀疏的term-doc矩阵进行降维，当一篇篇文章变成简短的向量化表示后，就可以用各种科学计算和机器学习算法进行分析处理了。<br>　　之前的推荐算法的设计是用的最大熵估计，他和诸如朴素贝叶斯、逻辑回归等，本质就是根据文章词汇信息把文章作为一个二类归类问题来解决的。根据自己以前的经验，这种方法是最简单，效果也还是比较理想的，而且相比现在设计的越来越复杂的算法，也有坚实的数理做依据的。<br>　　这次，尝试一个新的推荐方式，我的思路是这样的：如果你SVD分解降维后取n_topics=2，那么这些文章最后就都映射成了二维向量，可以把这些二维向量看作平面中的坐标，那么每篇文章其实就是这个平面上的点了。一般来说，文章越相似，那么他们的向量就越相近，然后映射到坐标空间中两者的欧式距离也就越短。反应到我们的推荐阅读中，如果一个人可能有几个兴趣点，那么他喜欢的文章在空间位置就应该聚成以这几个簇的形式展现出来。当然n_topics=2肯定不能用在实践中应用的，否则会丢失大量的特征信息，但是很容易将这个想法推广到多维的超平面上，基本原理都是一样的。<br>　　这个方法在实现中考虑到的缺陷有：浮点向量没法保存到数据库，只能驻留内存和dump到文件系统了；计算速度肯定比贝叶斯要慢很多，但是绝大多数推荐系统不都是定时进行数据线下计算线上加载的么；目前只考虑点赞的，不考虑踩的负样本的影响了，或许这也不是什么优劣势，负样本本来就可以在所有样本中采样来进行平衡。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201606/personalized-reading-based-on-content-recommendation-(2)-svd-impl.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2017 taozj
            </div>
            <div class="footer-right">
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">
                    <img src="/post_images/icons/icp_min.png" alt="粤ICP备17002382号-1">粤ICP备17002382号-1
                </a>
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258402767'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1258402767%26online%3D2' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>, theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a>  enhanced by Nicol <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>
<script src="/js/search.js"></script> 


    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>


   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</script>

  </div>
</body>
</html>