<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>桃子的博客铭</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="淡泊明志，宁静致远！">
<meta property="og:type" content="website">
<meta property="og:title" content="桃子的博客铭">
<meta property="og:url" content="https://taozj.org/page/8/index.html">
<meta property="og:site_name" content="桃子的博客铭">
<meta property="og:description" content="淡泊明志，宁静致远！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="桃子的博客铭">
<meta name="twitter:description" content="淡泊明志，宁静致远！">
  
    <link rel="alternative" href="/atom.xml" title="桃子的博客铭" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/iconfont.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">taozj</a></h1>
        </hgroup>

        
        <p class="header-subtitle">高性能、高可用服务端开发</p>
        
        <br>
        
        <p class="header-subtitle">淡泊明志，宁静致远！</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">文章归档</a></li>
                        
                            <li><a href="https://album.taozj.org">个人相册</a></li>
                        
                            <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                        
                            <li><a href="/about">请你读我</a></li>
                        
                            <li><a href="/search.html">搜索本站</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作/">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构架/">构架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">taozj</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">taozj</a></h1>
            </hgroup>
            
            <p class="header-subtitle">高性能、高可用服务端开发</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="https://album.taozj.org">个人相册</a></li>
                
                    <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                
                    <li><a href="/about">请你读我</a></li>
                
                    <li><a href="/search.html">搜索本站</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-usage-of-apache-lucy-fulltext-index" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201605/usage-of-apache-lucy-fulltext-index.html" class="article-date">
      <time datetime="2016-05-05T07:12:58.000Z" itemprop="datePublished">2016-05-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201605/usage-of-apache-lucy-fulltext-index.html">Apache Lucy的全文检索引擎的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、前言">一、前言</h1><p>　　给定个需求：如果当客户提的问题在问题库中没有精确检索到，怎么推荐出最相近的问题呢？<br>　　其实，本来想用之前的那个LSI来实现的，就是当SVD分解后得到特征矩阵和特征值，那么任何一个新的问题输入，就可以先计算得到降维的特征表示，然后根据向量相似距离就可以找出来了。用gensim的计算库工程是可以实现的，因为具有增量计算方法，可以不断新加新文本，淘汰文本就直接把相关问题的降维向量剔除就可以了。不过其主要遇到的问题还是SVD的计算量很复杂，而且当文本短而term极为稀疏的时候，如果要让检索有效，topic_num值必须设置很大才行。<br>　　然后曲折另外一个解决方案：使用现有的全文检索引擎，将待选答案建立索引，有新查询语句，将其分词后在索引中查找即可，这等于把搜索全部外包出去了。不过这样也有缺点：没有了语义检的特性，不过语料有限情况下这种特性并不明显，明文检索已经可以；没有降纬减噪的功能，可以通过去除停留词达到部分减噪效果。<br>　　当前开源的全文检索引擎很多，比如Lucene、Solr、Sphinx、Xapian等等。考虑到语言、项目集成等因素，最终选择了Apache Lucy，这个家伙算是KinoSearch的继任者，算是对Lucene的C/Perl语言的简洁移植版本，所以C语言可以很方便的在现有的项目中调用。</p>
<p><img src="/post_images/images/201605/b2b52063d6234b4d1b118a107d76b6e8.png" alt="Apache Lucy"></p>
<h1 id="二、使用方法和注意事项">二、使用方法和注意事项</h1><p>　　Lucy的使用方法、接口感觉跟之前我使用的Whoosh(一个全Python实现的全文检索引擎)十分的相似，由于接触到的还不是很多，不知道是不是大多数的搜索引擎思路都是一致的。</p>
<h2 id="2-1_使用步骤">2.1 使用步骤</h2><p>　　(1) 创建检索信息的表（Schema）结构（主要是各个索引列的名字、类型等信息）；<br>　　(2) 指明文件系统存储路径，然后调用Indexer_new创建索引（Indexer）；<br>　　(3) 针对每条记录/文档，创建成一个Doc对象，然后通过Indexer_Add_Doc将文档添加到索引中<br>　　(4) Indexer_Commit提交计算生成索引数据；<br>　　(5) 如果需要检索数据，使用IxSearcher_new方法创建IndexSearcher对象，然后使用IxSearcher_Hits检索遍历结果，而分别调用HitDoc_Get_Doc_ID和HitDoc_Get_Score可以得到文档ID和Rank Score；<br>　　(6) 如果需要修改数据（比如增加或者删除Doc），就需要用Indexer_new创建索引，然后使用Indexer_Add_Doc、Indexer_Delete_By_Doc_ID等方法来实现。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/软件/">软件</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201605/usage-of-apache-lucy-fulltext-index.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-fulltext-search-based-on-lsi-lda" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/fulltext-search-based-on-lsi-lda.html" class="article-date">
      <time datetime="2016-04-29T11:06:47.000Z" itemprop="datePublished">2016-04-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/fulltext-search-based-on-lsi-lda.html">基于LSI/LDA的文本检索的原理和操作步骤</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　自从上次写了那个<a href="/201604/how-to-calc-svd.html">SVD的计算步骤</a>之后，一直都想补充这一篇——用SVD进行文本检索，刚好这次需求驱动，着手试了一把，实验结果感觉还行！<br>　　SVD算是线性代数里面的东西，PCA、LSI、LDA这些算是不同应用目的的不同叫法吧，其中LSI全名叫Latent Semantic Indexing，看他的名字就是立志要用在文本信息检索里面，但是SVD的应用可不仅仅如此，比如图像处理、推荐系统、语音处理等等。<br>　　关于LSI的教材，本来Edel Garcia有一系列比较好的教程的，但是不知道为什么后来全部删掉了，附录的两个是可以下载的，内容说的也很清楚明白，推荐阅读。SVD由于原理简单，实现好的库也有很多。本文采用了gensim库已经封装好了，使用教程中有详细的操作步骤，个人将测试代码推送到<a href="https://github.com/taozhijiang/chinese_nlp">chinese_nlp</a>库。目前小范围的测试效果还可以，不知道语料多了之后效果怎样，同时需要知道SVD是比较耗费计算量的。</p>
<h1 id="一、计算步骤">一、计算步骤</h1><p>　　参考文档中介绍的具体计算步骤，这里描述下来。<br>　　(1) 文本预处理：中文分词，然后去除停用词、删除低频词词，进行word-&gt;id转换；<br>　　(2) 可选的优化，比如用TF-IDF为词汇加上局部权重；<br>　　(3) 将训练文本用dictionary转换成id表现的形式，这就得到了Term-Document矩阵$A$；<br>　　(4) $A=USV^t$，进行SVD分解，得到$U、S、V$矩阵；<br>　　(5) 降维，将奇异值S减少为k个(topic-mode参数)，当然k是个经验数字，比如200-500，然后$U$选前k列，$V$ 选前k列；$S$选左上角k行k列对角方阵，其实$V’$的低n行就是A第n列（第n个文本）的向量表示，且满足$V=A^TUS^{-1}$，或者任意一个文本$d=d^TUS^{-1}$；<br>　　(6) 对于一个新的查询文本q，其查询向量为$q=q^TUS^{-1}$，那么任意两个文本的相似度就可以计算为<br>$$sim(q,d)=sim(q^TUS^{-1}, d^TUS^{-1})$$<br>　　两个向量相似度的计算常常使用consine余弦相似度。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/fulltext-search-based-on-lsi-lda.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-linux-env-program-(2)-difference-select-poll-epoll" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/linux-env-program-(2)-difference-select-poll-epoll.html" class="article-date">
      <time datetime="2016-04-28T11:02:14.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/linux-env-program-(2)-difference-select-poll-epoll.html">Linux环境开发（二）：IO复用之select/poll/epoll之原理和差异分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　select/poll/epoll算是Linux中最常用的IO复用形式了，select是POSIX的标准，所以在Windows平台也是支持的。通常来说，select相对于poll和epoll的限制比较的多，但是在连接数小流量大的时候，select的性能表现也不见得比poll/epoll要差，而epoll对于侦听大量描述符，同时只有少量描述符活跃的时候更为的有效。<br>　　其实这几个IO复用的内部实现，select和poll比较接近，但epoll跟前几两者已经完全不同了，在此做一个总结吧。</p>
<p>　　这些函数都是系统调用，其中select/pselect/poll/ppoll定义在fs/select.c当中，而epoll被单独定义在了fs/eventpoll.c文件当中。</p>
<h1 id="一、select">一、select</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</div><div class="line">                  fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</div></pre></td></tr></table></figure>
<p>　　select主要是通过三个fd_set记录要监测的read/write/except事件的文件描述符，fd_set的大小被__FD_SETSIZE这个宏所限制，如果要增加这个值势必要重新编译系统内核，这也是select最大的诟病：监听的事件个数是有限的（1024）。外边通过FD_SET、FD_CLR等操作宏，实际内部是将这1024个文件描述符映射成1024bit=128byte=32long(32位系统)中的比特位的。<br>　　在进入系统调用后，接着：<br>　　(1) 调用core_sys_select，对于每个描述符read/write/except以及输入和输出，内核需要为这些描述符申请6倍的映射空间，然后将select输入的参数拷贝进内核空间，然后调用do_select；<br>　　(2) do_select中，按照bit扫描看是否需要r/w/ex的检查，如果需要，就调用文件系统file_operations-&gt;poll函数，检测POLLIN_SET/POLLOUT_SET/POLLEX_SET，并标志保存位图的对应位置;<br>　　(3) do_select调用返回到core_sys_select，将结果拷贝到用户空间（复用传参的地址），调用结束返回；</p>
<p>　　对于socket或者文件系统fd的poll调用，都会调用注册文件系统提供的poll函数，比如对于网络socket的poll，底层的poll函数是定义在net/ipv4/tcp.c中的tcp_poll()，调用过程如下：<br>　　a. fs/select.c: 在do_select开始的时候，会调用poll_initwait()函数，这个函数会将poll_wqueues.poll_table的_qproc设置为__pullwait函数；<br>　　b. fs/select.c：在下面遍历检测的时候，会调用文件系统/网络系统的poll函数(*f_op-&gt;poll)(f.file, wait)，这里调用参数f.file是每个文件描述符，wait是上面的poll_table；<br>　　c. 映射到socket上面，就是调用的net/sock.c中的sock_poll；<br>　　d. 如果是TCP，那么就映射到底层的net/tcp.c中的tcp_poll；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(<span class="keyword">struct</span> file *file,</div><div class="line">                  <span class="keyword">struct</span> poll_table_struct *wait)</span></span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> socket *sock,</div><div class="line">              <span class="keyword">struct</span> poll_table_struct *wait)</span></span>;</div></pre></td></tr></table></figure></p>
<p>　　tcp_poll就会根据sk的状态设置各种标志，其中最重要的一条是调用了sock_poll_wait(file, sk_sleep(sk), wait);这里的三个参数都有作用：<br>　　file:跟踪的具体文件描述符；<br>　　sk_sleep(sk):得到一个等待队列wait_address，维持了有阻塞在这个sock上的进程，通知唤醒用户进程就是通过这个等待队列来做的；<br>　　wait:poll_table的等待队列；<br>　　(4) poll_wait(file, wait_address, wait);也就是wait-&gt;_qproc(file, wait_address, wait);<br>　　这个过程比较的绕，就是在程序开始的时候，建立一个poll_wqueue的队列以及poll_table结构，并将__poll_wait注册为回调函数，然后遍历每个文件描述符的时候调用对应文件系统的底层poll函数，在文件系统驱动中去调用这个回调函数（主要就是把current当前进程挂载到设备的等待队列上去），设置相应的标志，并且返回。如果驱动程序的数据可用了，就会唤醒挂载到这个等待队列上的进程（没有区分到底是IN/OUT/EX事件触发的唤醒哦）。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核/">内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/linux-env-program-(2)-difference-select-poll-epoll.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-linux-env-program-(1)-async-blocking-io-model" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/linux-env-program-(1)-async-blocking-io-model.html" class="article-date">
      <time datetime="2016-04-26T10:18:29.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/linux-env-program-(1)-async-blocking-io-model.html">Linux环境开发（一）：同异步、阻塞的IO模型相关问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>　　其实这几个概念可能在实际的开发中并没有什么需要注意的，因为你调用什么函数就知道接下来需要怎么做了，但是如果要确实分清这几个概念的区别和联系，还是需要动动脑筋的。下面这幅图十分的好：<br><img src="/post_images/images/201604/62da0c7a07594deebfee5e538995fe34.gif" alt="LinuxIO模型矩阵"></p>
<p>　　总结来说，区分的关键点在于：<br>　　(1) 同步-异步：IO资源可用与否是自己去检测，还是依赖于状态、信号、回调等其它机制来通知；<br>　　(2) 阻塞-非阻塞：IO调用的函数在资源不可用时候是否立即返回，还是被挂起状态直到资源可用；</p>
<h1 id="一、同步阻塞IO">一、同步阻塞IO</h1><p>　　算是最简单最容易理解的模型了，且Linux默认的IO模型就是这样的，比如你用open打开文件或者socket创建套接字而没有显式使用O_NONBLOCK/SOCK_NONBLOCK参数的时候，那么后续使用read/write/recv/send等函数的时候，每当资源不可用，应用程序将阻塞在这些调用上面，直到这些调用成功后返回，程序才会继续执行下去。<br>　　这时候的阻塞，内核会将程序进程切换到睡眠的状态，当内核完成IO将数据返回到用户态可用的时候，程序会被切换继续运行下去。</p>
<h1 id="二、同步非阻塞IO">二、同步非阻塞IO</h1><p>　　通常在open和socket调用时候添加了O_NONBLOCK/SOCK_NONBLOCK标志，或者采用ioctl等机制后续设置了这个标志的时候，当调用上面的IO操作函数时候，如果此时资源不可用，调用会立即返回（通常返回EAGAIN/EWOULDBLOCK错误）。<br>　　这个时候应用程序通常的做法是sleep一会儿，或者干点别的事情，然后再次进行IO调用看资源是否可用了。总体来说该方法是比较低效率的，如果忙等待会浪费很多计算资源；且如果休眠时间长或者干别的事情长，那么总体IO响应将会变得很不及时。虽然习惯上称为“异步模式”开发，但本质上还是同步非阻塞的类型，而正规上称为基于事件驱动的开发方式。</p>
<h1 id="三、异步阻塞IO">三、异步阻塞IO</h1><p>　　这其实是一个带阻塞通知的非阻塞IO，是select/poll/epoll函数族的典型情况。从使用上来说，虽然将fd/socket设置为了非阻塞形式，但是select/poll/epoll的调用却是阻塞的，所以这里实际上将阻塞从原先的IO操作转嫁挪动到的资源的侦听操作(epoll_wait)上面了。</p>
<h1 id="四、异步非阻塞IO">四、异步非阻塞IO</h1><p>　　最复杂的情况了，在linux中有aio_xxxx()对应的函数族，其最大的特点是程序的执行和IO操作可以重叠执行：程序调用aio_xxxx()后立即返回，然后程序就执行其它的代码了，而内核完成IO操作之后，会通过状态、信号、回调函数等机制完成IO操作之后对应要处理的内容。<br>　　Windows的完成端口就是典型的异步非阻塞IO模型。而在Linux环境下，感觉异步非阻塞IO不太遭怎么待见，网站基本的构架都是基于epoll这类异步阻塞IO设计的。我想，这可能是因为异步非阻塞IO的优势不是特别的明显，而异步阻塞IO比较符合一般人的思维编程习惯吧。</p>
<p>　　注：后两者的差异，其实就是典型高性能IO设置中常说的Reactor模式和Proactor模式：Reactor中回调通知的是关心的事件或者资源是否就绪了，而真正需要应用程序自己读取或者写入数据；而Proactor模式中，应用程序不需要进行实际的读写过程，操作系统会读取缓存区或者写入缓存区到真正的IO设备，当收到通知的时候，真正的读写事件已经完成了。相比较而言，Proactor需要先分配内存，然后再处理IO操作，可以实现数据的Zero-Copy；同时Reactor模式所有的工作都在回调函数中处理，当回调函数任务繁重的时候，容易导致回调队列拥塞。<br>　　然后据陈硕所言，Linux下面还是Reactor模式较为成熟，Linux下的aio基本没有开发和完善的动力，这些异步操作接口很少使用在网络编程上，而是boost::asio为了跨平台，选取了Proactor模式而已(不过boost.asio也支持Reactor模式操作的)；此外，常用的Libevent就是典型的Reactor模式，而Libevent在Windows下只支持select的异步模式，不过如果是在Windows下的网络开发，可能大部分人还是会直接使用操作系统提供的完成端口机制吧，因为几乎没有看到程序先在Windows平台上开发，然后再兼容到Linux平台的。</p>
<p>本文完！</p>
<h1 id="参考">参考</h1><ul>
<li><a href="http://blog.jobbole.com/99765/" target="_blank" rel="external">聊聊同步、异步、阻塞与非阻塞</a></li>
<li><a href="http://www.ibm.com/developerworks/library/l-async/" target="_blank" rel="external">Boost application performance using asynchronous I/O</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-async/" target="_blank" rel="external">使用异步 I/O 大大提高应用程序的性能</a></li>
<li><a href="http://blog.jobbole.com/99912/" target="_blank" rel="external">聊聊IO多路复用之select、poll、epoll详解</a></li>
<li><a href="http://xmuzyq.iteye.com/blog/783218" target="_blank" rel="external">高性能IO设计的Reactor和Proactor模式</a></li>
<li><a href="http://www.zhihu.com/question/22064431" target="_blank" rel="external">为何 Boost 的 Asio 要使用 Proactor 模式实现？</a></li>
<li><a href="http://tech.youzan.com/tcp_network_programming/" target="_blank" rel="external">TCP网络编程杂谈</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核/">内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-oversee-of-http-based-on-libmicrohttpd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/oversee-of-http-based-on-libmicrohttpd.html" class="article-date">
      <time datetime="2016-04-26T07:54:10.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/oversee-of-http-based-on-libmicrohttpd.html">基于libmicrohttpd的HTTP服务器初探</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　最近写一个小项目，需要用到HTTP Server来支持一个API操作，正如同现在如火如荼的云API泛滥时代，感觉你不弄个开放接口都不好意思说自己是互联网公司。要求是用POST方式以及JSON数据格式发一个请求，然后服务端返回一个JSON格式的结果。当然用HTTP格式而非Socket方式的好处是显而易见的，HTTP是建立在socket之上的一个应用层协议，虽然性能可能不是最好的，但意味着你不用定义数据包的协议格式、容错以及通信过程中的各种繁琐的细节，只需要关注用户发送的有效负载信息及自己的处理逻辑设计实现就可以了。<br>　　说到HTTP可能最先想到的是Apache和Nginx，然而寡人不是做前端的，也不懂全世界最好的语言（PHP），更不晓得RESTful API，HTTP收到的JSON数据还不晓得怎么和后台的CGI结合起来。于是，这次另辟蹊径找到了libmicrohttpd，话说这个libmicrohttpd是用C写的，GNU旗下产品，支持Linux、Windows、以及andriod、symbian等平台（其定位就是作为一个嵌入式的HTTP库，方便集成到各个程序中去），支持SSL、session等机制，不过每个部分都比较简单，算是简单实现了一个HTTP的框架吧。</p>
<p><img src="/post_images/images/201604/843f0a282190edd9e34aff3cc52e8aa5.jpg" alt="libmicrohttpd"></p>
<h1 id="一、HTTP协议_-_libmicrohttpd">一、HTTP协议 - libmicrohttpd</h1><p>　　libmicrohttpd的文档算是比较的详细，但是用起来还是有点需要注意的：</p>
<h2 id="1-1_处理POST_JSON数据格式的请求">1.1 处理POST JSON数据格式的请求</h2><p>　　libmicrohttpd本身提供了POST数据的处理接口，在新连接到时候使用MHD_create_post_processor创建POST处理器，收到数据后，调用MHD_post_process处理，只不过得到的数据表示为带=的键值对形式，这对我们这种JSON数据显然是不行的。<br>　　如果需要自己收取处理数据，然后自己用JSON库来解析处理，那么我们需要做的是，将完整的数据收上来，然后自己手动处理数据。其思路为：<br>　　(1) 在create_response函数中，调用MHD_lookup_connection_value (connection, MHD_HEADER_KIND, MHD_HTTP_HEADER_CONTENT_LENGTH);，这会解析HTTP头部得到数据的长度，依据这个长度创建接受缓冲区；<br>　　(2) 不断地收数据，直到接受不到数据为止，然后检查收到的数据长度和之前头部报告的长度是否相等；<br>　　(3) 调用自己的数据处理接口。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/oversee-of-http-based-on-libmicrohttpd.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-server-prog-port-from-windows-to-linux" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/server-prog-port-from-windows-to-linux.html" class="article-date">
      <time datetime="2016-04-18T10:33:52.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/server-prog-port-from-windows-to-linux.html">Windows服务端程序向Linux移植经验总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　前面做了一些Windows服务端程序向Linux服务端程序的移植工作，还是有些收获的，这里整理记录一下，将工作内容和细节方面的东西供大家参考。<br>　　需要说明几点：这里的移植是真的移植，而不是考虑跨平台开发型的；这里的移植是针对无界面形式的程序，主要是服务端程序；那啥wine、mono的太大，就不考虑了。<br><img src="/post_images/images/201604/e7b52d9197604c2914da1244565384bb.jpg" alt="WINDOWS LINUX"></p>
<h1 id="一、数据类型定义">一、数据类型定义</h1><h2 id="1-1_数据类型的差异">1.1 数据类型的差异</h2><p>　　Windows和Linux的数据类型定义完全是两个风格，而且Windows的类型定义喜欢用大写字母，Windows的数据类型主要是定义在windef.h这个头文件里面的，可以将简单的数据类型按照目标机器翻译过来，当然也有些定义比较的复杂，不过很多却是没用的，可以安全的删掉。</p>
<h2 id="1-2_函数接口的差异">1.2 函数接口的差异</h2><p>　　Windows也是支持POSIX标准的，所以大多数的底层函数还是可以用的，但是某些函数的名字和参数签名等还是有些差异(比如stricmp/strcasecmp)，如果要在这个头文件里面处理，可以内联封装加进去。</p>
<h1 id="二、进程间的通信">二、进程间的通信</h1><h2 id="2-1_创建线程">2.1 创建线程</h2><p>　　Windows使用CreateThread创建线程，而Linux通常使用pthread线程库来实现多线程。</p>
<h2 id="2-2_多线程以及进程间同步">2.2 多线程以及进程间同步</h2><p>　　在Windows上面，除了CriticalSection是仅限线程间的同步之外，其他Mutex、Event、filemap，在使用的时候，只要设定了lpName，那么就可以在其他进程中用这个名字打开，就算是进程间的同步和通信了，否则的话就是线程间的同步。<br>　　不仅仅在这里，其实进程间通信Linux一般都有POSIX和SYS V两套接口，实际经验和感受来说POSIX的接口更加习惯好用一些。</p>
<table>
<thead>
<tr>
<th>Windows</th>
<th>Linux(线程)</th>
<th>Linux(进程)</th>
</tr>
</thead>
<tbody>
<tr>
<td>CriticalSection</td>
<td>pthread_mutex</td>
<td>-</td>
</tr>
<tr>
<td>Mutex</td>
<td>semaphore</td>
<td>semaphore</td>
</tr>
<tr>
<td>Event</td>
<td>semaphore</td>
<td>semaphore</td>
</tr>
<tr>
<td>filemap</td>
<td>shm、mmap</td>
<td>shm、mmap</td>
</tr>
</tbody>
</table>
<p>　　shm和mmap其实都差不多，但是如果有些数据不像映射到硬盘文件系统上（比如处于保密安全考虑），那么就推荐使用shm来实现。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/server-prog-port-from-windows-to-linux.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-recommend-system-algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/recommend-system-algorithm.html" class="article-date">
      <time datetime="2016-04-12T10:34:18.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/recommend-system-algorithm.html">推荐系统常用的推荐算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="一、推荐系统概述和常用评价指标">一、推荐系统概述和常用评价指标</h1><h2 id="1-1_推荐系统的特点">1.1 推荐系统的特点</h2><p>　　在知乎搜了一下推荐系统，果真结果比较少，显得小众一些，然后大家对推荐系统普遍的观点是：<br>　　(1) 重要性程度UI&gt;数据&gt;算法，就是推荐系统中一味追求先进的算法算是个误区，通常论文研究得到的推荐方法有的带有很多的假设限制，有的考虑工程实现问题较少，推荐系统需要大量的数据整理和转化，同时更需要考虑公司业务特性以及与现有系统的集成，方能形成推荐系统和业务之间的良性循环；<br>　　(2) 推荐系统离线测试很好，上线后要么没有严格的测试结果而只能凭感觉，要么实际效果差强人意，我想主要缘于离线测试比较理想，而在线AB冠军测试无论对于前端还是后台要求都很高，没有雄厚的研发实力难以实现；<br>　　(3) 推荐系统受到的外部干扰因素特别多（季节、流行因素等），整个系统需要不断的迭代更新，没有一劳永逸的事情。<br><img src="/post_images/images/201604/f732c70cc213540804f4220ac672c727.jpg" alt="推荐系统图"></p>
<h2 id="1-2_推荐系统的评价指标">1.2 推荐系统的评价指标</h2><p>　　由于推荐系统比较复杂，所以涉及到的评价指标也很多。当然，用户满意度最为的有效，因为这本来就是推荐系统的最终目标，但是奈何资源有限成本太高，推荐系统还依赖于其它客观评价指标。<br>　　(1) 推荐准确度：<br>　　这个参数可以离线计算所得，而且较为的客观，所以是各大研究论文算法最重要的参考指标。总体来说，推荐系统有两大任务：“预测”和“推荐”，所以推荐系统准确度的评分包括：<br>　　a. 评分预测：学习用户的评价模型，用于预测用户对于未接触事物的评分，其实可以看作是一个回归模型，一般用均方根误差或者绝对误差来衡量；<br>　　b. TopN推荐：给用户一个个性化的推荐列表，其一般通过准确度、召回率等指标评估。其中N也是一个可变参数，可以根据不同的N描绘出对应算法的ROC曲线来进一步评价推荐效果；<br>　　(2) 覆盖率：<br>　　体现了挖掘算法对发掘长尾商品的能力。最简单的定义是，对所有用户推荐出的产品做并集，然后看这个出现的并集产品与总产品数中所占的比例，这种方式比较的粗线条，因为推荐系统中马太效应(马太效应，是指强者越强、弱者越弱的社会现象)频繁，所以好的推荐算法应当是所有商品被推荐的几率差不多，都可以找到各自合适的用户，所以实际中会考虑信息熵、基尼系数等指标。
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/recommend-system-algorithm.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-recommend-system-cases" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/recommend-system-cases.html" class="article-date">
      <time datetime="2016-04-12T10:27:57.000Z" itemprop="datePublished">2016-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/recommend-system-cases.html">推荐系统的典型推荐案例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　还依稀记得我小的时候，爸爸骑着自行车带我买东西，有时候在小店面，有时候去供销合作社，基本都是跟售货员说：我要一包火柴、3块肥皂、一瓶酱油等等，最多有的时候售货员会问你说要好的、一般的还是便宜的，形式有些像现在的普通药店形式；后来超市开始慢慢走入我们的生活，超市提供的选择和类型就开始多了，而且你还可以逛逛多家超市比较自己喜欢和便宜的，也不用觉得“问了人家或者人家推荐了，不买又不好意思”；现今随着互联网的浪潮，电商变的越来越流行，轰炸式的广告让农村五六十岁的大叔大妈都知道买东西可以找淘宝、京东，而淘宝、亚马逊这些电商的产品目录是绝大多数超大型超市也难以比拟的（当然这之中还有一个国内市场混乱、诚信缺失的因素，导致各类欺诈、假冒伪劣案例频发，所以现今越来越多的人买东西都会选择大型商家自营来挑选了）。<br>　　其实，就是当今社会生产力的发展，导致各行各业的产品过载，越来越多的人患上了选择恐惧症：吃饭不知道吃啥，听歌不知道听啥，打开浏览器不知道干嘛……虽然我在先前的<a href="">文章</a>中告诫大家不要在浩繁的信息海洋中被淹没而让自己的大脑越来越慵懒，遇事要有自己的主见，选择自己的所需所爱，否则你的依赖性会越来越强，但如果对于一个数据挖掘工程师来说，这何尝又不是一个巨大的机遇呢？<br>　　前段时间在搜索资料的时候，偶遇“推荐系统”这个话题，觉得还蛮有意思的。曾经Amazon的老大貌似说过要了解自己的每一个客户，亚马逊能称为全球最大的电商，跟其强大的推荐系统不无关系，不断作为推荐系统研究的经典案例，也为全球各大新兴电商尽相模仿。买了本<a href="https://book.douban.com/subject/26371405/">《京东平台数据化运营》</a>，说实话，这本书算是个京东商家后台操作手册，其中基本难寻技术干货，但同时也折射出电商对于数据化运营之重视。国内对于推荐系统的教材寥寥，项亮所著<a href="https://book.douban.com/subject/10769749/">《推荐系统实践》</a>算是写的比较早的，内容也还可以。刚看了前两章，其中所著推荐系统案例让我大开眼界、不愿独享，因此摘录下来推荐给大家。</p>
<p>　　正如上文所说的，推荐系统主要是在当前信息和产品过载情况下最为有用，因为如果可供选择的类别的很少，用户完全可以按照自己的喜好、或者收集相关信息做出自己的选择。当前在电商、影视音乐、社交网络、阅读、广告等，算是推荐系统使用最为广泛的领域。</p>
<h1 id="一、电商">一、电商</h1><p>　　电商类的推荐，首推强大的亚马逊了，其讲求的是了解每个客户，针对客户个性化推荐。当打开自己的推荐列表的时候，不仅显示出推荐的内容、评分，还提供了与用户交互反馈式的方式：我拥有了、我不感兴趣、评分，甚至显示出给你推荐的理由，由此可见亚马逊推荐功能之强大，同时对自己的推荐系统之自信。当然我在亚马逊购物的东西还不多，亚马逊可用的信息应当包括购买记录、添加购物车历史、搜索历史、浏览历史等信息，甚至还包括你的购物趋势(Inspired by your shopping trends)，当然还有那些Facebook等社交网络推荐、打包销售等还没能体会到。<br>　　作为海淘一族，下面是Amazon针对自己的推荐信息：<br><img src="/post_images/images/201604/137dcdf3e514a2ca4dd36df276e806ec.jpg" alt="Amazon推荐内容"><br>　　引用亚马逊CEO Jeff Bezos:</p>
<blockquote>
<p>“We have 6.2 million customers, we should have 6.2 million stores. There should be the optimum store for each and every customer.”<br>　　据称推荐系统给亚马逊贡献了20%~30%的收入，可见一个好的推荐系统比一般广告的收益率要高的多！<br>　　国内的京东也在倡导数据化运营，为个人生成的购物基因还是蛮有意思的。<br><img src="/post_images/images/201604/40f368924eafb4b67d4c034aef2fe77e.jpg" alt="京东购物基因"><br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/recommend-system-cases.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-how-to-calc-svd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/how-to-calc-svd.html" class="article-date">
      <time datetime="2016-04-09T17:20:04.000Z" itemprop="datePublished">2016-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/how-to-calc-svd.html">SVD的数学计算步骤</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>涉及到矩阵论相关的东西，这里查资料需要把他彻底搞个明白，幸好找到了参考中的pdf文档，写的很详细很入门，于是就拜读了一下。对于知道的人不要笑话，不知道的赶紧补课吧！</p>
<h1 id="一、线性代数相关基础">一、线性代数相关基础</h1><ul>
<li>点乘/内积: $(\vec{x},\vec{y}) = \vec{x}\cdot\vec{y} = \sum_{i=1}^nx_i+y_i$<br>要求点乘的两个向量的维度相同</li>
<li>正交：$\vec{x}\cdot\vec{y} = 0$<br>两个向量的点乘为0</li>
<li>标准向量：|$\vec{x}| = \sqrt{\sum_{i=1}^nx_i^2} = 1$<br>向量的长度为1</li>
<li>Gram-Schmidt正交化：<br>用于产生一个矩阵的标准正交基，定义为每个列向量的长度为1，不同列向量相互正交，计算过程为：<br>（1）对于第一列，对向量的模长进行标准化；<br>（2）后面的每一列，依次按照公式$\vec{w}_k = \vec{v}_k - \sum_{i=1}^{k-1}\vec{u}_i\cdot\vec{v}_k*\vec{u}_i$进行计算，然后将计算结果$\vec{w}_k$进行标准化。<br>如果标准正交基是方阵，那么叫做正交矩阵，且$\vec{A}\vec{A}^T=\vec{I}$。</li>
<li>矩阵的乘法：<br>如果$\vec{A}$和$\vec{B}$分别是维度为(m,n)和(n,s)的矩阵，那么$\vec{A}\vec{B}$结果的维度就是(m,s)。</li>
<li>对角矩阵：<br>对角线上的元素全不为零，其余元素全部为零的方阵。</li>
<li>单位矩阵：<br>除了对角线上的元素为1，其他元素都为0的方阵，且$\vec{A}\vec{I}=\vec{A}$。</li>
<li>行列式：<br>将一个方阵映射而成的数值，根据其方阵的维度不同，计算如下：<br>（1）$\vec{A} = \begin{bmatrix}a\end{bmatrix}$，$det(\vec{A})=a$;<br>（2）$\vec{A} =\begin{bmatrix}a&amp;b\\c&amp;d\end{bmatrix}$，$det(\vec{A})=ad-bc$;<br>（3）对于更高维度的，按照第一行展开成低纬度的子方阵计算，展开过程中交替改变符号。<br>这里给出一个例子，计算检验看看对不对（$det(\vec{A})=-36$）。<br>$$\vec{A}=\begin{bmatrix}1&amp;2&amp;3&amp;4\\ -1&amp;-2&amp;-7&amp;-4\\2&amp;3&amp;4&amp;5\\ -2&amp;-3&amp;5&amp;4\end{bmatrix}$$</li>
<li>特征值和特征向量：<br>对于方阵$\vec{A}$满足$\vec{A}\vec{v}=\lambda\vec{v}$，那么非0向量$\vec{v}$为特征向量，$\lambda$为特征值。其实可以上面看作是个方程组的解的问题，将$\vec{A}$看成方程组的系数，那么特征向量为方程组的解，比如<br>$\vec{A} =\begin{bmatrix}2&amp;1\\1&amp;2\end{bmatrix}$，那么<br>$$\vec{A}\vec{v}=\lambda\vec{v}=\begin{bmatrix}2&amp;1\\1&amp;2\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}=\lambda\begin{bmatrix}x_1\\x_2\end{bmatrix}$$<br>其整理后就为<br>$$\begin{bmatrix}(2-\lambda)&amp;1\\11&amp;(2-\lambda)2\end{bmatrix}=0$$<br>解得特征值为$\lambda_1=3,\lambda_2=1$，对应的特征向量为$\begin{bmatrix}1,1\end{bmatrix}$和$\begin{bmatrix}1,-1\end{bmatrix}$。</li>
</ul>
<h1 id="二、进行SVD奇异值分解">二、进行SVD奇异值分解</h1><p>SVD的目的，就是将一组相关的变量投射到某个超平面，形成相互无关的变量，用以更好的显示变量之间的差异性，同时还可以根据相关性进行排序，找出哪些属性的差异最明显，可选择的保留差异性大的属性，从而实现了数据的降维。其寻找的超平面具有以下目的：</p>
<ul>
<li>最近重构性：样本点到这个超平面的距离都足够近；</li>
<li>最大可分性：样本在这个超平面上的投影都尽可能的分开；<br>SVD的最简洁表达公式如下<br>$$\vec{A}_{mn}=\vec{U}_{mm}\vec{S}_{mn}\vec{V}_{nn}^T$$<br>其中，$\vec{A}_{mn}$为原始信号，$\vec{U}_{mm}$和 $\vec{V}_{nn}$都是两个正交矩阵，$\vec{V}_{nn}^T$为 $\vec{V}_{nn}$的转置，$\vec{S}$为对角矩阵，那么$\vec{A}_{mn}$就可以用右边的三个公式表示出来。</li>
</ul>
<h2 id="2-1_SVD分解">2.1 SVD分解</h2><p>下面介绍SVD分解的计算过程：</p>
<ul>
<li>给定原始信号$\vec{A}$，计算 $\vec{A}_{mn}\vec{V}_{nm}^T$，得到(m,m)方阵；</li>
<li>计算方阵的特征值和特征向量；</li>
<li>按照特征值从大到小的顺序，依次取其特征向量作为列，组成矩阵$\vec{U}’$；</li>
<li>对$\vec{U}’$进行Gram-Schmidt正交化形成正交矩阵$\vec{U}_{mm}$；</li>
<li>依照上面类似的过程，采用$\vec{A}_{nm}^T\vec{V}_{mn}$进行计算，最终得到正交矩阵$\vec{V}_{nn}$，再行转秩得到$\vec{V}_{nn}^T$；</li>
<li>对于$\vec{S}$，是使用上面的非0特征值按照从大到校的顺序开放形成对角矩阵，对于矩阵维度不满足，右端依次添加0列即可；</li>
<li>用$\vec{U}_{mm}\vec{S}_{mn}\vec{V}_{nn}^T$就可以重构$\vec{A_{mn}}$了。</li>
</ul>
<h2 id="2-2_SVD用于降维的额外操作">2.2 SVD用于降维的额外操作</h2><p>上面是SVD分解，所以最终得到的三个变量是能够完全重构原来的输入信号的。在上面计算的特征值的时候，如果按照从大到小的顺序，实际就是按照属性差异从大到小进行的排列，一般来说可以事先固定设定$\lambda$的个数，或者取总$\lambda$和前95%部分的$\lambda$来决定降维的程度。<br>比如对原始的信号属性从n维降低到r维度，只需要用原始信号乘以前r列的特征向量就可以了。<br>$$\vec{A}_{mn}\vec{U}_{n,1:r}\approx\hat{A}_{mr}$$<br>就可以了。</p>
<p>其实，本质上PCA跟SVD就是一个东西～～<br>本文完！</p>
<h1 id="参考">参考</h1><ul>
<li><a href="https://www.ling.ohio-state.edu/~kbaker/pubs/Singular_Value_Decomposition_Tutorial.pdf" target="_blank" rel="external">Singular Value Decomposition Tutorial</a></li>
<li><a href="https://zh.wikipedia.org/zh/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3" target="_blank" rel="external">奇异值分解</a></li>
<li><a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="external">机器学习中的数学(5)-强大的矩阵奇异值分解(SVD)及其应用</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-conclusion-of-machine-learning-algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201604/conclusion-of-machine-learning-algorithm.html" class="article-date">
      <time datetime="2016-04-07T05:26:27.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201604/conclusion-of-machine-learning-algorithm.html">不带公式的机器学习算法整理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>生命不息，奋斗不止。持续更新中…</p>
<p>　　这个题目取得比较奇怪，原因是：虽然号称数学是世界上最简洁的语言，但是太多的公式难免看的人心慌；其次是公式在hexo+mathjax打起来比较的费劲，还有兼容性问题。其实，本意就是想把常用算法罗列一下，用个一两段文字描述一下基本意思和原理，还有用途和局限性，如果看看记不起来了，再去寻求一大堆资料温习一下。其实机器学习常用的算法都比较老了，各种语言的学习库也久经考验，正如越来越多的码农沦为系统集成工程师一样，数据挖掘虽然不用从头实现算法的各个部分，但是如果能对流程和数据特性了如指掌，对各种算法适用范围、优缺点、参数含义烂熟于心，对各种业务指标期望有的放矢，岂不乐哉～<br>　　在此还想啰嗦的一句是，这么多算法无论复杂与简单，大多（统计类的可能有些例外）遵循了给出一个模型—计算误差—修正系统，直到得到最优解或者可以接受的误差为止，由此不得不感叹道维纳“控制论”之伟大！<br><img src="/post_images/images/201604/3dd9457bf78c0383571901dab41eb69f.png" alt="Machine Learning"></p>
<h1 id="一、分类">一、分类</h1><h2 id="1-1_贝叶斯">1.1 贝叶斯</h2><p>　　遵循贝叶斯公式框架的理论，后验概率正比于先验概率与似然度之积。</p>
<h3 id="1-1-1_朴素贝叶斯">1.1.1 朴素贝叶斯</h3><p>　　朴素贝叶斯之所以朴素，是基于“属性条件的独立性假设”而使得模型的计算被简化了。具体来说，就是输入样本有N维的属性，所有属性之间相互独立，每个属性单独独立的对分类结果产生影响。<br>　　对于离散值，就考虑每个属性出现的频率关系得到概率关系，而对于连续的属性，可以考虑其分布类型的概率密度函数。离散属性中，贝叶斯分布一般可以分为Bernoulli /Multinomial，前者是二项式分布，后者是多项式分布。对于统计的元素前者出现与否只有0、1两个状态，后者多项式分布，会记录出每个元素的具体出现频率。一般短文本分类的情况，适用于二项式分布，长文本分析的类似情况，使用多项式分布效果较好。<br>　　在文本分类（情感分析）中，使用过贝叶斯分类，很明显：先验概率就是训练文档各个分类的文档比重，此时你没有观测数据，那么按照这么个比例把握比较大，相似度就统计各个分类中词的出现与否/频率，然后对待测的数据，衡量待测数据中出现的词在各个分类中的比率来计算和各个分类的相似程度，最终修正先验概率得到后验概率。关于伯努利分布和多项式分布，在具体文本测试中两者估计就一个多点的差异，尚不是很明显。<br>　　这两个实现和求解的过程都比较简单，性能还不错，注意建模时候需要平滑处理，防止最终计算概率时候未出现词导致概率为0，其中常用的拉普拉斯修正~“+1”平滑实现简单而且有效。</p>
<h3 id="1-1-2_半朴素贝叶斯">1.1.2 半朴素贝叶斯</h3><p>　　朴素贝叶斯有属性独立性假设，这种假设在现实中并不是总是成立的，所以对属性独立性假设进行放松就形成了版朴素贝叶斯，比如常见的“独依赖估计”(ODE)，其就是假设每个属性在类别之外最多依赖一个其他的属性（如果增加依赖的属性可能计算结果会变好，但是高阶联合概率计算十分复杂），而这个被依赖的属性选择方法就成了这类算法的研究点：比如所有属性都依赖同一个属性，而这个父属性可以通过交叉验证来选择最好的。</p>
<h3 id="1-1-3_贝叶斯网络">1.1.3 贝叶斯网络</h3><p>　　又称为信念网络(Belief Network)，借助于有向无环图(DAG)来刻画属性之间的依赖关系。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数学/">数学</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201604/conclusion-of-machine-learning-algorithm.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2017 taozj
            </div>
            <div class="footer-right">
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">
                    <img src="/post_images/icons/icp_min.png" alt="粤ICP备17002382号-1">粤ICP备17002382号-1
                </a>
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258402767'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1258402767%26online%3D2' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>, theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a>  enhanced by Nicol <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>
<script src="/js/search.js"></script> 


    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>


   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</script>

  </div>
</body>
</html>