<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>GNU GDB调试手册 | 桃子的博客铭</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="人家都说Windows平台下的程序员是幸福的，因为Visual Studio实在是太好用了。　　我想一听到上面这句话，绝大多数Linux平台C/C++程序员都将会沉默，至少网上搜Linux平台下C/C++开发调试，很大一部分文章都是介绍搭建IDE的，这也侧面说明了Linux平台下没有一个占绝对主流地位好用的IDE。自己平时写程序是用的SlickEdit，这个IDE很贵，支持代码补全和跳转，调试">
<meta property="og:type" content="article">
<meta property="og:title" content="GNU GDB调试手册">
<meta property="og:url" content="https://taozj.org/201701/gnu-gdb-debug.html">
<meta property="og:site_name" content="桃子的博客铭">
<meta property="og:description" content="人家都说Windows平台下的程序员是幸福的，因为Visual Studio实在是太好用了。　　我想一听到上面这句话，绝大多数Linux平台C/C++程序员都将会沉默，至少网上搜Linux平台下C/C++开发调试，很大一部分文章都是介绍搭建IDE的，这也侧面说明了Linux平台下没有一个占绝对主流地位好用的IDE。自己平时写程序是用的SlickEdit，这个IDE很贵，支持代码补全和跳转，调试">
<meta property="og:updated_time" content="2017-02-15T14:52:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GNU GDB调试手册">
<meta name="twitter:description" content="人家都说Windows平台下的程序员是幸福的，因为Visual Studio实在是太好用了。　　我想一听到上面这句话，绝大多数Linux平台C/C++程序员都将会沉默，至少网上搜Linux平台下C/C++开发调试，很大一部分文章都是介绍搭建IDE的，这也侧面说明了Linux平台下没有一个占绝对主流地位好用的IDE。自己平时写程序是用的SlickEdit，这个IDE很贵，支持代码补全和跳转，调试">
  
    <link rel="alternative" href="/atom.xml" title="桃子的博客铭" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/iconfont.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">taozj</a></h1>
        </hgroup>

        
        <p class="header-subtitle">高性能、高可用服务端开发</p>
        
        <br>
        
        <p class="header-subtitle">淡泊明志，宁静致远！</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">文章归档</a></li>
                        
                            <li><a href="https://album.taozj.org">个人相册</a></li>
                        
                            <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                        
                            <li><a href="/about">请你读我</a></li>
                        
                            <li><a href="/search.html">搜索本站</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作/">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构架/">构架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">taozj</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">taozj</a></h1>
            </hgroup>
            
            <p class="header-subtitle">高性能、高可用服务端开发</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="https://album.taozj.org">个人相册</a></li>
                
                    <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                
                    <li><a href="/about">请你读我</a></li>
                
                    <li><a href="/search.html">搜索本站</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-gnu-gdb-debug" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201701/gnu-gdb-debug.html" class="article-date">
      <time datetime="2017-01-19T13:03:50.000Z" itemprop="datePublished">2017-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      GNU GDB调试手册
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内核/">内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>　　人家都说Windows平台下的程序员是幸福的，因为Visual Studio实在是太好用了。<br>　　我想一听到上面这句话，绝大多数Linux平台C/C++程序员都将会沉默，至少网上搜Linux平台下C/C++开发调试，很大一部分文章都是介绍搭建IDE的，这也侧面说明了Linux平台下没有一个占绝对主流地位好用的IDE。自己平时写程序是用的SlickEdit，这个IDE很贵，支持代码补全和跳转，调试过程也支持断点、Watch等特性，但是使用过程中还是有这样那样的小问题(比如非英文字串显式、速度比较慢)，但是总体比较而言还是比较优秀的跨平台C/C++ IDE。虽然线下编码调试使用这货当然可以，然则线上环境就无能为力了，再加上自己之前对gdb也只是了解个表明，这次就顺着gdb的文档深挖一下！<br>　　真是一看吓一跳，gdb的命令行调试要远比IDE的功能高级的多，如果只是通常的设置断点，监测变量什么的可能IDE比较方便，但是一旦上升到高级点的调试技巧，反而gdb在命令行的模式下更为的方便和高效。<br>　　前方预警：<strong>这将会是一篇很长很长的文档摘读</strong>。</p>
<h1 id="一、开始使用gdb">一、开始使用gdb</h1><h2 id="1-1_启动gdb">1.1 启动gdb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ gdb program [core|pid]</div><div class="line">➜  ~ gdb --args g++ -O2 -o main main.cpp</div><div class="line">(gdb) shell <span class="built_in">echo</span> <span class="variable">$SHELL</span></div><div class="line">(gdb) <span class="built_in">set</span> logging on</div></pre></td></tr></table></figure>
<p>　　gdb接需要调试的程序可执行文件，后面可以附加core文件或者pid进程号(调试正在运行的进程)，如果有第三个参数gdb总是先尝试解释他为core文件，然后才是进程号。第二种格式采用–args，待调试的程序执行的时候需要额外的参数，此时可执行程序后面的参数不再被gdb解释。<br>　　组合键Ctrl-D或者输入quit可以退出调试状态，如果之前attach到一个进程上面去了，可以用detach命令释放进程，如果quit有表达式那么表达式就作为gdb的退出状态，否则是被调试的子进程的退出状态。gdb中使用Ctrl-C不会终止gdb，而是会终止gdb正在运行的调试指令返回到gdb命令状态。<br>　　在gdb中可以使用shell或者!做前导来执行shell中的命令而不用退出gdb(gdb的退出和重启动的代价是很大的)，make命令可以用来重新编译程序而不用先导shell|!符号，而gdb自动重新加载符号。<br>　　通过set logging on可以打开日志功能，默认会将日志输出追加到当前目录的gdb.txt文件中。</p>
<h2 id="1-2_gdb中的命令">1.2 gdb中的命令</h2><p>　　gdb是很智能的，所有的命令都可以使用TAB、TAB-TAB进行补齐或者提示，不输入任何命令的空换行(在可能的情况下)表示重新执行前一条指令，这节省了重复输入step|list等指令的劳动。gdb允许指令和参数的缩减输入，没有歧义的时候会运行，而在遇到歧义的时候起会提示出各个歧义的命令列表供参考。<br>　　有些命令参数中可能含有特殊的符号(比如括号)，尤其在C++允许函数重载的时候需要使用参数类型来进行区分，此时参数需要使用 ‘ 单引号来包围，而且在需要的时候gdb也会自动帮你包围并给出候选列表的。</p>
<h2 id="1-3_gdb帮助">1.3 gdb帮助</h2><p>　　gdb本身附带了很多帮助命令，比如：<br>　　<strong>help <em>command</em></strong>：显示名的帮助信息<br>　　<strong>apropos <em>args</em></strong>：会在命令名、文档中搜索指定的表达式<br>　　<strong>info <em>args|registers|breakpoints|…</em></strong>：可以显示很多状态信息，具体可以查看help info<br>　　<strong>set <em>var val</em></strong>：设置环境变量<br>　　<strong>show <em>var</em></strong>：显示环境变量的值</p>
<h2 id="1-4_调试执行程序">1.4 调试执行程序</h2><p>　　对于待调试程序编译时候，总应该使用-g选项生成调试信息。<a id="more"></a></p>
<h3 id="1-4-1_启动调试程序">1.4.1 启动调试程序</h3><p>　　<strong>run/r</strong><br>　　必须在gdb启动的时候指定调试文件，或者启动后再使用exec|exec-file指定调试文件。启动的时候gdb会创建子进程(inferior process)并在子进程中立即运行该程序。run命令后面可以接参数，所有的参数都会被传递给可执行程序，而下次调试如果直接run而不添加参数，上一轮的参数会被继承自动添加(下面的start也是一样)。<br>　　除了在调用run/start的时候指定参数，还可以单独调用set args方法设置参数。参数的展开和shell规则一样，而且支持输入输出重定向(比如&gt;aa.txt)，展开后传递给run/start使用。<br>　　<strong>start</strong><br>　　该命令会在程序入口函数的地方(C/C++默认是main)添加一个临时断点，然后程序立即运行并在入口函数的地方被暂停。<br>　　此处还需要注意，C++程序在执行main之前会创建static和全局变量，他们的构造函数会被调用，所以程序入口函数不一定会被最早执行的程序代码。</p>
<h3 id="1-4-2_调试运行的进程">1.4.2 调试运行的进程</h3><p>　　<strong>attach process-id</strong><br>　　可以用来跟踪一个已经在运行的进程，然后被跟踪的进程会暂停执行，然后可以做任何的调试操作，以及continue让程序继续执行。同时，gdb还会在当前工作路径、源代码搜索路径等地方搜索该进程的可执行文件，当然也可以使用file命令手动加载可执行文件。<br>　　<strong>detach</strong><br>　　一旦detach之后程序会继续执行，而且和gdb再无瓜葛了。如果当前有attach的进程而使用Ctrl-D退出gdb，gdb会提示是否要detach调试的进程。<br>　　<strong>kill</strong><br>　　该命令会kill掉当前调试的进程，无论是run/start创建的还是attach调试的。常用情况是修改代码后需要重新调试，此时可以先kill掉当前调试，然后编译出新的可执行程序，再使用run/start开启调试，此时gdb会发现可执行程序已经修改了，会重新读取符号表信息(但是之前的断点等信息还是得以保留的)。</p>
<h3 id="1-4-4_调试多线程程序">1.4.4 调试多线程程序</h3><p>　　线程除了共享地址空间之外，拥有自己独立的寄存器状态、执行栈和线程存储。gdb可以查看跟踪进程的所有线程的状态信息，但是只能有一个线程处于当前被跟踪的状态。<br>　　<strong>info threads [thread-id-list]</strong><br>　　显示所有(或者指定)线程的信息，带星号标识的是当前跟踪的线程。<br>　　<strong>thread thread-id</strong><br>　　切换thread-id线程为当前跟踪线程。<br>　　<strong>thread apply [thread-id-list | all] command</strong><br>　　在所有(或者指定)线程线程上执行command命令。<br>　　<strong>thread name [name]</strong><br>　　设置线程的名字(info threads中会显示)，如果不带参数，会恢复名字为操作系统默认名字。</p>
<h3 id="1-4-5_调试fork创建的多进程程序">1.4.5 调试fork创建的多进程程序</h3><p>　　GDB对fork产生新进程的调试没有特殊的支持，当使用fork产生子进程的时候，GDB会继续调试父进程，子进程不会被阻碍而是继续执行，而此时如果子进程遇到断点后，子进程会收到SIGTRAP信号，当在非调试模式下默认会导致子进程中止。如果要调试子进程，可以让子进程启动后睡眠一段时间(或者监测某个文件是否创建)，在这个空隙中使用ps查看子进程的进程号，然后再启动gdb去attach到这个进程上面去调试。<br>　　通过catch命令可以让gdb在fork/vfork/exec调用的时候暂停执行。<br>　　影响fork多进程调试还有以下几个变量：<br>　　<strong>follow-fork-mode</strong><br>　　可选值是parent或child，指明当正在被调试的进程fork出子进程的时候，如果该值是parent，那么父进程被调试子进程正常执行，这也是默认行为；而当其为child的时候，则新创建的子进程被调试，父进程正常执行。<br>　　<strong>detach-on-fork</strong><br>　　可选值是on或off，知名当被调试的进程fork出子进程后，是否detach某个进程还是调试他们俩，如果是on，那么子进程(或父进程，取决于上面follow-fork-mode的值)将会被detach正常执行，这是默认行为；否则两个进程都会被gdb控制，其中的一个进程被正常调试，另外一个进程被suspend住。<br>　　<strong>follow-exec-mode</strong><br>　　gdb对于exec调用的反应，其值可以为new或same，当值为new的时候，之前fork的子进程和exec后的进程都会被保留；如果是same，则exec的进程使用之前fork的进程，exec会用新的执行镜像替代原先的可执行程序，这是默认行为。</p>
<h3 id="1-4-6_设置书签保存历史状态">1.4.6 设置书签保存历史状态</h3><p>　　gdb可以在程序执行的过程中保留快照(状态)信息，称之为checkpoint，可以在进来返回到该处再次查看当时的信息，比如内存、寄存器以及部分系统状态。通过设置checkpoint，万一调试的过程中错误发生了但是已经跳过了错误发生的地方，就可以快速返回checkpoint再开始调试，而不用重启程序重新来过。<br>　　<strong>checkpoint</strong><br>　　对当前执行状态保存一个快照，gdb会自动产生一个对应的编号供后续标识使用。从提示信息看来，其实每建立一个checkpoint，都会fork出一个子进程，所以每个checkpoint都有一个唯一的进程ID所对应着。<br>　　<strong>info checkpoints</strong><br>　　查看所有的checkpoint，包括进程ID、代码地址和当时的行号或者符号。<br>　　<strong>restart checkpoint-id</strong><br>　　恢复程序状态到checkpoint-id指明的checkpoint，所有的程序变量、寄存器、栈都会被还原到那个状态，同时gdb还会将时钟信息回退到那个点。恢复过程中程序的状态和系统的部分状态是支持的，比如文件指针等信息，但是写入文件的数据、传输到外部设备的数据都无法被回退。<br>　　<strong>delete checkpoint checkpoint-id</strong><br>　　删除指定的checkpoint。<br>　　此外，checkpoint的作用还在于断点、观测点不是什么情况下都可用的情况下，因为Linux系统有时候为了安全考虑，会随机化新进程的地址空间，这样重启调试程序会导致之前使用绝对地址设置的断点、观测点不可用。</p>
<h1 id="二、中断和继续运行">二、中断和继续运行</h1><h2 id="2-1_断点、监视点和捕获点">2.1 断点、监视点和捕获点</h2><p>　　gdb除了普通断点，还支持检测点(watchpoint)、捕获点(catchpoint)两类特殊的断点类型，他们都能使用enable、disable、delete进行管理。检测点会在检测的变量以及使用运算符组合成的表达式的值发生改变的时候暂停程序的执行；catchpoint是在某个事件发生的时候暂停程序的执行，比如C++抛出异常、加载库的时候。</p>
<h3 id="2-1-1_断点">2.1.1 断点</h3><p>　　<strong>break [location]</strong><br>　　location可以是函数名、行号、指令地址，在程序执行到这些指定位置前会暂停下来(暂停时候这些位置的任何代码都不会被执行)。如果没有location参数，则断点会在下一条执行的指令前设置，在最内帧中gdb会在下次执行到该点的时候暂停，这种情况最常见的是在循环中使用。<br>　　<strong>break … if cond</strong><br>　　每次指定到该点的时候会先计算cond的状态，当cond!=0的时候断点生效，程序执行暂停下来。而且在同一个位置，可以使用不同的条件设置多个条件断点。<br>　　<strong>tbreak args</strong><br>　　只生效一次的临时断点，一旦断点生效程序暂定在这个断点处的时候，该断点会被自动删除掉。<br>　　<strong>rbreak regex</strong><br>　　在所有匹配regex正则表达式的函数名处都设置断点，并打印出这些新设置的断点。正则表达式的元字符含义同grep工具的含义(而同shell有所差别)。这在C++设置重载函数断点的时候十分有效。<br>　　<strong>rbreak file:regex</strong><br>　　通过一个文件名的前缀，可以缩小rbreak设置断点的范围(否则库的头文件也会被搜索并设置断点)。<br>　　<strong>info break|breakpoints</strong><br>　　查看断点(同时还包括watchpoint和catchpoint)，同时如果断点被触发了，还会显示触发的次数信息。</p>
<p>　　在一个位置上设置断点，其本质上可以对应于多个位置，比如：同名重载函数、C++合成的多个构造函数、模板函数和模板类、inline函数。对于这种单个断点多个地址的情况，gdb会自动在需要的位置插入断点，当使用info break显示的时候，会以breakpoint-number.location-number的方式显示，断点管理可以引用breakpoint-number，或者针对某个子地址的断点操作。<br>　　动态库也支持断点，不过其地址需要在加载库的时候才能解析，因此动态库中的断点在未能解析地址前都是pend状态，同时动态库在程序执行的过程中也可能进行多次加载和卸载的操作，gdb在只要有动态库加载和卸载操作的时候，都会重新计算断点的位置信息。</p>
<h3 id="2-1-2_监视点">2.1.2 监视点</h3><p>　　监视点是监视特定表达式的值是否改变而触发程序暂停执行，而不用去关心该值到底在代码的哪个位置被修改的。监视的表达式可以是：某个变量的引用、强制地址解析(比如<em>(int </em>)0x12345678，你无法watch一个地址，因为地址是永远也不会改变的)、合理的表达式(比如a-b+c/d，gdb会检测其中引用的各个变量)。<br>　　<strong>watch [-l|-location] expr [thread thread-id] [mask maskvalue]</strong><br>　　thread-id可以设置特定线程改变expr的时候触发中断，默认情况下针对硬件模式的检测点所有的线程都会检测该表达式；-location会让gdb计算expr的表达式，并将计算的结果作为地址，并探测该地址上的值(数据类型由expr计算结果决定)。<br>　　软件模式的检测点作用有限，只能当前单个线程能侦测其变化，虽然该值也可能会被其他线程修改。<br>　　watch命令还存在两个变体：rwatch当expr被程序读的时候触发中断；awatch会在程序读取或者写入expr的时候被中断。watchpoint支持软件模式和硬件模式的检测点，后者效率会比前者高很多，因为如果不支持硬件模式gdb会每次step并计算检测的表达式，x86构架支持硬件模式。rwatch和awatch只支持硬件模式的检测点。<br>　　<strong>info watchpoints</strong><br>　　查看检测点信息，和短线信息输出格式类似。<br>　　当检测点旧监测的变量或者表达式超过了其作用域的时候，gdb会自动删除失效的观测点，所以当跳出变量的作用域后又进入的话，需要重新创建检测点。尤其当调试程序重启的时候，所有局部变量的观测点都会消失，只有全局变量的检测点会保留。</p>
<h3 id="2-1-3_捕获点">2.1.3 捕获点</h3><p>　　可以让gdb在某些事件发生的时候暂停执行，比如C++异常、加载动态链接库以及某些系统调用的时候，其格式为<code bash="">catch event</code>，还有一个变体<code bash="">tcatch event</code>设置临时捕获点，其中event的参数可以为：<br>　　<strong>throw|rethrow|catch [regex]</strong><br>　　在C++异常抛出、重新抛出、捕获的时候触发，可选使用regex参数限定特定的异常类型(在gcc-4.8开始支持)，内置变量<strong>$_exception</strong>会记录在catchpoint激活时候的异常。<br>　　当异常发生时候，程序通常会停留在libstdc++的异常支持点，此时可以通过使用up命令切换帧跳转到用于异常代码处。<br>　　<strong>syscall [name | number | group:groupname | g:groupname] …</strong><br>　　在进入和/或返回系统调用的时候触发。name可以指明catch的系统调用名(定义在/usr/include/asm/unistd.h，且gdb会帮助智能补全)，group|g:groupname可以用来指定一组类别的系统调用，比如g:network，通过智能补全可以查看支持的group信息。<br>　　<strong>exec|fork|vfork</strong><br>　　<strong>load|unload [regex]</strong><br>　　加载和卸载共享库时候触发，可选regex进行过滤。<br>　　<strong>signal [signal… | ‘all’]</strong><br>　　可以在软件收到信号的时候触发。gdb本身会占用SIGTRAP和SIGINT两个信号，如果不添加额外参数，会catch除了这两个信号之外的所有信号。<br>　　使用info break命令，watchpoint的信息会被展示出来，可以像普通断点一样管理之。</p>
<h3 id="2-1-4_断点管理(删除、禁用)">2.1.4 断点管理(删除、禁用)</h3><p>　　<strong>clear</strong><br>在最内栈中，可以用来删除正在被暂停的这个断点。<br>　　<strong>clear location</strong><br>删除指定位置处的断点，可以是func、file:func、linenum、file:linenum。<br>　　<strong>delete [breakpoints] [range…]</strong><br>参数breakpoints可用可不用，可以指明breackpoints、watchpoints、catchpoints的值或者范围来删除它们，他们的编号在同一编号空间中。<br>　　<strong>disable|enable [breakpoints] [range…]</strong><br>禁用|启用某些断点，如果没有指明范围，则是针对所有的断点。<br>　　<strong>enable [breakpoints] once range…</strong><br>临时启用某些断点，一旦这些断点激活，就会被自动disable。<br>　　<strong>enable [breakpoints] count cnt range…</strong><br>　　这种情况下临时使能的断点，会在每次被激活的时候递减cnt计数，当其值为0的时候，会禁用该断点。这个count还有一个好用的方式是和ignore相结合，可以在循环中跳过cnt个循环。<br>　　<strong>enable [breakpoints] delete range…</strong><br>　　临时启用某些断点，一旦这些断点激活，就会被自动delete，跟通过tbreak设置的断点起始状态一样。</p>
<h3 id="2-1-5_条件断点">2.1.5 条件断点</h3><p>　　当指定的cond为true的时候，断点就会被触发，其可以用于普通断点，也可以用于watchpoint(虽然值一旦改变就会触发，但是可以用cond过滤得到感兴趣的值)。条件断点可以具有side-effect，比如其可以调用函数、写入日志、执行命令等操作，副作用是可控的，除非该条件断点上又设置了别的断点，而别的断点使程序暂停此时该cond可能就没有被检查调用。<br>　　普通断点和检测点可以在命令break/watch的时候使用 if关键字指明条件，但是catch不能识别if关键字；其上所有的断点都可以在创建之后使用condition关键字指明条件来创建和删除条件：<br>　　<strong>condition bnum expr</strong>、<strong>condition bnum</strong>：<br>　　创建和删除断点的条件，在expr为true的时候断点才会被触发，后者删除条件后断点就退化成非条件断点了。<br>　　<strong>ignore bnum cnt</strong>：<br>　　让断点可以忽略cnt次后生效，如果是使用continue命令恢复程序的执行，也可以使用<code bash="">continue cnt</code>的方式代替ignore指令。如果一个断点有ignore和condition两种属性，那么在ignore到达0之前是不会检查condition条件的。</p>
<h3 id="2-1-6_断点命令列表">2.1.6 断点命令列表</h3><p>　　<strong>commands [range…]</strong><br>　　<strong>… command-list …</strong><br>　　<strong>end</strong><br>　　通过command-list的方式，可以让断点(breakpoint、watchpoint、catchpoint)在暂停的时候执行一些命令串(比如用来答应表达式或者寄存器的当前值，使能其他断点等)，如果要删除断点的命令串，可以使用commands紧邻着end就可以了。如果没有range参数，该commands默认作用于最后一个创建的断点(或者命令列表，使用rbreak等条件创建的多个断点)。<br>　　在上面说的命令列表中，在执行指定操作后，可以使用标准的命令来恢复程序的执行，比如continue、step等。可以在命令列表的开头使用silent，就不会打印当前断点的额外信息，对于变量等显示，可以使用echo、output、printf等命令来查看，同时还可以使用set命令，让给部分变量赋上正确的值，然后让程序继续执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">break</span> 31</div><div class="line">Breakpoint 4 at 0x434c62: file ./<span class="built_in">source</span>/main.cpp, line 31.</div><div class="line">(gdb) commands</div><div class="line">Type commands <span class="keyword">for</span> breakpoint(s) 4, one per line.</div><div class="line">End with a line saying just <span class="string">"end"</span>.</div><div class="line">&gt;silent</div><div class="line">&gt;<span class="built_in">printf</span> <span class="string">"origin port is %d\n"</span>, srv_port</div><div class="line">&gt;<span class="built_in">set</span> srv_port = srv_port + 100</div><div class="line">&gt;cont</div><div class="line">&gt;end</div><div class="line">(gdb) start</div><div class="line">port number is: 8911</div></pre></td></tr></table></figure></p>
<p>　　如果此时使用info b，可以查看当前断点的命令列表的详情:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(gdb) info b</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">4       breakpoint     keep y   0x0000000000434c62 <span class="keyword">in</span> main(int, char**) at ./<span class="built_in">source</span>/main.cpp:31</div><div class="line">        breakpoint already hit 1 time</div><div class="line">        silent</div><div class="line">        <span class="built_in">printf</span> <span class="string">"origin port is %d\n"</span>, srv_port</div><div class="line">        <span class="built_in">set</span> srv_port = srv_port + 100</div><div class="line">        cont</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h3 id="2-1-7_动态打印">2.1.7 动态打印</h3><p>　　上面的printf可以方便的在gdb的终端界面进行打印操作，此外gdb还允许进行打印的灵活配置，该具就是<strong>dprintf</strong>。<br>　　其通过function配置可以随意调用打印函数，而channel配置可以重定向到任何输出流，dprintf的行号可以on-the-fly的任意位置插入打印语句，其格式化输出也是和上面的printf如出一辙。GDB不会检查设置function和channel的合法性，如果非法值会在调试的过程中报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">set</span> dprintf-style call</div><div class="line">(gdb) <span class="built_in">set</span> dprintf-function fprintf</div><div class="line">(gdb) <span class="built_in">set</span> dprintf-channel stderr</div><div class="line">(gdb) dprintf 35,<span class="string">"at line 35, the srv_port is%d\n"</span>, srv_port</div><div class="line">D<span class="built_in">printf</span> 1 at 0x434<span class="built_in">cd</span>4: file ./<span class="built_in">source</span>/main.cpp, line 35.</div><div class="line">(gdb) info b</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       dprintf        keep y   0x0000000000434<span class="built_in">cd</span>4 <span class="keyword">in</span> main(int, char**) at ./<span class="built_in">source</span>/main.cpp:35</div><div class="line">        breakpoint already hit 1 time</div><div class="line">        call (void) fprintf (stdout,<span class="string">"at line 35, the srv_port is%d\n"</span>, srv_port)</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h3 id="2-1-8_断点保存">2.1.8 断点保存</h3><p>　　<strong>save breakpoints [filename]</strong><br>　　通过上面的命令，可以将所有当前的断点定义和他们的type、commands、ignore counts等信息保存到文件中去，而source命令可以读取这些保存的结果。需要注意的是，对于引用了局部变量的watchpoints很有可能无法重建，因为无法获取当时创建时候的有效上下文信息。<br>　　保存的结果是纯文本文件，其内部实际是一系列的gdb命令列表，可以方便的编译该文件，比如移除不关心的断定定义。</p>
<h2 id="2-2_继续和单步执行">2.2 继续和单步执行</h2><p>　　<strong>continue|c|fg [ignore-count]</strong><br>　　从程序最后停止的位置继续执行，且该位置上的所有断点将会被bypassed。可选的ignore-count和ignore作用相同，该参数只有在当前停止是由于断点触发的时候才有效，否则该参数将会被忽略。<br>　　如果想从别的地方继续程序的执行(而不是当前暂停的位置)，可以选用<strong>return</strong>到函数的调用位置、<strong>jump</strong>到任意位置开始恢复执行。<br>　　<strong>step|s</strong><br>　　继续执行当前的程序直到达到一个新的代码行号后，停止程序并将控制转给GDB。step只会停留在代码行的第一条指令处，如果在当前行中有调用带有调试符号的函数，那么step会继续停留，即step会进入到带符号的函数中去，否则其行为类似于<strong>next</strong>命令而不会进入到函数中去。<br>　　说到这里，需要注意的是step命令只会停留到带有调试符号的代码中，如果在没有调试符号的函数环境中使用step，那么程序会一直执行直到到达一个含有调试信息的函数；否则，需要stepi命令。<br>　　<strong>step <em>count</em></strong><br>　　持续执行count次的step，如果在这之前遇到一个断点或者和step无关的信号，step将会停止。<br>　　<strong>next|n [count]</strong><br>　　在当前(最内层)的stack frame中执行到下一个代码行，和step不同的是代码行中的函数调用将会被直接执行而不会停止。类似的，next也只会在代码行的首个指令处停止执行。<br>　　<strong>finish|fin</strong><br>　　继续执行直到当前选定的stack frame的函数返回，如果可以打印函数的返回值，简言之就是将当前函数执行完。<br>　　和这个命令对应的是<strong>return [expr]</strong>命令，该命令是取消当前函数的后续执行直接返回，并且可选返回一个表达式作为调用结果。<br>　　<strong>until|u</strong><br>　　继续执行直到在当前stack frame中到达超过当前行号的位置，这个在循环中使用的比较多，非循代码下跟next命令比较相似，而且until命令在退出当前stack frame的时候总是会停止程序的执行。需要注意的是，编译器为了效率可能会重排循环代码，有时候until的行为可能会有些诡异。<br>　　<strong>until|u <em>location</em></strong><br>　　相比不带参数的until效率会更高(采用了临时断点方式实现)，会执行程序直到特定位置或者退出当前stack frame，所以只有location是在当前stack frame内部的时候才会到达，location可以是行号、地址等任意类型的位置信息。<br>　　该until命令的另外一个好处，是可以跳过(skip over)递归函数调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span> <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</div><div class="line"><span class="number">5</span>     <span class="keyword">if</span>( value &gt; <span class="number">1</span>)</div><div class="line"><span class="number">6</span>         value *= factorial(value - <span class="number">1</span>);</div><div class="line"><span class="number">7</span>     <span class="keyword">return</span> value;</div><div class="line"><span class="number">8</span> &#125;</div></pre></td></tr></table></figure></p>
<p>　　如果当前执行点在第5行，<code bash="">until 7</code>命令会持续整个递归调用，直到value=120的时候在第7行暂停。<br>　　<strong>advanced <em>location</em></strong><br>　　和until比较类似，但是不会跳过递归调用，同时location的位置也不需要限定在当前的stack frame。<br>　　<strong>stepi/si <em>count</em></strong><br>　　执行一条(count条)机器指令，在使用这种方式调试的时候，建议使用<code bash="">display/i $pc</code>显示机器指令的汇编代码。<br>　　<strong>nexti/ni <em>count</em></strong><br>　　和上面类似，只是在遇到函数调用指令的时候不会跟踪函数调用，会直接等待函数返回。</p>
<h2 id="2-3_跳过函数和代码文件">2.3 跳过函数和代码文件</h2><p>　　有些时候调试中可能对某个函数、某个文件中的所有函数或者特定文件中的特定函数不感兴趣。<br>　　比如：<code cpp="">foo(boring());</code>如果不想调试boring()函数，方法是先step进入boring()，然后使用finish跳出该函数，再继续调试foo()函数。使用<strong>skip</strong>命令可以设置忽略某些函数的调试达到上述的效果。<br>　　<strong>skip function [linespec]</strong><br>　　执行该命令后，linespec指定的函数名或者linespec行号所在的函数将会被跳过。如果没有指定linespec，那么当前正在被调试的函数名将会被作为参数使用。<br>　　<strong>skip file [filename]</strong><br>　　执行该命令后，所有源代码在filename中实现的函数，都会在stepping的过程中被跳过。如果没有指定filename，那么当前调试焦点所在的源代码文件将作为其参数。<br>　　<strong>skip [options]</strong><br>　　是一个基本更灵活的命令(不过测试发现极大发行版的gdb不支持该模式)，通过-file|-function可以得到上面另个子命令相同的效果，而且可以任意组合使用。更强大的是使用-gfile|-rfunction的正则表达式模式，来指定符合正则表达式的文件后者函数名。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) skip -gfile utils/*.cpp</div><div class="line">(gdb) skip -rfu ^std::(allocator|basic_string)&lt;.*&gt;::~?\1 *\(</div></pre></td></tr></table></figure></p>
<p>　　如果没有任何参数，其效果类似于命令<code bash="">skip function</code>。<br>　　<strong>info skip</strong><br>　　<strong>skip enable/disable/delete [range]</strong><br>　　常规的skip管理命令。</p>
<h2 id="2-4_信号">2.4 信号</h2><p>　　信号是操作系统定义在程序中可以异步发生的事件，有些信号是程序正常执行的一部分(比如SIGALRM)，而有些信号预示着错误甚至是致命的(比如SIGSEGV)，通常会终止程序的执行。很多信号如果没有事先设置好处理handler，默认的处理方式是终止该程序的执行。<br>　　GDB可以感知程序中任何信号的发生，可以设置对特定信号的特定处理方式。正常情况下GDB是让非错误的信号(比如SIGALRM)传递到调试的程序，而让错误信号发生的时候停止程序的执行(具体可以使用info signals查看)，可以通过<strong>handle</strong>命令修改特定信号的行为。<br>　　<strong>catch signal [sig…|’all’]</strong><br>　　给对应信号设置catchpoint。<br>　　<strong>handle <em>sig</em> [keywords…]</strong><br>　　修改GDB对信号的默认处理方式，sig参数可以是SIG打头的信号名、low-high的信号值范围、’all’所有信号；keywords可以是下面的关键字<br>　　nostop、stop：当该信号发生的时候gdb是否要停止程序的执行；stop-&gt;print<br>　　print、noprint：当该信号发生的时候是否打印相关信息；noprint-&gt;nostop<br>　　pass|noignore、nopass|ignore：GDB决定是否让你的应用程序看到该信号，即应用程序消费该信号。对于非错误信号的默认模式是nostop|noprint|pass，对于错误信号的模式是stop|print|pass。<br>　　当一个信号停止了程序的执行，被调试的应用程序在continue之前是觉察不到该信号的，在GDB报告一个信号的发生的时候，可以通过handle命令的pass|nopass来设置是否传送该信号，然后继续程序的执行。<br>　　GDB对于调试中的信号处理做了<strong>一定的优化</strong>：<br>　　如果信号是nostop的，此时使用stepi/step/next进行跟踪调试的时候，将会优先执行信号处理函数，在信号处理函数返回后再执行主线调试代码，即会step over信号处理。不过信号处理函数本身也可能有断点等因素导致执行流过早的停止。<br>　　当使用了stop的时候，并且程序设置了对应信号的信号处理函数，此时程序如果因为信号暂停的话，则使用step/stepi/next将会跳入到信号处理函数中去跟踪。</p>
<h2 id="2-5_多线程程序">2.5 多线程程序</h2><p>　　在多线程程序调试中，具有两种工作模式：all-stop和non-stop。</p>
<h3 id="2-5-1_all-stop_mode">2.5.1 all-stop mode</h3><p>　　当进程中任意线程因为某种原因停止执行的时候，所有其他线程也同时被GDB停止执行。好处是程序停止的时候所有线程的状态都被保留下来了，可以切换线程查看整个程序当时的所有状态(缺点是整个业务全部阻塞暂停了)。<br>　　在默认设置下，当恢复程序执行的时候，所有的线程也都会立即执行，即使是使用step/stepi/next这种单步跟踪的模式也是如此。线程的调度是操作系统控制的，即使单步跟踪的时候很有可能其他的线程执行了更多指令后，当前线程才执行完单步指令并停止；还有可能单步跟踪后发现自己停止在了其他的线程上面，因为任何时候任何线程因为断点、信号、异常的时候都会停止程序的执行，并且GDB会自动选定切换到该线程上面去(同时会打印Switching的切换信息)。<br>　　有些操作系统支持OS调度锁定的支持，就可以修改上述GDB的默认行为。<br>　　<strong>schedule-locking</strong><br>　　off：不会锁定，所有线程可以自由运行；<br>　　on：当程序resume的时候，只有当前线程可以运行；<br>　　step：该模式是为单步模式优化的模式，当跟踪的时候阻止其他线程抢占当前线程。当step的时候其他线程无法运行，而在使用continue、until、finish类似指令的时候其他线程可以自由运行。除非其他线程运行时候触发了断点，否则GDB不会切换当前调试的线程。<br>　　<strong>schedule-multiple</strong><br>　　该设置是针对多进程情况下的调试。<br>　　off：只有当前线程所在的进程的所有线程允许恢复执行，该off为默认值。<br>　　on：所有进程的所有线程都可以执行。</p>
<h3 id="2-5-2_non-stop_mode">2.5.2 non-stop mode</h3><p>　　当进程中任意线程停止时，在跟踪检查停止线程的时候其他的线程任然继续执行，其好处就是对线上系统进行最小化的干扰入侵，整个程序还是可以继续响应外部请求的。<br>　　通过下面的设置可以开启non-stop模式，一般都是在gdb开始的时候或者连接调试目标的时候设置才会生效，且在调试过程中不能切换该模式，不是所有平台都支持non-stop模式，所以即使设置了GDB还是有可能fallback到all-stop模式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">set</span> pagination off</div><div class="line">(gdb) <span class="built_in">set</span> non-stop on</div></pre></td></tr></table></figure></p>
<p>　　non-stop模式的验证也十分的简单，在一个多线程的网络程序中先设置断点，此时发送一个请求那么处理线程会被停止，接下来删除该断点，再次发送一个请求，看该请求是否得到正常响应。如果non-stop正常开启生效的话，此时的info threads会显示其他线程都是running的状态。<br>　　non-stop模式下的命令默认都是针对当前线程的，如果要针对所有线程，通常需要使用-a参数，比如continue -a。</p>
<h3 id="2-5-3_线程相关的断点">2.5.3 线程相关的断点</h3><p>　　<strong>break <em>location</em> thread <em>thread-id</em> [if …]</strong><br>　　在多线程模式下，可以设置线程相关的断点(而不是默认针对所有线程)，其语法类似，只不过需要使用thread关键字指明GDB分配的线程标识符。当线程退出或者gdb在detach的时候，该线程相关联的断点会被自动删除。</p>
<h3 id="2-5-4_中断的系统调用">2.5.4 中断的系统调用</h3><p>　　使用GDB调试多线程程序的时候有一个副作用，就是当线程因为断点或其他因素暂停的时候，其他线程此时如果阻塞在系统调用上，此时的系统调用可能会过早的退出！因为多线程程序调试的时候线程之间需要可能会用信号等手段来通信。<br>　　对此，应当培养良好的系统调用使用习惯，多做系统调用返回值的判断。</p>
<h1 id="三、程序的执行的回放">三、程序的执行的回放</h1><p>　　GDB提供<em>process record and replay target</em>(后面简称R&amp;RT)的功能，可以记录程序的执行过程(execution log)，并在后续时间上进行正向、逆向的程序运行。在调试目标运行的时候，如果接下来的执行指令在log中存在，就会进入replay mode，该模式下不会真正的执行对应的指令，而是将事件、寄存器值、内存值直接从日志中提取出来；如果接下来的执行指令不在log中，GDB将会在record mode执行，所有的指令将会按照正常方式执行，GDB还会记录log方便将来reply。<br>　　进程的R&amp;RT支持正向和逆向执行，即使对应的平台底层调试不支持reverse exec，但是通过reply mode可能模拟这个功能，而record mode可能由于平台的限制不支持reverse exec。<br>　　<strong>record *method</strong><br>　　开启进程的R&amp;RT模式。默认的方法是使用full recording，其实际是GDB采用软件模拟的方式实现的，该模式支持replay reverse exec，不过不支持non-stop mode和异步执行模式的多线程调试。R&amp;RT只能调试正在执行的进程，所以事先需要先使用run|start命令开启调试进程，然后使用record method进行记录。<br>　　<strong>record stop</strong><br>　　停止进程的R&amp;RT，此时所有的log将会被删除，而调试进程将会被终止挥着保持在其最终状态。<br>　　如果是在record模式下(在log的最末尾)使用该命令，被调试的进程将会在下一个要被记录的指令处停止，即如果record了一段时间后停止record，那么调试进程将会保持在类似record从未发生过的状态；如果在replay模式(就是在log的某个中间位置而非末尾)下执行该命令，那么被调试的进程将会在那个点开始进行live正常调试；如果被调试进程退出，或者被detach，那么R&amp;RT将会自动停止。<br>　　<strong>record goto begin|start|end|<em>n</em></strong><br>　　跳转到指定的log位置，除了特殊的begin|start|end，其中的n是log中的instruction的标号。<br>　　<strong>record save|restore <em>filename</em></strong><br>　　log的保存和恢复。如果不指明文件名将会是默认的’gdb_record.process_id’。<br>　　<strong>set record full insn-number-max <em>limit</em>|unlimited</strong><br>　　设置log记录的指令的数目，默认值是200,000。如果设定的limit值是个正数，记录的指令数目超过这个限制后GDB会依次从最先的指令中删除这些旧指令以在不超过这个限制的条件下保存新指令记录，如果其参数值是0或者unlimited，那么久不会有保存数的限制，最终保存的多少将受内存大小的限制。<br>　　<strong>set record full stop-at-limit on|off</strong><br>　　设置在full方式下当保存指令数目超过限制的生活，如果ON(默认)，则GDB会在首次超过限制的生活停止调试进程，并向用户询问是否继续执行下去；如果是OFF，则GDB会自动进行上面删除最旧记录添加最新记录的行为。<br>　　<strong>info record</strong><br>　　显示record记录相关信息，包括当前是Record mode还是Replay mode、最小最大指令记录、当前保存的指令数目、可记录最大条目数限制值等信息。<br>　　<strong>record delete</strong><br>　　当在reply模式下执行该命令的时候，会删除当前所在所在指令之后的所有log记录，即丢失当前指令之后的所有记录，并开始新的record。</p>
<h1 id="四、栈信息检查和回溯">四、栈信息检查和回溯</h1><p>　　由函数调用的原理，一个运行的程序会有多层的stack frame，当被调试程序停止的时候GDB会默认选中当前执行的stack frame(当然后面可以手动选择在各个stack frame之间选择切换)，后续的操作都隐含针对当前选中的stack frame。</p>
<h2 id="4-1_栈结构">4.1 栈结构</h2><p>　　栈帧(stack frame)包含的是传递给函数的参数、函数中的局部变量、已经函数执行的地址(返回地址)信息。当程序最开始执行的时候，只有main函数的一个frame，称其为initial frame或者outermost frame，frame会在函数调用的时候创建并在函数返回的时候删除，当前正在执行的栈称为innermost frame，其地址由frame pointer register寄存器保存，从而可以方便的访问调用参数和局部变量。<br>　　GDB会从innermost开始upward，由0开始对frame进行编号，以方便对特定的stack frame进行引用。<br>　　某些编译器提供某种方法使得编译出来的函数没有stack frame，比如gcc的-fomit-frame-pointer选项，为了就是让那些大量调用的函数节省frame的建立时间，不过其缺点是栈回溯变得困难了。</p>
<h2 id="4-2_Backtrace">4.2 Backtrace</h2><p>　　从当前执行的frame(innermost, 0)开始，沿着其调用者upward的过程。<br>　　<strong>backtrace|bt [n|-n]</strong><br>　　如果没有参数，会打印整个stack，每一行代表一条frame；如果n表示打印innermost n的frame；如果-n表示只打印最outermost n的frame。<br>　　命令info stack是backtrace的别名。<br>　　<strong>backtrace|bt full [n|-n]</strong><br>　　参数和上面的类似，但是还会同时打印每frame的局部变量(调用参数会直接在frame的那一行显示出来)。<br>　　<br>　　在多线程程序的调试中，GDB默认只对当前选中的线程显示backtrace，如果要对其他的线程同样执行类似的跟踪，需要使用前缀的方式<code bash="">thread apply all backtrace</code>才能达到效果，尤其对于调试多线程程序的coredump十分有效。<br>　　backtrace中的函数参数、变量的值可能显示不完美，对于非标量类型的变量会用…显示，而有限变量可能会被优化掉(比如调用的过程中使用寄存器传参)，此时其值会被用’<optimized out="">‘代替。<br>　　默认栈完全回溯会跟踪到main这个outermost层次，如果需要跟踪启动代码，可以设置<code bash="">set backtrace past-main on</code>变量，不过我想一般都用不着这么个层次吧。<br>　　默认情况下backtrace是没有层次限制的(一直顶到main)，通过<code bash="">set backtrace limite n|0|unlimited</code>可以进行设置。</optimized></p>
<h2 id="4-3_选择栈的frame和查看frame">4.3 选择栈的frame和查看frame</h2><p>　　上面说过，很多命令都是隐含针对当前选定的frame操作的。因为GDB对frame都进行了编号，所以既可以用编号进行引用选择，也可以采用相对的up/down操作进行frame的切换。<br>　　<strong>frame|f n</strong><br>　　使用frame编号进行选择，0代表最innermost(当前正在执行)的栈，最大值就是main frame的编号值。<br>　　<strong>frame|f stack-addr</strong><br>　　在stack-addr处选择frame。这通常在frame因为bug被破坏了，导致GDB无法为frame进行编号的生活，以及当程序具有多个stacks并且在他们之间切换的时候。<br>　　<strong>up|down|up-silently|down-silently n</strong><br>　　相对形式的切换frame，参数n默认为1，其值也可以为正数或者负数。</p>
<p>　　<strong>frame|f</strong><br>　　该命令不会切换当前选择的帧，而是简洁的打印当前帧的一些信息。<br>　　<strong>info frame [addr]</strong><br>　　更加详细的打印当前选中frame的信息。<br>　　<strong>info args|locals</strong><br>　　前者打印当前frame的调用参数，后者显示所有可访问的局部变量(包括static或者automatic声明的)。</p>
<h1 id="五、调试与源代码文件">五、调试与源代码文件</h1><h2 id="5-1_打印源代码">5.1 打印源代码</h2><p>　　通过list命令可以显示源代码信息，默认情况下回显示10行源代码，这个设置可以通过变量listsize进行调整。list可以接受0、1、2个参数，使用起来较为的灵活。<br>　　<strong>list location</strong><br>　　该location参数可以是行号，也可以是函数名，表示以该行号为中心或者以该函数开始位置为中心，进行listsize代码行的打印。<br>　　<strong>list +|-</strong><br>　　向前|向后打印刚刚打印代码的位置。<br>　　<strong>list</strong><br>　　这个list会接着打印而不用理会之前的参数。但是+|-的参数会被保留，维持向前、向后的打印顺序。<br>　　**list [first],[last]<br>　　打印指定范围内的代码。</p>
<h2 id="5-2_指定位置信息">5.2 指定位置信息</h2><h3 id="5-2-1_行表示方法">5.2.1 行表示方法</h3><p>　　<strong>-|+offset</strong><br>　　指定位置是相对于当前行的偏移。不过针对不同的命令，current line的含义也有差异，对于list，表示的是最后一次打印的行，对于breakpoint表示的是在当前stack frame执行停止的位置。<br>　　<strong>filename:linenum</strong><br>　　在文件filename的linenum行，如果filename是相对路径名，那么它将会匹配所有的源代码文件。<br>　　<strong>function</strong><br>　　指代的是函数体的开始位置。<br>　　<strong>function:label</strong><br>　　在function中出现的label。<br>　　<strong>filename:function</strong><br>　　在文件filename中出现的函数体的开始位置，指明文件名主要是用于消除函数的二义性。<br>　　<strong>label</strong><br>　　在当前stack frame的label标签指定的位置，如果没有当前stack frame的环境(比如被调试的进程还没有运行)，则GDB不会去搜索label。</p>
<h3 id="5-2-2_显式的位置表示">5.2.2 显式的位置表示</h3><p>　　允许用户采用key=value的方式指明参数名和参数值，这种使用方法在函数、label、文件等具有相同名字的时候具有很大的区分性，同时准确的位置信息也会让GDB更快的定位目标。<br>　　<strong>-source filename</strong><br>　　通常单独的source没有意义，它是和下面的function、line等结合使用的。为了消除可能的文件名歧义，建议对于常用的文件名增加一些额外的路径前缀。<br>　　<strong>-function function</strong><br>　　<strong>-label label</strong><br>　　<strong>-line number</strong><br>　　这里的line既可以是绝对的行号，也可以是相对的(+|-3)行号位置。比如<code bash="">break -s main.c -li 3</code>。</p>
<h3 id="3-2-3_地址信息位置表示">3.2.3 地址信息位置表示</h3><p>　　通常的地址信息会使用<code bash=""><em>addr</em></code>的形式来表示。<br>　　<strong>expression</strong><br>　　<strong>funcaddr</strong><br>　　<em>*’filename’:funcaddr</em></p>
<h2 id="5-3_修改源代码">5.3 修改源代码</h2><p>　　<strong>edit</strong>命令可以修改源代码文件，其编辑的位置是在调用edit命令时候，调试程序中当前活动的那一行。可以通过给edit命令额外的参数确定位置：number 当前活动文件的行号，function 函数定义的开始位置。<br>　　EDITOR环境变量可以指定修改源代码所使用的编辑器名字，因此通过设置<code bash="">export EDITOR=vim</code>就可以完成默认编辑器的设定。<br>　　打印完是不是可以直接shell make编译啦！</p>
<h2 id="5-4_源代码和机器码的对应及反汇编">5.4 源代码和机器码的对应及反汇编</h2><p>　　通过info line可以建立源代码行号和程序地址之前的对应关系，而disassemble可以显示一段地址中机器指令。GDB还有一个变量’disassemble-next-line’，当打开他的时候会在程序停止的时候自动显示要执行的下一行源代码的第一条汇编代码，而如果下一条执行的指令没有调试信息，就会显示下一条机器指令的反汇编结果。<br>　　<strong>info line <em>location</em></strong><br>　　打印locatin代表的源代码行编译后的其实地址和结束地址。当然也可以进行反方向的隐射查询，通过地址查询其对应源代码的那一行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(gdb) info line 14</div><div class="line">Line 14 of <span class="string">"aa.cpp"</span> starts at address 0x4008d9 &lt;main(int, char**)+47&gt; and ends at 0x4008e2 &lt;main(int, char**)+56&gt;.</div><div class="line">(gdb) info line *0x4008e0</div><div class="line">Line 14 of <span class="string">"aa.cpp"</span> starts at address 0x4008d9 &lt;main(int, char**)+47&gt; and ends at 0x4008e2 &lt;main(int, char**)+56&gt;.</div></pre></td></tr></table></figure></p>
<p>　　<strong>disassemble [/m|/s|/r] [start, end]|[start, +len]</strong><br>　　<strong>disassemble [/m|/s|/r] <em>location</em></strong><br>　　可以显示一段地址范围的反汇编信息，或者函数名等其他代表的地址信息的反汇编结果，如果是跨文件的记住使用<code bash="">disassemble ‘foo.c’::bar</code>这样的形式。/m或者/s参数可以显示源代码和反汇编代码同时交叉显示的效果，/r还会以hex的方式显示机器码，当然这对一般人来说使用较少。<br>　　<strong>set disassembly-flavor intel|att</strong><br>　　反汇编是显示intel还是att的风格，个人比较偏向att的格式，这也是GDB的默认行为。</p>
<h1 id="六、查看数据">六、查看数据　　</h1><p>　　最常用的检查数据的命令就是<strong>print|p|inspect</strong>，其接受一个表达式作为参数，会根据调试的语言对表达式进行求值，并将其结果打印出来。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span> expr</div></pre></td></tr></table></figure></p>
<p>　　一种更加底层检查数据的方式是使用<strong>x</strong>命令，该命令会检查内存中特定地址的数据并通过特定的格式显示出来。<br>　　如果想知道表达式的类型而不是关系其值的话，可以使用<strong>ptype <em>expr</em></strong>命令，就可以显示出struct、class等复杂变量的类型信息。</p>
<h2 id="6-1_表达式">6.1 表达式</h2><p>　　GDB的表达式可以支持普通表达式、条件表达式、函数调用、类型转换、字符串常量、宏等类型，同时使用’{elem1, elem2, …}’这种表达式还可以创数组常量。<br>　　<strong>@</strong> 该操作符用于将一段内存当做数组使用<br>　　<strong>::</strong> 该曹组福用于指明在文件或者函数中的变量<br>　　<strong>{type} addr</strong> addr可以是一个整形或者指针，该表达式用于将指定位置的内存引用为type类型的变量。</p>
<h2 id="6-2_二义性的表达式">6.2 二义性的表达式</h2><p>　　由于重载和模板机制，在C++这类语言中二义性的表达式非常常见，在这种情况下通常需要给出函数的参数签名’function(types)’等信息才能和其他同名对象进行区分。GDB会自动探测二义性的存在，给出所有可能性的选择列表，并最终给出’&gt;’提示符信息让用户选择，固定的选项是’[0] cancel’和’[1] all’，后面的选项是各个明细，比如<code bash="">break String::after</code>这样的命令，用空格分割的选项才会打上断点。<br>　　<strong>set multiple-symbols all|ask|cancel</strong><br>　　默认参数值是all，当某个命令的表达式有多个选项的时候，GDB会自动选择所有可能的选项，但是某些环境下必须有一个选项的时候，GDB会显示出上面所述的菜单供选择；ask表示只要二义性检测到了，就会给出菜单让做出选择；cancel表示当debuger探测到二义性的时候会当做错误，相应的命令被放弃执行。</p>
<h2 id="6-3_程序变量">6.3 程序变量</h2><p>　　程序的变量算是最常被在表达式中使用的，变量是在当前选择的stack frame中可见的，他们可以是：全局变量、file-static变量、根据变成语言语法规则可见的变量。这里有一个例外，就是你可以引用file-scope的变量或者函数，即使当前执行的上下文不在该文件当中。<br>　　各个函数中的变量，以及各个文件中的函数或者变量可能会出现重名的情况，这个时候就需要’::’操作符进行指定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">file::variable  file::<span class="keyword">function</span></div><div class="line"><span class="keyword">function</span>::variable</div><div class="line">(gdb) p <span class="string">'aa.cpp'</span>::main::b</div></pre></td></tr></table></figure></p>
<p>　　在调试的时候，有时候会出现在函数进入作用域和返回的生活，某些局部变量的值是错误的，尤其是当进行机器指令单步的时候，因为很多机器上stack frame的建立(包括局部变量的定义)和函数返回的时候stack frame的销毁，都不是单个机器指令可以解决的，所以在stack frame完全建立和销毁的时候，检查到的变量值很可能是异常的。<br>　　一些没有被使用的变量也可能被编译器优化掉，这时候价差这些变量的值可以提示他们不存在。</p>
<h2 id="6-4_人工数组">6.4 人工数组</h2><p>　　通常用于需要打印内存中连续对象的时候以及变长数组的时候特别的有用，其语法结构是<code bash="">*addr@len</code>，在@的左边是目标数组的第一个元素，右边的操作数是数组的期望长度，所得到的结果是一个元素跟左操作数类型一样的数组。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *arry = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span> (<span class="keyword">int</span>));</div><div class="line">p *arry@len</div></pre></td></tr></table></figure></p>
<p>　　另外一种创建人工数组的方式是使用cast类型转换，将一个值重新使用数组去解释，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(gdb) p/x (short[4])0x123456789AL</div><div class="line"><span class="variable">$4</span> = &#123;0x789a, 0x3456, 0x12, 0x0&#125;</div><div class="line">(gdb) p/x (short[])0x123456789AL</div><div class="line"><span class="variable">$5</span> = &#123;0x789a, 0x3456, 0x12, 0x0&#125;</div></pre></td></tr></table></figure></p>
<p>　　当然如果你不设置数组的长度，而直接使用<code bash="">(type[])value</code>，那么GDB会自动计算数组的长度<code bash="">sizeof(value)/sizeof(type)</code>。<br>　　有时候人工数组也不见得方便，比如存储的元素是有规律的但是在物理上不是连续的，那么上面的方法就没法使用了，这个时候最常用的是用convenience变量，然后直接用RET依次遍历元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> <span class="variable">$i</span> = 0</div><div class="line">p dtab[<span class="variable">$i</span>++]-&gt;fv</div><div class="line">RET</div><div class="line">RET...</div></pre></td></tr></table></figure></p>
<h2 id="6-5_输出格式">6.5 输出格式</h2><p>　　print默认是根据表达式的类型自动显示的，在大多数情况下都可以工作的很好，但是在print中可以指定输出格式得到个性化得显示结果。下面的格式参数通过/和print命令相连，比如<code bash="">print/x $pc</code><br>　　x 把表达式当做一个int，并使用hex方式显示该整数<br>　　d|u 作为有符号|无符号十进制整数打印<br>　　o|t 作为八进制|二进制数打印<br>　　a 在打印地址的时候，通过最近符号加偏移的方式解析这个地址，和info symbol得到的结果类似<br>　　c 以十进制和字符的方式显示<br>　　f 以浮点数的形式打印<br>　　s 如果可以以字符串的方式显示。如果只想的目标是单字节的数据，则表示为null结尾的字符串；如果是单字节的数组，则表示为定长度的字符串；其他情况正常方式显示<br>　　z 类似x以十六进制显示数据，但是头部的字符会使用0补齐</p>
<h2 id="6-6_内存检查">6.6 内存检查</h2><p>　　通过命令’x’可以进行内存数据检查。其命名格式为(nfu是控制内存显示的大小、格式等参数信息的)<br>　　<code bash="">x /nfu addr</code><br>　　<strong>n</strong>(显示数目) 默认值是1，指明需要单位内存(u指明)显示的数目。如果n的值是负数，那么将会从addr开始进行反方向的内存显示。<br>　　<strong>f</strong>(显示格式) 显示的格式参数和上面print命令的输出格式相类似(包括：x、d、u、o、t、a、c、f、s)，初次还包括i用于机器指令的显示。默认情况下是使用x进行hex显示，该值会随着x|print命令的操作而更新。<br>　　<strong>u</strong> 显示单位尺寸 b(bytes，1字节)、h(半字，2字节)、w(字，4字节)、g(gaint字，8字节)，同样该参数会随着每次使用x被自动记住并在下次命令中自动应用。对于i显示机器指令该参数会被忽略，而对于s该参数默认是b。<br>　　由于<strong>f</strong>和<strong>u</strong>两个格式参数的空间是不重叠的，所以可以以任意顺序显示，但是n必须在他俩之前。<br>　　<strong><em>addr</em></strong> 指定需要检查的起始地址位置，比如函数名等，其最终会被解析成一个整形的地址值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) x/20i main</div><div class="line">(gdb) x/4xw <span class="variable">$sp</span></div></pre></td></tr></table></figure></p>
<h2 id="6-7_自动显示">6.7 自动显示</h2><p>　　对于需要经常查看的表达式，可以使用display命令将其添加到自动显示列表中，这样每次程序停止执行的时候，就会自动显示该表达式的值，加入的表达式会自动产生一个递增的整形编号。display也可以使用print|x命令的参数进行格式化输出控制，而且其内部如果发现格式化参数包含i|s或者数字，就会调用x；否则会调用print进行输出。<br>　　<strong>display[/fmt] expr</strong><br>　　<strong>display/fmt addr</strong> 使用’i’、’s’格式，或者指定了数字<br>　　将表达式或者要检查的内存地址添加到自动显示列表中去。<br>　　比如想要自动显示下一条要执行的指令，可以做如下添加：<code bash="">display/i $pc</code>。<br>　　<strong>undisplay dnums…</strong><br>　　将对应编号的表达式或者内存从自动显示列表中删除。列表可以使用逗号’,’进行分割，以及使用2-4这种范围表示。<br>　　<strong>info display</strong><br>　　<strong>enable|disable display dnums…</strong><br>　　查看、禁用或者使能自动显示。<br>　　<strong>display</strong><br>　　进行自动显示列表中表达式值的显示，就像程序刚停止时候自动显示的效果相同。<br>　　如果添加自动显示的表达式引用到了局部变量，GDB会自动考虑其上下文信息，如果执行的上下文中该局部变量没有定义则不会显示其值，而如果下次再次进入定义该变量的上下文，则该表达式变得有意义会再次显示其值。无论如何，info display总会显示该表达式的相关信息。</p>
<h2 id="6-8_数值历史(Value_History)">6.8 数值历史(Value History)</h2><p>　　通过使用print命令显示的值会被自动保存在GDB的数值历史当中，该值会一直被保留直到符号表被重新读取或者放弃的时候(比如使用file或symbol-file)，此时所有的值历史将会被丢弃。在使用print打印值的时候，会将值编以整形的历史编号，然后可以使用<strong>$num</strong>的方式方便的引用，单个的<strong>$</strong>表示最近的数值历史，而<strong>$$</strong>表示第二新的数值历史，<strong>$$n</strong>表示倒数第n新的数值历史(所以可以推断<code bash="">$$0==$; $$1==$$;</code>)。<br>　　比如刚刚打印了一个指向结构体的指针，那么<code bash="">print <em>$</em></code>就可以显示结构体的信息，而命令<code bash="">print $.nex</code>甚至可以显示结构体中的某些字段。</p>
<h2 id="6-9_Convenience变量">6.9 Convenience变量</h2><p>　　GDB允许自由创建便捷变量用于保存值，后续可以方便的引用该值，该类型的变量由GDB管理而与正在调试的程序没有直接的关联。便捷变量也是使用符号<strong>$</strong>打头的，可以使用任意名字(除了GDB使用的寄存器名)。<br>　　在任意时候使用一个便捷变量都会创建他，如果没有提供初始化值那么该变量就是void，直到给其进行赋值操作为止。便捷变量没有固定的类型，可以为普通变量、数组、结构体等，而且其类型可以在赋值过程中改变(为当前值的类型)。<br>　　<strong>show convenience|conv</strong><br>　　显示道目前所有的便捷变量和便捷函数，以及其值。<br>　　<strong>init-if-undefined $variable = expr</strong><br>　　如果该变量还没有被创建或初始化，则创建这个变量。如果该变量已经被创建了，则不会创建和初始化该变量，并且expr表达式也不会被求值，所以这种情况下也不会有expr的副作用发生。<br>　　便捷变量的一种经典用法，就是之前提到的连续查看变量时候用于计数作用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> <span class="variable">$i</span> = 0</div><div class="line"><span class="built_in">print</span> bar[<span class="variable">$i</span>++]-&gt;contents</div></pre></td></tr></table></figure></p>
<p>　　下面的一些便捷变量是GDB自动创建的：<br>　　<strong>$_exitcode</strong><br>　　当调试程序终止的时候，GDB将会根据程序的退出值自动设置该变量，并且将<strong>$_exitsignal</strong>变量设置为void。<br>　　<strong>$_exitsignal</strong><br>　　当调试中的程序因为一个未捕获信号而终止，此时GDB会自动将变量<strong>$_exitsignal</strong>设置为该信号，同时重置变量<strong>$_exitcode</strong>为void。</p>
<h2 id="6-10_Convenience函数">6.10 Convenience函数</h2><p>　　便捷函数和便捷变量一样使用<strong>$</strong>打头引用，其可以像一个普通函数一样在表达式中使用，便捷函数只被GDB内部使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">print</span> <span class="variable">$_isvoid</span> (<span class="variable">$_exitsignal</span>)</div></pre></td></tr></table></figure></p>
<p>　　<strong>$_isvoid (expr)</strong><br>　　如果expr是void则返回1，否则返回0。<br>　　GDB还有很多的便捷函数支持，但是需要在编译GDB的时候提供Python的支持才可以使用。下面的这些函数意义显而易见，就不在啰嗦了。<br>　　<strong>$_memeq</strong>(buf1, buf2, length); <strong>$_regex</strong>(str, regex); <strong>$_streq</strong>(str1, str2); <strong>$_strlen</strong>(str)</p>
<h2 id="6-11_寄存器">6.11 寄存器</h2><p>GDB可以像普通变量一样引用机器的寄存器值，通过<strong>$</strong>打头。<br>　　<strong>info registers</strong><br>　　<strong>info all-registers</strong><br>显示机器所有寄存器的名字和其当前值信息。后者比前者会多出浮点寄存器和向量寄存器。</p>
<h2 id="6-12_操作系统信息">6.12 操作系统信息</h2><p>通过直接的info os可以显示出GDB支持的操作系统信息类别。<br>　　<strong>info os infotype</strong><br>　　files 列出目标上面打开的文件信息。<br>　　modules 列出目标上加载的内核模块信息。<br>　　msg 列出目标上所有的Sys V消息队列信息。<br>　　processes 列出目标上所有的进程信息。<br>　　semaphores 列出目标上所有Sys V信号量信息。<br>　　shm 列出目标上所有Sys V共享内存信息。<br>　　sockets 列出目标上所有Internet-domain socket信息。<br>　　threads 列出目标上所有线程信息。</p>
<h2 id="6-13_内存和文件拷贝">6.13 内存和文件拷贝</h2><p>　　通过dump、append、restore命令可以在目标机之间传递数据和内存信息。dump命令和append命令将数据写入(追加)到文件中，而restore会读取文件内容并将其加载到调试进程的指定内存位置中。GDB默认使用binary的文件格式，推荐使用该格式。<br>　　<strong>dump|append memory <em>filename</em> <em>start_addr</em> <em>end_addr</em></strong><br>　　<strong>dump|append value <em>filename</em> <em>expr</em></strong><br>　　<strong>restore <em>filename</em> binary <em>bias</em> <em>start</em> <em>end</em></strong><br>　　其中一个比较重要的参数是bias，如果其值为非0，那么这个值将会作为偏移添加到文件中所有地址值上面。因为二进制文件总是从地址0开始，所以在恢复的时候需要添加这个偏移值。</p>
<h2 id="6-14_产生core文件">6.14 产生core文件</h2><p>　　core文件是运行进程的内存镜像和运行状态信息(比如寄存器等)的集合。通过配置，操作系统可以在程序挂掉的时候自动产生coredump文件，而在GDB调试的时候，也支持使用命令方式手动创建coredump文件，这样就可以快速创建一个程序在当时的快照。<br>　　<strong>generate-core-file|gcore [file]</strong><br>　　如果没有提供名字，那么默认将产生core.pid文件名格式的dump文件。</p>
<h2 id="6-15_内存查找">6.15 内存查找</h2><p>　　使用命令find可以对内存进行序列字节的查找操作。<br>　　<strong>find [/sn] start_addr, +len, val1 [, val2, …]</strong><br>　　<strong>find [/sn] start_addr, end_addr, val1 [, val2, …]</strong><br>　　该命令会在内存中搜索var1、var2…字符序，其范围从start_addr开始，以结束地址或者长度结束。<br>　　参数s表示搜索的大小，可以是b、h、w、g(跟之前的x命令一样)，如果该参数没有指定，GDB会考虑当前调试程序的语言环境确定，比如0x43这种整数就默认为w(4字节)类型；n表示打印最大搜索命中数量，默认行为是全部打印。该命令还可以搜索字符串，字符串使用双引号括住。<br>　　对于查找结果，命中数目保存在变量<strong>$numfound</strong>中，而最后一个值命令的地址保存在<strong>$_</strong>中。</p>
<h1 id="七、跟踪点(Tracepoint)">七、跟踪点(Tracepoint)</h1><p>　　有些情况不适合把线上的业务停下来，进行长时间的跟踪和调试；还有些行为只有在线上实时运行的环境才能重现，延时或者线下环境无法复现的问题，针对这种类型的情况，需要不打断程序的运行去观察程序的行为。<br>　　通过GDB的<strong>trace</strong>和<strong>collect</strong>命令，可以在程序中设置跟踪点，然后在跟踪点到达(命中hit)的时候计算事先构造的表达式的值；接下来，通过<strong>tfind</strong>命令，可以检查这些跟踪点中表达式在当时所记录下来的值。当前跟踪点的功能值在remote target的情况下支持，该功能是在remote stub中实现的，但是当前情况下的GDB还没有实现，目前主要使用的方式是使用文件的方式操作。</p>
<h2 id="7-1_设置跟踪点">7.1 设置跟踪点</h2><p>　　跟踪点实际上是一种特殊的断点，所以可以使用任何标准断点的命令来操作跟踪点，和断点不同的是不支持ignore count、不支持针对特定于线程的跟踪点。对于每一个跟踪点，可以事先指明到达的时候所需要搜集的数据，包括寄存器、局部变量和全局变量，之后可以使用GDB的命令来检查这些在当时收集到的数据值。<br>　　跟踪点是动态跟踪工具，意味着这些跟踪点可以被插入在目标的任何位置。<br>　　静态跟踪点暂且不表。</p>
<h3 id="7-1-1_创建和删除跟踪点">7.1.1 创建和删除跟踪点</h3><p>　　<strong>trace location</strong><br>　　**其中的location可以是和break命令参数一样的任意有效位置，通过trace命令可以创建一个跟踪点，当debuger遇到的时候会暂停，收集完相应地数据后继续执行。GDB还支持pending tracepoint，类似于断点的原理，表示在一些共享库还没有加载的时候地址无法解析。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">trace foo.c:121 trace *0x12322 trace +2</div><div class="line">trace my_<span class="keyword">function</span> //函数的第一行</div><div class="line">trace *my_<span class="keyword">function</span> //函数的准确起始地址</div></pre></td></tr></table></figure></p>
<p>　　<strong>trace location if <em>cond</em><br>　　带有条件的，只有当cond取值为true(非零)的时候，才会进行数据的收集，避免每次到达跟踪点都收集数据导致数据量暴增，而往往很多情况下的数据是没有价值的。<br>　　条件跟踪点既可以在创建的时候使用if进行限定，也可以后续使用类似breakpoint情况下的condition命令进行设定修改。和断点不同的是，GDB不会自己去对条件表达式进行取值，而是将该表达式编码给agent(独立于GDB)。
　　</strong>delete tracepoint [num]<strong><br>　　永久性地删除一个或者所有(不带参数)的跟踪点。
　　</strong>disable|enable tracepoint [num]<strong><br>　　禁用|使能某个或者所有的跟踪点。
　　</strong>info tracepoints [num…]**<br>　　显示某个或者全部跟踪点的信息，使用方法和info breakpoints相同。</p>
<h3 id="7-1-2_跟踪点计数">7.1.2 跟踪点计数</h3><p>　　<strong>passcount [n [num]]</strong><br>　　passcount是一种自动停止trace experiment的方式，当tracepoint被命中n次之后trace experiment会自动停止。<br>　　当使用passcount带有n但是不带num参数的时候，n将会作用于最近添加的跟踪点。如果不适用passcount进行设定，默认行为跟踪点将会一直运行直到被用户显式地停止。</p>
<h3 id="7-1-3_跟踪状态变量">7.1.3 跟踪状态变量</h3><p>　　trace state variable是一种特殊类型的变量，它是在target-side创建和管理的(但是对GDB可见)，和GDB的convenience变量语法相同，必须采用tvariable命令显式创建，并且总是64位的整形。<br>　　虽然trace state variable是被target端管理的，但是可以在GDB中像使用convenience variable一样使用它们，GDB会在trace experiment运行的时候从target端获取该变量的当前值。该变量也是使用符号<strong>$</strong>打头的，和GDB其他变量在同一个名字空间中，所以需要注意不能重名。<br>　　<strong>tvariable $name [ = expr]</strong><br>　　创建名为<strong>$name</strong>的trace state variable，并且可选地给其一个初始值。初始值得表达式expr是在该变量创建的时候就进行取值的，得到的结果将会转换成64位整形类型。后续再使用tvariable接上已经存在的变量名的时候，实际不会进行创建操作，而是将之前的变量进行重新赋值。如果没有提供初始值，默认初始值是0。<br>　　<strong>info tvariable
　　</strong>delete tvariable [ $name … ]**<br>　　如果没有提供额外参数，将会删除所有的变量。</p>
<h3 id="7-1-4_跟踪点行为列表">7.1.4 跟踪点行为列表</h3><p>　　<strong>actions [num]</strong><br>　　用于指明在跟踪点被命中的时候所需要执行的操作，如果没有提供num参数，那么该设置默认针对于最新创建的跟踪点。<br>　　这些行为列表中的命令一行一个，通过单个end标示着结束，当前所支持的行为包括collect、teval和while-stepping，其实使用起来跟command命令十分的类似，只不过其命令的内容只能是上面允许的，而不能是其他的GDB调试命令。要想删除跟踪点的actions，则提供空的end就可以了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(gdb) trace sum</div><div class="line">Tracepoint 1 at 0x4008a4: file aa.cpp, line 5.</div><div class="line">(gdb) actions</div><div class="line">Enter actions <span class="keyword">for</span> tracepoint 1, one per line.</div><div class="line">End with a line saying just <span class="string">"end"</span>.</div><div class="line">&gt;collect a, b</div><div class="line">&gt;collect <span class="variable">$regs</span></div><div class="line">&gt;<span class="keyword">while</span>-stepping 4  <span class="comment">#single step 4 times, collect data</span></div><div class="line"> &gt;collect c</div><div class="line"> &gt;end</div><div class="line">&gt;end</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>　　<strong>collect [/mods] expr1, expr2, …</strong><br>　　收集用逗号分隔的各个表达式的值。收集的对象除了全局变量、静态变量、局部变量，还可以包含：<br>　　<strong>$regs</strong> 所有的寄存器<br>　　<strong>$args</strong> 函数的所有调用参数<br>　　<strong>$locals</strong> 所有局部变量<br>　　<strong>$_ret</strong> 函数的返回地址<br>　　<strong>teval expr1, expr2, …</strong><br>　　当跟踪点被命中的生活，计算表达式的值，该命令接收使用逗号风格的多个表达式。取值表达式的结果将会被丢弃，所以该命令的主要用处是在不添加这些值在trace buffer的同时，将表达式计算并赋值给trace state variable。<br>　　<strong>while-stepping n</strong><br>　　在跟踪点之后进行n步的单步调试，并且在每次单步执行后进行数据的搜集，需要收集的数据在while-stepping后使用collect表示，并使用end结尾。<br>　　<strong>set default-collect expr1, expr2</strong><br>　　该变量可以是使用逗号分隔的一大串表达式表明默认需要收集的值，表明在每个跟踪点默认都要搜集的数据。注意的是这个表达式是在每个跟踪点独立解析的，所以相同的表达式、名字在各个跟踪点可能被解析为不同对象。</p>
<h3 id="7-1-5_开始和停止跟踪执行">7.1.5 开始和停止跟踪执行</h3><p>　　<strong>tstart</strong><br>　　该命令启动trace experiment并且开始搜集数据，该命令的副作用是丢弃所有在trace buffer中的已经存在的历史数据。如果给该命令提供了参数，他们将会被视为note并被存储起来。<br>　　<strong>tstop</strong><br>　　该命令会停止trace experiment，如果<strong>某个跟踪点</strong>已经达到其passcount，或者trace buffer的缓冲区已经满了，那么trace experiment会自动停止。如果给该命令提供了参数，他们将会被视为note并被存储起来。<br>　　<strong>tstatus</strong><br>　　用于显示跟踪和收集到的数据信息。</p>
<h3 id="7-1-6_Tracepoints的限制">7.1.6 Tracepoints的限制</h3><p>　　因为收集数据的行为是在target自动进行的，所以GDB无法做出细致的控制，而且后续检查数据的时候也仅基于已经收集到的历史数据。<br>　　(1) 因为跟踪点的首要目标是收集作值，所以GDB的复杂表达式往往是不可用的。在收集的过程中不能调用函数、进行类型转换、访问convenience变量、修改变量值等操作。</p>
<h2 id="7-2_使用跟踪记录的数据调试">7.2 使用跟踪记录的数据调试</h2><p>　　当trace experiment结束后，可以使用GDB命令来查看已经收集到的数据，这些收集的数据都是每次命令跟踪点收集到数据的快照。所有GDB的命令(比如print、info registors、backtrace等)的请求，都会像当时跟踪点命中时候的状态值进行对应返回，而请求那些没有收集到的数据将会失败。</p>
<h2 id="7-2-1_tfind">7.2.1 tfind</h2><p>　　通过使用命令<strong>tfind <em>n</em></strong>可以查看缓冲区中第n个快照，缓冲区中的快照都是从0开始编号的，如果tfind你没有接参数，将会依次访问下一个快照。<br> 　　<strong>tfind start</strong><br> 　　<strong>tfind none|stop</strong><br> 　　<strong>tfind -</strong><br> 　　<strong>tfind tracepoint num</strong><br> 　　<strong>tfind pc addr</strong><br> 　　<strong>tfind line [file:]n</strong></p>
<h2 id="7-2-2_tdump">7.2.2 tdump</h2><p>　　该命令不接受任何参数，其用于打印当前trace snapshot所收集到的所有数据。tdump通过扫描跟踪点的当前收集行为，然后按照其行为打印对应每个表达式的值。</p>
<h2 id="7-3_使用Trace_Files">7.3 使用Trace Files</h2><p>　　可以将线上收集到的数据保存到文件当中，后续可以通过target tfile进行加载，就像使用原始的trace数据一样访问。<br>　　<strong>tsave [-r] filename</strong><br>　　默认的情况下该命令保存在host的文件系统中，所以GDB将会从target上面拷贝对应的数据到本地保存。如果target支持的话，可以通过’-r’参数，直接将数据保存在target的文件系统上面，这样在收集到的数据量很大的时候会更加的高效。<br>　　<strong>target tfile filename</strong><br>　　加载tfile数据，使后面可以感觉和target在线访问的效果，只不过只能访问历史数据而不能进行任何新的trace experiment。</p>
<h1 id="八、GDB对编程语言的支持">八、GDB对编程语言的支持</h1><h2 id="8-1_GDB对C/C++语言的支持">8.1 GDB对C/C++语言的支持</h2><h3 id="8-1-1_GDB对C/C++语言的支持">8.1.1 GDB对C/C++语言的支持</h3><p>　　因为总所周知的原因，GCC和GDB对C/C++的支持一直很不错，包括在gdb命令行中的表达式、操作符的使用就可见一斑了。C++要比C复杂的多，所以下面罗列了一些GDB和C++调试的一些东西。<br>　　C++成员函数的调用是支持的，形如:<code cpp="">count = aml-&gt;GetOriginal(x, y);</code>；<br>　　当成员函数正在被调试(作为选中的stack frame)的时候，调试的表达式具有和成员函数一样的名字空间；<br>　　在某种程度上支持C++重载函数的调用，GDB会进行解析并指向正确的函数调用。但是限制是：GDB不支持用户定义类型转换所支撑的函数重载，以及调用不纯在的构造函数，没有对应类型实例化的模板函数，也不能处理省略的和默认的函数参数。对于数值类型转换、类型提升都是正常支持的。函数重载默认是使能的，除非使用<code bash="">set overload-resolution off</code>关闭之，然后就可以显式调用重载版本的重载函数了：<code bash="">p’foo(char,int)’(‘x’,13)，自然GDB的补全功能不会让你输的很累的。<br>　　GDB支持C++的::名字解析操作符，正如同函数代码中使用方式一样。</code></p>
<h3 id="8-1-2_针对C++的其他GDB特性">8.1.2 针对C++的其他GDB特性</h3><p>　　针对C++的重载特性，GDB可以自动补全所有的重载版本列表，方便识别和选择；<strong>rbreak <em>regex</em></strong>这种正则形式的断点，可以在所有重载版本的函数上实现添加。<br>　　<strong>catch throw|rethrow|catch</strong> 可以提供C++异常处理的监测支持。<br>　　<strong>ptype <em>typename</em></strong> 可以显示该类型的继承关系，同时其成员变量和成员函数也显示的较为详细。<br>　　<strong>info vtbl <em>expr</em></strong> 对多态机制虚函数表的支持。</p>
<h2 id="8-2_C语言预处理宏">8.2 C语言预处理宏</h2><p>　　宏本身是个比较麻烦的东西，因为可以某些点定义、某些点取消定义、某些点重新定义，GDB支持对含有宏的表达式进行展开并显示展开后结果的功能。如果要让编译后的程序具有宏调试功能，需要额外的编译参数-gdwarf-2和-g3(-g是不够的)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  gdb gcc -gdwarf-2 -g3 sample.c -o sample</div></pre></td></tr></table></figure></p>
<p>　　上面的gdwarf-2具有gdwarf-3、gdwarf-4等版本，推荐支持的情况下使用最新版本的调试格式。<br>　　<strong>macro exp|expand <em>expression</em></strong><br>　　显示expression中所有宏被展开后的结果。因为GDB只会进行宏展开而不会对表达式取值，所以这里的expression不需要是合法的表达式。<br>　　<strong>info macro [-a|-all] [–] <em>macro</em></strong><br>　　显示当前的或者全部的macro宏定义，同时显示该宏定义所在的源代码文件及其所在行号位置信息。其中的–表示参数列表结束，因为C中有些宏是可以使用-开头的，这里用于消除歧义作用。<br>　　<strong>info macros <em>location</em></strong><br>　　显示所有在location位置有效的宏定义及他们的位置信息。(显示结果有点多哦)<br>　　<strong>macro define <em>macro</em> <em>replacement-list</em></strong><br>　　<strong>macro define <em>macro</em>(<em>arglist</em>) <em>replacement-list</em></strong><br>　　自定义宏及其展开式，通过该命令创建的宏会在GDB求值的每个表达式中都会生效(只对GDB本身作用，与代码中使用的宏无关)，直到其显式使用macro undef进行删除，同时该宏还会覆盖程序中同名宏的展开(有点诡异)。<br>　　<strong>macro undef <em>macro</em></strong><br>　　只会删除上面使用macro define定义的宏，而不会删除程序代码中定义的宏。<br>　　<strong>macro list</strong><br>　　显示所有通过macro define定义的宏。<br>　　除了通常在源代码中执行宏定义，还可以在编译的时候在命令行中通过<code bash="">‘-Dname=value’</code>的方式定义，这样的宏也支持使用info macro命令查看，不过其行号信息显示为0。</p>
<h1 id="九_修改调试程序的执行">九 修改调试程序的执行</h1><p>　　例如在程序调试的过程中发现了明显的错误，想要验证修改该简单错误后程序执行会不会得到正确结果的时候，GDB的alter execution功能就会比较的好用，支持比如：修改某个寄存器、变量、内存的值，向程序发送某个信号，从不同的地方重新执行，直接跳出函数执行等操作。</p>
<h2 id="9-1_给变量重新赋值">9.1 给变量重新赋值</h2><p>　　下面都是将变量x修改为新值，区别是使用print会同时打印这个变量的值，同时还会降其放入历史记录中去。在使用set的时候还需注意，因为gdb中有很多变量也是使用set设置更新的(比如width)，此时就应该使用set variable|var而不能使用set简写了，并且使用后者总是一个好习惯，可以防止莫名其妙的修改了环境变量值而不知。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">print</span> x=8</div><div class="line">(gdb) <span class="built_in">set</span> x=8</div></pre></td></tr></table></figure></p>
<p>　　GDB中对于变量类型的转换要比C/C++语言宽松的多，比如可以把整数当做指针使用等，也可以直接将值放到指定内存位置上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">print</span> &amp;a</div><div class="line"><span class="variable">$2</span> = (int *) 0x7fffffffe1ec</div><div class="line">(gdb) <span class="built_in">set</span> &#123;int&#125;0x7fffffffe1ec = 9789</div><div class="line">(gdb) <span class="built_in">print</span> a</div><div class="line"><span class="variable">$3</span> = 9789</div></pre></td></tr></table></figure></p>
<h2 id="9-2_从不同位置恢复执行">9.2 从不同位置恢复执行</h2><p>　　默认使用continue恢复程序执行的时候，会从之前停止的位置继续执行，而使用jump命令可以指定程序恢复执行的位置。该命令很多时候是调回已经执行的代码，重新设置某些变量，然后再次执行下来。<br>　　<strong>jump|j <em>location</em></strong><br>　　在location的位置恢复执行，如果该处有断点则会立即停止，而且有时候为了达到这个效果会同tbreak组合使用。jump除了修改程序计数器之外，<strong>不会修改</strong>当前stack frame、stack pointer、内存信息和其他的寄存器信息，所以如果使用jump调到别的函数位置开始执行，那么结果将会变得十分离奇，因此如果location的地址不在当前执行函数范围内，GDB会给出信息要求确认。<br>　　将<strong>$pc</strong>直接设置新值，然后运行continue也会得到相同的效果。</p>
<h2 id="9-3_向程序发送信号">9.3 向程序发送信号</h2><p>　　<strong>signal <em>sig</em></strong><br>　　恢复程序的执行并立即给予其sig信号。如果sig为0，程序将不会收到信号并恢复执行，这常常用于程序因为收到某个信号而停下来，该信号原本会传递给应用程序的时候，通过’signal 0’可以让程序不收到该信号而继续执行。注意在多线程的环境下，当恢复执行程序的时候信号会被传送到当前选定的线程(而可能不是最后停止下来的线程)，因此如果要使用’signal 0’屏蔽信号，必须先选中对应正确的线程，否则GDB也会探测并给出确认提示。<br>　　此处的signal发送信号和命令kill发送信号是不同的，后者仍然会通过GDB根据handle觉得过滤处理，而signal会直接将信号传递给调试的应用程序。<br>　　<strong>queue-signal <em>sig</em></strong><br>　　将sig信号排队给当前线程，并在程序恢复执行的时候立即发送，要求sig的handle必须是pass的，否则GDB会报错。<br>　　sig参数还可以是0，起效果是当前线程所有排队的信号将会被清空，程序恢复执行的时候将没有信号发给该线程。该命令和上面signal不同的是signal会导致程序的恢复执行，再则queue-signal发送的信号必须是pass处理的信号。</p>
<h2 id="9-4_函数中返回">9.4 函数中返回　</h2><p>　　<strong>return [expr]</strong><br>　　该命令可以取消一个函数的执行，如果提供了expr表达式，则该表达式的值将会作为函数的返回值。<br>　　当使用了该命令，GDB会放弃当前选定的stack frame及其包含在其内部的所有stack frame，使得该函数的调用者作为最内层stack frame。return命令不会恢复程序的执行，而是使得程序的状态处于函数刚刚返回的状态，与其不同的是finish命令，会恢复函数的执行直到函数函数的正常范围时停止。</p>
<h2 id="9-5_调用程序的函数">9.5 调用程序的函数</h2><p>　　<strong>print <em>expr</em></strong><br>　　对表达式expr求值，并打印显示结果，其表达式可以包含对被调试程序中的函数的调用。<br>　　<strong>call <em>expr</em></strong><br>　　同样对表达式expr求值，但是不显示void返回函数的结果，如果调用的函数本身会返回值，那么该返回的值还是会被打印，并添加到值历史记录中去。</p>
<h1 id="十、调试目标和远程调试">十、调试目标和远程调试</h1><p>　　GDB的调试目标可以是process(进程)、exec file、core file、recording sessions，以及突破单机限制采用串口线、网络相连的remote调试目标。调试目标可以使用target命令进行设置，target+TAB可以查看当前gdb所支持的调试目标的种类。<br>　　<strong>target <em>type</em> <em>parameters</em></strong><br>　　参数<em>type</em>常见的有exec|core，这种方式也可以使用exec-file、core-file方式指定，甚至在gdb启动的时候就作为启动参数附加上去。target工具最常用的，还是在于对远程调试的支持上。远程调试，是主要在于一些运行程序的远程操作系统的限制(比如内核限制、内存限制)导致无法全功能运行gdb调试器的情况下尤为的有用，此外就是gdbsever和gdb规定了一套通信协议，而前者尺寸比后者要小的多，运行起来更轻便的同时，也容易在一个新平台上面进行快速的移植和支持。</p>
<h2 id="10-1_连接到远程调试目标">10.1 连接到远程调试目标</h2><h3 id="10-1-1_两种远程连接模式">10.1.1 两种远程连接模式</h3><p>　　GDB支持两种模式的远程调试连接：remote和extend-remote，两者基本功能相同，但是在处理出错、退出等细节性的方面差异很大。<br>　　<strong>target remote</strong><br>　　当调试的程序退出或者detach后(还比如在gdb中使用kill主动杀死正在调试的进程)，target将会断开连接，当使用了gdbserver的时候，gdbserver也会自动退出。<br>　　gdbserver的启动模式有三种：PROG、–attach、–multi，前两者是在gdbserver启动的时候指定调试的二进制程序或者要attach的调试进程，在remote模式下只能连接这两种模式的gdbserver。<br>　　不支持run命令，连接到远程后被调试程序已经运行了，此时可以使用step、continue等各项调试指令。<br>　　不支持attach命令，必须在启动的时候通过–attach参数指定。<br>　　<strong>target extend-remote</strong><br>　　当调试的程序退出或者detach后，target任然保持着和gdbserver连接(此时只有gdb退出后，gdbserver才会reopen侦听)，即使当前没有调试程序在运行。使用–once参数可以让gdbserver在第一个连接断开后退出，否则如果需要使远程的gdbserver退出，可以使用monitor exit命令。<br>　　extend-remote除了上面PROG、–attach外，还可以连接使用–multi模式启动的gdbserver，连接后在使用命令设置远程调试文件或者远程attach进程。<br>　　支持使用run命令，启动的程序是通过set remote exec-file的方式指定的。如果gdbserver启动的时候指明了调试文件，那么也不需要使用run命令了，可以类似使用step、continue等命令恢复程序执行。<br>　　支持attach命令。</p>
<h3 id="10-1-2_指明Host和Target文件">10.1.2 指明Host和Target文件</h3><p>　　具有调试符号的执行文件才可以用于调试。在远程调试模式下，允许GDB通过建立的调试连接访问远程的程序文件(remote program file access)。<br>　　我们将运行gdb的成为Host，运行gdbserver的称为Target，如果远程程序文件访问是支持的，那么允许Target调试的程序是stripped之后的(确实调试符号)，只需要Host加载的程序是带有调试符号的就可以了，除此之外还需要使用set sysroot的方式指明其他组件和库的调试信息。即使此时Host和Target的程序不一致，但是也必须保证后者是前者strip得到的，否则调试将会有异样的结果。</p>
<h3 id="10-1-3_一些远程调试相关命令">10.1.3 一些远程调试相关命令</h3><p>　　<strong>target remote|extended-remote <em>serial-device</em></strong><br>　　<strong>target remote|extended-remote <em>[tcp:]host:port</em></strong><br>　　host主机可以是主机名或者IP地址，如果host和target运行在同一台主机上，则host字段可以被省略(:占位还是需要保留)。<br>　　<strong>target remote|extended-remote <em>udp:host:port</em></strong><br>　　<strong>target remote|extended-remote | <em>command</em></strong><br>　　在后台运行command，并通过管道与之通信，command必须是shell的命令并使用/bin/sh进行解析。</p>
<p>　　<strong>detach</strong><br>　　当完成调试的时候，可以使用该命令进行对GDB控制的释放，当使用remote模式连接的时候，此时GDB可以自由连接其他的target了；而如果使用extend-remote连接的时候，此时GDB仍然处于和target连接状态。<br>　　<strong>disconnect</strong><br>　　断开和target的连接，此时GDB可以自由连接其他的target了。<br>　　<strong>monitor <em>cmd</em></strong><br>　　允许想远程发送任意命令，被远程monitor所解析。motinor exit可以让gdbserver立即退出，通常在disconnect命令之后使用，而monitor set debug|remote-debug 0|1还可以设置后续描述到的这两个调试参数。</p>
<p>　　gdb允许想远程目标上传、接收、删除文件，这对于嵌入式调试(已占用串口线)十分方便，命令如下：<br>　　<strong>remote put <em>hostfile</em> <em>targetfile</em></strong><br>　　<strong>remote get <em>targetfile</em> <em>hostfile</em></strong><br>　　<strong>remote delete <em>targetfile</em></strong></p>
<h2 id="10-2_gdbserver程序">10.2 gdbserver程序</h2><p>　　如前面所说，gdbserver运行的Target端可以是strip后没有调试符号的运行程序，而在Host端负责符号相关的支持。OPTIONS参数选项比较重要的有–debug，可以显示一些额外的调试信息，而–remote-debug会显示一些远程调试协议相关的信息，主要是gdbserver本身开始调试使用的。<br>　　<strong>gdbserver [OPTIONS] COMM PROG [ARGS …] </strong><br>　　命令中的COMM是串口设备字段或者TCP/IP的网络字段，ARGS是作为给PROG的运行参数使用。<br>　　<strong>gdbserver [OPTIONS] –attach COMM PID </strong><br>　　调试一个运行着的进程的时候，不需要指明运行的二进制程序的位置。在extended-remote模式下还允许使用attach命令进行进程指定。pid可以使用pidof工具辅助查找(有多个同名运行的进程的话会一并全部返回，使用-s可以返回单个PID)。<br>　　<strong>gdbserver [OPTIONS] –multi COMM </strong><br>　　允许gdbserver在不指定调试程序、调试进程的情况下启动，后续通过extended-remote连接后再行设定。</p>
<h1 id="十一、GDB_TUI(Text_User_Interface)调试界面">十一、GDB TUI(Text User Interface)调试界面</h1><p>　　就像之前说到的，Windows下面的程序员是幸福的，因为他们有着号称最好用的IDE——Visual Studio。其实内行看门道，到这里发现GNU GDB也是当之无愧的程序调试利器，只不过像通常Linux平台下的软件一样擅长功能而不善于表达，导致给外人看来一种很难用的“假象”。<br>　　GDB内部集成了一个TUI的用户界面，在启动GDB的时候可以使用<code bash="">gdb -tui</code>参数的方式使能，该模式是使用的curses库实现的一个建议UI界面。这个界面基本只是显示的基本功能，远远达不到IDE效果，不过它的好处是比较的易用(因为他没啥功能……)，只需要在command窗口进行常规的gdb调试，分割出来的其他窗口可以自动显示源代码、反汇编、寄存器等信息，操作要有好许多。<br>　　在Linux下面还有一个十分常用的gdb调试外壳，就是DDD，感兴趣的也可以去了解一下。</p>
<h1 id="参考">参考</h1><ul>
<li><a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_gdb.html" target="_blank" rel="external">Debugging C and C++ programs with gdb and ddd</a></li>
<li><a href="https://www.ibm.com/developerworks/library/l-gdb/" target="_blank" rel="external">Linux software debugging with GDB</a></li>
<li><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/linux_debugging.md" target="_blank" rel="external">Tips for debugging on Linux</a></li>
<li><a href="http://www.cprogramming.com/debugging/segfaults.html" target="_blank" rel="external">Debugging Segmentation Faults and Pointer Problems</a></li>
<li><a href="http://www.cprogramming.com/gdb.html" target="_blank" rel="external">A GDB Tutorial with Examples</a></li>
<li><a href="https://blogs.msdn.microsoft.com/vcblog/2015/11/18/announcing-the-vs-gdb-debugger-extension/" target="_blank" rel="external">Announcing the VS GDB Debugger extension</a></li>
<li><a href="https://book.douban.com/subject/4111413/" target="_blank" rel="external">软件调试的艺术</a></li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/201701/gnu-gdb-debug.html">GNU GDB调试手册</a></p>
        <p><span>最后更新:</span>2017-02-15, 22:52:25</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/201701/gnu-gdb-debug.html" title="GNU GDB调试手册">https://taozj.org/201701/gnu-gdb-debug.html</a>
            <span class="copy-path" data-clipboard-text="原文: https://taozj.org/201701/gnu-gdb-debug.html　　作者: taozj" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 请勿以任何形式转载文章完整正文
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/201702/little-thoughts-at-the-begin-of-2017.html">
                    2017年春节返途中的两三思考
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/201701/https-principle.html">
                    HTTPS原理简单介绍
                </a>
            </div>
        
    </nav>


  
  
     <! -- 添加捐赠图标 -->

    

    <div class ="post-donate">
      <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="Donate 打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
           
            欣赏此文？赏份狗粮！
                     
        </span>
        <br>
      </div>  
  
      <div id="donate_guide" class="donate_bar center hidden">
        
          <a href="/post_images/resources/alipay.png" title="支付宝打赏" class="fancybox" rel="article0"       style="float:left;margin-left:25%;margin-right:2px;">
          <img src="/post_images/resources/alipay.png" title="支付宝打赏" height="164px" width="164px">
          </a> 
          

      
       <a href="/post_images/resources/weixin.png" title="微信打赏" class="fancybox" rel="article0">
         <img src="/post_images/resources/weixin.png" title="微信打赏" height="164px" width="164px">
       </a>
      
    
      </div>
  
      <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
          $('#donate_board').addClass('hidden');
          $('#donate_guide').removeClass('hidden');
        }
      </script>
    </div>

    

<! -- 添加捐赠图标 -->


  
</article>





    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="201701/gnu-gdb-debug.html" data-title="GNU GDB调试手册" data-url="https://taozj.org/201701/gnu-gdb-debug.html"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"freesign"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        <!-- ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//127.0.0.1:4000/js/embed.js'; -->
        ds.src = '/js/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/201702/little-thoughts-at-the-begin-of-2017.html" title="上一篇: 2017年春节返途中的两三思考">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/201701/https-principle.html" title="下一篇: HTTPS原理简单介绍">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(5)-message-queue.html">后台开发那些常用技术再次小结（五）：消息队列</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(4)-cache.html">后台开发那些常用技术再次小结（四）：缓存部分</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/cmake-cheatsheet.html">CMake工具使用手册</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(3)-storage.html">后台开发那些常用技术再次小结（三）：存储部分</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(2)-web-service.html">后台开发那些常用技术再次小结（二）：Web服务层</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/study-note-of-scalable-backend-(1)-front.html">后台开发那些常用技术再次小结（一）：前端部分</a></li><li class="post-list-item"><a class="post-list-link" href="/201702/little-thoughts-at-the-begin-of-2017.html">2017年春节返途中的两三思考</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/gnu-gdb-debug.html">GNU GDB调试手册</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/https-principle.html">HTTPS原理简单介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/rpc-principle-and-tips.html">RPC设计和使用中的一些杂谈</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/learn-note-of-distributed-system-(6)-application.html">分布式系统入门笔记（六）：基于ZooKeeper的分布式系统的应用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/learn-note-of-distributed-system-(5)-zab-consensus.html">分布式系统入门笔记（五）：ZooKeeper之ZAB一致性协议</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/blog-collection.html">【置顶】博客资源收录大全</a></li><li class="post-list-item"><a class="post-list-link" href="/201701/linux-performance-basic.html">Linux服务器的那些性能参数指标</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/cmd-tools-sed-awk.html">文本处理利器sed与awk使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/install-gentoo-root-zfs-on-macbookpro-2015-early.html">MacbookPro上基于ZFS的Gentoo双系统安装</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/learn-note-of-distributed-system-(4)-raft-consensus.html">分布式系统入门笔记（四）：Raft一致性算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/read-note-of-amazon-dynamo.html">Amazon Dynamo论文阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/consistent-hashing.html">一致性hashing的原理解析</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/nginx-load-balancing.html">基于Nginx的软件负载均衡实现解读</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/study-conclusion-stage.html">【置顶】个人阶段性学习和规划总结(技能树)</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/design-patterns-(3)-behavioral.html">设计模式整理总结（三）：行为型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/design-patterns-(2)-structural.html">设计模式整理总结（二）：结构型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/http2-spec.html">HTTP/2协议规范和特性解读</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/learn-note-of-google-grpc.html">Google gRPC框架学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201612/tcp-connection-keep-alive.html">网络开发中客户端连接保鲜机制的实现方法</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/design-patterns-(1)-creational.html">设计模式整理总结（一）：创建型模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/forkp-mulit-process-manage-framework.html">forkp多进程程序管理库的轮子</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-distributed-system-(3)-see-paxos-from-phxpaxos.html">分布式系统入门笔记（三）：从PhxPaxos中再看Paxos协议工程实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-tencent-libco-coroutine.html">腾讯libco协程库学习使用笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/libto-coroutine-library-base-on-boost-context2.html">基于Boost.Context2库的协程库轮子libto的设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-distributed-system-(2)-paxos-algorithm.html">分布式系统入门笔记（二）：Paxos算法介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/learn-note-of-distributed-system-(1)-abstraction-and-2PC-3PC.html">分布式系统入门笔记（一）：分布式系统基本概念和两三阶段提交</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/about-multi-process-thread-dev-manage.html">浅谈多进程程序的进程控制和管理方式</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/transform-work-env-to-mac-os.html">macOS新平台工作环境的设置和迁移</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/introduction-of-boost-context-and-new-coroutine-library.html">Boost.Context库简介及Boost.Coroutine协程使用方式</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(4)-sort.html">数据结构和算法（四）：主流内排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(3)-rbtree.html">数据结构和算法（三）：红黑二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(2)-avl.html">数据结构和算法（二）：AVL自平衡二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/201611/data-structure-and-algorithm-(1)-hash.html">数据结构和算法（一）：hash散列容器</a></li><li class="post-list-item"><a class="post-list-link" href="/201610/talk-about-singleton.html">说说设计模式中的单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/basics-of-boost-asio-(3)-strand.html">Boost-Asio网络开发基础知识（三）：Strand序列化执行用户回调</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/basics-of-boost-asio-(2)-overview-of-the async-framework.html">Boost.Asio网络开发基础知识（二）：异步框架总览</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/basics-of-boost-asio-(1)-read-the-docs.html">Boost.Asio网络开发基础知识（一）：读读文档</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/cpp11-atomic-and-memory-model.html">C++11标准中的Atomic原子操作和内存模型</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/lockless-in-multi-thread.html">多线程开发中无锁队列的设计和实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/talk-about-io-seperation-design.html">开发中IO分离设计的重构杂谈</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/learn-note-of-protobuf.html">Google Protobuf数据交换格式的使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/read-(linux-mulit-thread-server-develop).html">《Linux多线程服务端编程》读摘</a></li><li class="post-list-item"><a class="post-list-link" href="/201609/usage-of-boost-coroutine.html">Boost.Coroutine协程库的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/201608/feeling-of-cpp-11-and-two-ticks.html">C++11新标准阶段性学习心得及两个小轮子分享</a></li><li class="post-list-item"><a class="post-list-link" href="/201608/some-refined-and-modification-this-site.html">关于近来本站点的一些修改和设置</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/learn-note-of-boost-(1)-smart-ptr-memory-pool.html">Boost库学习笔记(一)：智能指针和内存池</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/simple-digit-recong-base-on-tesseract.html">基于Tesseract的数字识别程序</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/construct-running-close-of-tcp.html">TCP链接的建立和关闭过程</a></li><li class="post-list-item"><a class="post-list-link" href="/201607/design-and-impl-of-minicached-base-on-memcached.html">基于memcached原理实现的单机轻量级通用缓存库</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/learn-note-of-libevent-(3)-internel-impl-and-framework.html">Libevent学习笔记（三）：内部实现原理初探</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(4)-dns-proxy-support.html">基于Libevent转发的内网端口暴露（四）：添加DNS代理的功能</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/read-(the-art-of-sober-thinking).html">读《清醒思考的艺术》感</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/personalized-reading-based-on-content-recommendation-(2)-svd-impl.html">基于内容推荐的个性化阅读实现（二）：基于SVD的推荐算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(3)-ss5-proxy-support.html">基于Libevent转发的内网端口暴露（三）：添加SS5代理功能</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(2)-refined-and-improvement.html">基于Libevent转发的内网端口暴露（二）：优化重构</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/port-expose-based-on-libevent-(1)-basic-impl.html">基于Libevent转发的内网端口暴露（一）：基本实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201606/personalized-reading-based-on-content-recommendation-(1)-general-impl.html">基于内容推荐的个性化阅读实现（二）：基本实现</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/principle-of-oauth2.html">互联网OAuth 2.0开放授权原理</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/data-type-and-index-of-mysql-database.html">MySQL数据类型整理和索引介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/auto-answer-recommend-conclusion.html">答案自动推荐模块项目小结</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/learn-note-of-libevent-(2)-thread-pool-in-memcached.html">Libevent学习笔记（二）：Memcached中Libevent和线程池使用初探</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/fastcgi-support-for-http-server-libmicrohttpd.html">对libmicrohttpd添加FastCGI协议支持</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/learn-note-of-libevent-(1)-basic-usage.html">Libevent学习笔记（一）：基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/201605/usage-of-apache-lucy-fulltext-index.html">Apache Lucy的全文检索引擎的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/fulltext-search-based-on-lsi-lda.html">基于LSI/LDA的文本检索的原理和操作步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/linux-env-program-(2)-difference-select-poll-epoll.html">Linux环境开发（二）：IO复用之select/poll/epoll之原理和差异分析</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/linux-env-program-(1)-async-blocking-io-model.html">Linux环境开发（一）：同异步、阻塞的IO模型相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/oversee-of-http-based-on-libmicrohttpd.html">基于libmicrohttpd的HTTP服务器初探</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/server-prog-port-from-windows-to-linux.html">Windows服务端程序向Linux移植经验总结</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/recommend-system-algorithm.html">推荐系统常用的推荐算法</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/recommend-system-cases.html">推荐系统的典型推荐案例</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/how-to-calc-svd.html">SVD的数学计算步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/conclusion-of-machine-learning-algorithm.html">不带公式的机器学习算法整理</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/random-sampling-method.html">随机采样方法</a></li><li class="post-list-item"><a class="post-list-link" href="/201604/statistics-frequency-bayesian.html">统计学之边角料——频率派和贝叶斯派</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-spark-(3)-relative-modules.html">Spark学习手册（三）：Spark模块学习摘读</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-spark-(2)-read-official-doc.html">Spark学习手册（二）：Spark官方手册读摘</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-spark-(1)-construct-spark-hdfs.html">Spark学习手册（一）：HDFS支撑的Spark环境搭建与尝试</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/learn-note-of-pro-git.html">Pro Git速查笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/interesting-cases-of-machine-learning.html">深度学习的那些有趣案例</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/how-to-love-dog.html">我的养狗笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/one-year-old-of-my-zaizai.html">我们仔仔快要一岁啦</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/how-to-survive-from-info-ocean.html">面对越来越多的信息我们是怎么了</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/encrypt-safe-your-file-and-email-gpg.html">请善用GPG安全你的邮件和文件</a></li><li class="post-list-item"><a class="post-list-link" href="/201603/blog-site-under-https.html">我的博客用上HTTPS啦</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/learn-note-of-numpy.html">NumPy科学计算库学习记录</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/leave-tp-link-at-2015.html">2015年工作总结——离开TP之路</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/read-(i-am-in-taobao-these-ten-years).html">读《淘宝技术这十年》感</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/usage-and-optimize-of-zfs.html">终极文件系统ZFS的使用与优化技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/201602/setup-dev-env-for-pebble-smartphone.html">Pebble嵌入式开发环境搭建和开发测试样例</a></li><li class="post-list-item"><a class="post-list-link" href="/201601/read-(the-mystery-of-silicon-valley).html">读《硅谷之谜》感</a></li><li class="post-list-item"><a class="post-list-link" href="/201601/conclusion-of-machine-learning.html">机器学习中自然语言处理之总结</a></li><li class="post-list-item"><a class="post-list-link" href="/201601/gentoo-overlay-and-software-recommend.html">我的Gentoo Overlay和Linux软件推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/201510/docker-examples.html">Docker容器技术使用实例</a></li><li class="post-list-item"><a class="post-list-link" href="/201510/mail-server-based-on-postfix-dovecot.html">搭建基于Postfix和Dovecot的邮件服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/201509/rpmbuild-package-example-(2).html">RedHat系列软件打包实例（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/201509/rpmbuild-package-example-(1).html">RedHat系列RPM软件打包实例（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/201509/generate-makefile-through-autotools.html">利用autotools自动生成项目的Makefile</a></li><li class="post-list-item"><a class="post-list-link" href="/201508/keepass-pass-save.html">开源的个人密码管理器软件KeePass</a></li><li class="post-list-item"><a class="post-list-link" href="/201508/learning-and-debug-linux-kernel-under-windows.html">在Windows下通过虚拟机搭建Linux内核的学习和调试环境</a></li></ul>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2017 taozj
            </div>
            <div class="footer-right">
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">
                    <img src="/post_images/icons/icp_min.png" alt="粤ICP备17002382号-1">粤ICP备17002382号-1
                </a>
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258402767'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1258402767%26online%3D2' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>, theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a>  enhanced by Nicol <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>
<script src="/js/search.js"></script> 


    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>


   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</script>

  </div>
</body>
</html>