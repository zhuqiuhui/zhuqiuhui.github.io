<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>桃子的博客铭</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="淡泊明志，宁静致远！">
<meta property="og:type" content="website">
<meta property="og:title" content="桃子的博客铭">
<meta property="og:url" content="https://taozj.org/page/3/index.html">
<meta property="og:site_name" content="桃子的博客铭">
<meta property="og:description" content="淡泊明志，宁静致远！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="桃子的博客铭">
<meta name="twitter:description" content="淡泊明志，宁静致远！">
  
    <link rel="alternative" href="/atom.xml" title="桃子的博客铭" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
      <link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet">
  
  
      <link href="//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css" rel="stylesheet">
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/iconfont.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/clipboard.js/1.5.9/clipboard.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: true,
          fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
          scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.0.9/scrollreveal.min.js"
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
  
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">taozj</a></h1>
        </hgroup>

        
        <p class="header-subtitle">高性能、高可用服务端开发</p>
        
        <br>
        
        <p class="header-subtitle">淡泊明志，宁静致远！</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives">文章归档</a></li>
                        
                            <li><a href="https://album.taozj.org">个人相册</a></li>
                        
                            <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                        
                            <li><a href="/about">请你读我</a></li>
                        
                            <li><a href="/search.html">搜索本站</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux开发/">Linux开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/互联网/">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内核/">内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布式/">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/协议/">协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作/">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构架/">构架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/架构/">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活杂感/">生活杂感</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件/">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/运维/">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
                    </div>
                </section>
                
                
                

                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">taozj</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/post_images/resources/avatar.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">taozj</a></h1>
            </hgroup>
            
            <p class="header-subtitle">高性能、高可用服务端开发</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="https://album.taozj.org">个人相册</a></li>
                
                    <li><a href="https://wiki.taozj.org/doku.php">个人WiKi</a></li>
                
                    <li><a href="/about">请你读我</a></li>
                
                    <li><a href="/search.html">搜索本站</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/taozhijiang" title="GitHub"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/1683951363" title="新浪微博"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:dEB0YW96ai5vcmcK (base64)" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="/347714173" title="QQ"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/taozhijiang" title="Twitter"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-nginx-load-balancing" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201612/nginx-load-balancing.html" class="article-date">
      <time datetime="2016-12-13T16:08:26.000Z" itemprop="datePublished">2016-12-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201612/nginx-load-balancing.html">基于Nginx的软件负载均衡实现解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　负载均衡在服务端开发中算是一个比较重要的特性。因为Nginx除了作为常规的Web服务器外，还会被大规模的用于反向代理前端，因为Nginx的异步框架可以处理很大的并发请求，把这些并发请求hold住之后就可以分发给后台服务端(backend servers，也叫做服务池， 后面简称backend)来做复杂的计算、处理和响应，这种模式的好处是相当多的：隐藏业务主机更安全，节约了公网IP地址，并且在业务量增加的时候可以方便地扩容后台服务器。<br>　　负载均衡可以分为硬件负载均衡和软件负载均衡，前者一般是专用的软件和硬件相结合的设备，设备商会提供完整成熟的解决方案，通常也会更加昂贵。软件的复杂均衡以Nginx占据绝大多数，本文也是基于其手册做相应的学习研究的。据介绍除了Nginx，常用的基于反向代理的负载均衡软件还包括：HAProxy、Apache(mod_proxy)、Squid。<br><img src="/post_images/images/201612/ac230f42.png" alt="load-balancing"></p>
<h1 id="一、基本简介">一、基本简介</h1><p>　　负载均衡涉及到以下的基础知识。<br>　　(1) <strong>负载均衡算法</strong><br>　　a. Round Robin: 对所有的backend轮训发送请求，算是最简单的方式了，也是默认的分配方式；<br>　　b. Least Connections(least_conn): 跟踪和backend当前的活跃连接数目，最少的连接数目说明这个backend负载最轻，将请求分配给他，这种方式会考虑到配置中给每个upstream分配的weight权重信息；<br>　　c. Least Time(least_time): 请求会分配给响应最快和活跃连接数最少的backend；<br>　　d. IP Hash(ip_hash): 对请求来源IP地址计算hash值，IPv4会考虑前3个octet，IPv6会考虑所有的地址位，然后根据得到的hash值通过某种映射分配到backend；<br>　　e. Generic Hash(hash): 以用户自定义资源(比如URL)的方式计算hash值完成分配，其可选consistent关键字支持一致性hash特性；<br>　　(2) <strong>会话一致性</strong><br>　　用户(浏览器)在和服务端交互的时候，通常会在本地保存一些信息，而整个过程叫做一个会话(Session)并用唯一的Session  ID进行标识。会话的概念不仅用于购物车这种常见情况，因为HTTP协议是无状态的，所以任何需要逻辑上下文的情形都必须使用会话机制，此外HTTP客户端也会额外缓存一些数据在本地，这样就可以减少请求提高性能了。如果负载均衡可能将这个会话的请求分配到不同的后台服务端上，这肯定是不合适的，必须通过多个backend共享这些数据，效率肯定会很低下，最简单的情况是保证会话一致性——相同的会话每次请求都会被分配到同一个backend上去。<br>　　(3) <strong>后台服务端的动态配置</strong><br>　　出问题的backend要能被及时探测并剔除出分配群，而当业务增长的时候可以灵活的添加backend数目。此外当前风靡的Elastic Compute云计算服务，服务商也应当根据当前负载自动添加和减少backend主机。<br>　　(4) <strong>基于DNS的负载均衡</strong><br>　　通常现代的网络服务者一个域名会关连到多个主机，在进行DNS查询的时候，默认情况下DNS服务器会以round-robin形式以不同的顺序返回IP地址列表，因此天然将客户请求分配到不同的主机上去。不过这种方式含有固有的缺陷：DNS不会检查主机和IP地址的可访问性，所以分配给客户端的IP不确保是可用的(Google 404)；DNS的解析结果会在客户端、多个中间DNS服务器不断的缓存，所以backend的分配不会那么的理想。</p>
<h1 id="二、Nginx中的负载均衡">二、Nginx中的负载均衡</h1><p>　　Nginx中的负载均衡配置在<a href="https://www.nginx.com/resources/admin-guide/load-balancer/">手册</a>中描述的极为细致，此处就不流水帐了。对于常用的HTTP负载均衡，主要先定义一个upstream作为backend group，然后通过proxy_pass/fastcgi_pass等方式进行转发操作，其中fastcgi_pass几乎算是Nginx+PHP站点的标配了。</p>
<h3 id="2-1_会话一致性">2.1 会话一致性</h3><p>　　Nginx中的会话一致性是通过sticky开启的，会话一致性和之前的负载均衡算法之间并不冲突，只是需要在第一次分配之后，该会话的所有请求都分配到那个相同的backend上面。目前支持三种模式的会话一致性：
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201612/nginx-load-balancing.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-design-patterns-(3)-behavioral" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201612/design-patterns-(3)-behavioral.html" class="article-date">
      <time datetime="2016-12-11T13:39:41.000Z" itemprop="datePublished">2016-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201612/design-patterns-(3)-behavioral.html">设计模式整理总结（三）：行为型模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="三、行为型模式">三、行为型模式</h1><p>　　行为型模式主要包括：职责链(Chain of Responsibility)、命令(Command)、解释器(Interpreter)、迭代器(Iterator)、中介者(Mediator)、备忘录(Memento)、观察者(Observer)、状态(State)、策略(Strategy)、模板方法(Template Method)、访问者(Visitor)，行为型模式共有11种。</p>
<h2 id="3-1_职责链(Chain_of_Responsibility)模式">3.1 职责链(Chain of Responsibility)模式</h2><p>　　定义：是多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<br><img src="/post_images/images/201612/45efdf59850422593bbcfc54db35f529.png" alt="coresponse"><br>　　Handler类，引用下一个Handler，同时提供接口设置下一个Handler以实现后继链，还包括具体处理方式的抽象接口HandleRequest；ConcreteHandler处理它所负责的请求，可以访问它的后继者，即可以调用HandleRequest处理该请求，或者将请求转发给后继者。<br>　　当有多个对象可以处理同一个请求的时候，哪个对象处理该请求由运行时候自动确定。这样使得接收者和发送者都没有对方明确的信息，且链中的对象自己也不知道链的结构，职责链可以简化对象的相互链接，他们仅需保持一个指向其后继者的引用就可以了，而不需要保持其所有候选接收者的引用。</p>
<h2 id="3-2_命令(Command)模式">3.2 命令(Command)模式</h2><p>　　定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。<br><img src="/post_images/images/201612/94e0c5a6540e5ec253d38c99ee1d71c1.png" alt="command"><br>　　源于行为请求者和行为实现者如果紧密耦合的话，虽然实现简单，但是极为的僵化。命令模式可以把请求一个操作的对象和知道怎么执行一个操作的对象分割开来。实践人家建议不要为代码急于实现命令模式，即使后面需要重构，也很容易实现它，只有真正需要记录、撤销、恢复等操作的功能时，才考虑实现命令模式。<br>　　Command类抽象出一个Execute()接口；ConcreteCommand将一个接收者对象绑定于一个动作，然后调用接收者响应的操作，以实现Execute()；Client创建一个具体命令对象并设定它的接收者；Invoker要求该命令执行这个请求；Receiver知道如何实现请求对应的具体操作，就是实现Action的内容。<br>　　实例：Command模式很容易实现一个菜单Menu的功能，菜单的每一个MenuItem都是一个ConcreteCommand，当用户点击一个菜单项的时候，MenuItem调用Command规定的Execute()方法执行相应的操作。MenuItem本身并不知道他用的是哪个ConcreteMenu类，但是在创建MenuItem的时候已经通过构造函数放着请求的接收者，而Execute则可以直接调用接收者的一个或者多个操作。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201612/design-patterns-(3)-behavioral.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-design-patterns-(2)-structural" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201612/design-patterns-(2)-structural.html" class="article-date">
      <time datetime="2016-12-11T13:39:28.000Z" itemprop="datePublished">2016-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201612/design-patterns-(2)-structural.html">设计模式整理总结（二）：结构型模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <h1 id="二、结构型模式">二、结构型模式</h1><p>　　结构型模式主要包括：适配器(Adapter)、桥接(Bridge)、组合(Composite)、装饰(Decorator)、外观(Facade)、享元(Flyweight)、代理(Proxy)，总共有七种类型。</p>
<h2 id="2-1_适配器(Adapter)模式">2.1 适配器(Adapter)模式</h2><p>　　定义：将一个类的接口转换成客户希望的另外一个接口，Adaptor模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>　　类适配器模式<br><img src="/post_images/images/201612/c2c1c67522d126c478b563084b413203.png" alt="adaptor"><br>　　对象适配模式<br><img src="/post_images/images/201612/984f9b6f02bd155897b4e811c5e72645.png" alt="adaptor2"><br>　　当需要的东西就在眼前，系统的数据和行为都正确，但是接口不符合，可以使用适配器模式，目的使得原有控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望使用一些现存的类/工具，但是接口又与复用环境要求不一致的情况。其实现包括类适配器模式、对象适配模式两种：类适配器使用多重继承对一个接口与另一个借口进行匹配；对象匹配器依赖于对象组合的方式。<br>　　Target抽象出客户特定领域所期望的接口；Adaptee定义一个已存在的接口，是需要适配的接口；Adapter对前面的Adaptee接口与Target接口进行适配，如果是类适配ß方式则Adaptor派生Adaptee并实现其中的特定接口，如果是对象适配方式，则通过在内部封装一个私有的Adaptee对象，然后把源接口的调用转换为目标接口。<br>　　举例：一个现成的例子就是STL容器中，有标准的deque双端队列，而要实现stack/queue的数据结构就是通过适配器模式来实现的。</p>
<h2 id="2-2_桥接(Bridge)模式">2.2 桥接(Bridge)模式</h2><p>　　定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。<br><img src="/post_images/images/201612/a1baf46977e24c1e313dd8166b774850.png" alt="bridge"><br>　　当一个抽象可能有多个实现时候，通常采用继承来协调他们，但是这种方法不够灵活，类的继承关系是在编译的时候就定义好了，子类的实现和它的父类有非常紧密的依赖关系，很难让抽象部分和实现部分独立地进行修改和重用。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多分角度分离出来让他们独立变化。<br>　　Abstraction定义接口，并且维护着对Implementor对象的指针或者引用；RefinedAbstraction扩充由Abstraction定义的接口；在Implementor中规定实现类的接口，其接口不一定要与Abstration的接口完全一致，而且通常两者的接口完全不同，一般Implementor接口仅提供基本操作，而Abstration定义了基于这些基本操作较高层次的操作；ConcreteImplementorA,B…负责实现Implementor接口并定义它的具体实现。<br>　　具体的例子：电脑制造商和操作系统，前者设计接口installOS()，后者实现接口installOS_impl()，然后两者可以分别独立的演化，在Computer中包含对OS的一个引用就可以调用具体的installOS_impl()了。再比如抽象Window和实现WindowsImpl，前者包含后者对象的一个引用imp，那么Icon/TransientWindow的任何操作都可以调用imp-&gt;XXX()来实现了。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201612/design-patterns-(2)-structural.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-http2-spec" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201612/http2-spec.html" class="article-date">
      <time datetime="2016-12-08T23:39:09.000Z" itemprop="datePublished">2016-12-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201612/http2-spec.html">HTTP/2协议规范和特性解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　HTTP/2也算是个比较新的东西吧，虽然很多特性是基于之前的Google SPDY，但毕竟自2015年5月正式发布到现在也就一年半的时间。虽说绝大多数的主流浏览器在2015年底就基本都支持了HTTP/2协议(估计之前的SPDY“预演”功不可没)，但是对于生产环境的服务端来说可不会这么迅速就得到普及的，Apache 2.4.12通过mod_h2模块支持HTTP/2，nginx 1.9.5支持HTTP/2，所以一般服务器除非自己编译安装，要等到发行版入稳定仓库估计估计还得要个两年吧，毕竟最新的RHEL 7上的Apache还是2.4.6呢。<br>　　Google的主页已经全部部署了HTTP/2了(但是那个sffe服务器是个什么鬼？)，通过后面查看RFC发现HTTP/2具有很多优秀的特性，并且完全可以退化至HTTP/1.1，想想也是十分诱人啊。如果想在自己服务器部署Nginx支持HTTP/2的话，推举Ubuntu 16.04 LTS或许是一个不错的选择，最主要是因为<a href="https://www.nginx.com/blog/supporting-http2-google-chrome-users/">新版Google Chrome移除了NPN只支持ALPN</a>，而这依赖于openSSL 1.0.2，但是很多系统都没有更新到这个版本，而系统最重要的基础库又不能轻易升级，所以用Ubuntu 16.04 LTS是在稳定性和便捷性一个比较好的平衡点，不过如果你的服务器跑的其他非企业级发行版就另当别论了。<br>　　至于突然想到这个，是因为昨天看到gRPC/Protobuf，底层是用的HTTP/2的协议，而且一个朋友做OTT，也是使用的HTTP/2的协议传输的。虽说现实很凄惨，但是前途很光明，瞄一下RFC7540流水帐一把吧！错过了HTTP/1.x，不要再错过了HTTP/2了。<br><img src="/post_images/images/201612/1655d08c.png" alt="http2"><br>　　PS：网上流传的baidu/fex-team的中文版翻译，大家在参阅的时候需要特别注意，一方面那份文档是基于草案翻译的，和正式发布的版本还是有一些差异，二来一些翻译的质量还待商榷，只建议用来对照正式版协议辅助理解，而不可作为依赖。</p>
<h1 id="一、HTTP/1-x主要缺点和HTTP/2协议概述">一、HTTP/1.x主要缺点和HTTP/2协议概述</h1><h2 id="1-1_HTTP/1-x的主要缺陷">1.1 HTTP/1.x的主要缺陷</h2><p>　　HTTP/1.0的请求都是短连接，服务端应答之后会主动关闭掉该连接，HTTP/1.1为了减少这种频繁连接建拆支持KeepAlive长连接，但是请求和应答仍然是串行报头阻塞的，因此HTTP/1.x如果需要实现真正的并发则必须建立多个连接才可以。通常，增加HTTP/1.x的传输效率有：<br>　　(1) 通常浏览器和服务端允许建立6~8个长连接，但是这增加了服务器并发量的压力；<br>　　(2) 将资源分布到多个主机上面去，那么整体来说就可以建立更多的并发数，算是横向扩展的一种方式；<br>　　(3) 将多个图片组合成一个大的图片，然后通过CSS的方式将各个部分逻辑分割成小的图片，总体减少了请求的次数；<br>　　(4) HTTP/1.1 pipeline，允许多个请求在应答之前发送出去，不过服务端的返回必须是严格按照FIFO的顺序返回，也就是说只要其中一个请求响应时间长了也会导致后续的响应被阻塞。<br>　　HTTP/1.x是纯文本格式的协议，协议头附带很多冗余的信息，而且这种头部会被反复传输，最终会占用大量带宽，而且TCP的拥塞控制更加会恶化响应时间。</p>
<h2 id="1-2_HTTP/2概述">1.2 HTTP/2概述</h2><p>　　HTTP/2针对上面问题做出了改进，允许在单个TCP连接上面通过Stream的逻辑概念实现复用机制，在增加传输效率的同时减少了连接数(自然也降低了服务端和客户端压力)。HTTP/2通过流量控制和优先级机制，有助于只传播接受者需要使用的数据资源，并在有限的资源下建议某些资源优先被传输处理。<br>　　HTTP/2允许服务器主动推送响应给客户端，主要是基于服务端预测客户端将来会用到的资源。<br>　　传统HTTP/1.x的每个请求和应答都是Header+Body的形式传输的，HTTP/2对传输帧进行了重新设计，采用二进制进行封装和压缩，增加了传输效率和可扩展性。HTTP/2的报头(HEADERS)帧和数据(DATA)帧组成了基本的HTTP请求和响应，而设置(SETTINGS)帧、窗口更新(WINDOW_UPDATE)帧、推送承诺(PUSH_PROMISE)帧可以实现HTTP/2的其他功能。</p>
<h2 id="1-3_HTTP/2协议包的抓取">1.3 HTTP/2协议包的抓取</h2><p>　　因为HTTP/2所有流量都是加密的，虽然使用浏览器F12调试器可以查看上层的数据，尤其是一些协议相关的非数据帧是无法查看的，任何分析协议不抓包的行为都是耍流氓，但是如果直接用Wireshark得的抓包是无法查阅的。调试SSL/TLS加密数据的方法有两种：<br>　　(1). 如果针对是使用自己的网站，则可以使用你部署服务器的私钥来解密数据包；<br>　　(2). 如果是调试第三方的网站，则可以通过设置浏览器的SSLKEYLOGFILE环境变量以导出对称密钥，然后让Wireshark共享读取这个文件就可以解密浏览器回话过程中的包。<br>　　第三方的服务端和浏览器可能会有这样那样的问题，自己截取了一份Chrome访问Google的数据包，设置一下SSL中的(Pre)-Master-Secret就可以了，过滤条件使用http2，懒癌患者晚期可以直接<a href="/upload/http2_package.zip">下载</a>使用。<br><img src="/post_images/images/201612/42aa82451aaaf166f59f2fb57f1e9182.png" alt="http2-flow"></p>
<h1 id="二、HTTP/2连接的启动">二、HTTP/2连接的启动</h1><p>　　HTTP/2需要客户端感知服务端是否支持HTTP/2，而不能一开始就进行HTTP/2通信。因为HTTP通信包括http和https两种情况，虽然HTTP/2必定是加密的，但是源请求方式不同，探测HTTP/2的方式也不相同。<br>　　在http的模式下，客户端发起一个普通的HTTP/1.1请求，外加HTTP升级机制所需要的额外头部信息，即 Upgrade: h2c头。如果服务端不支持HTTP/2则忽略这个请求，按照HTTP/1.1的模式正常的返回通信，后续对话退化到HTTP/1.x协议上面；而支持HTTP/2的服务端可以返回一个101(转换协议)响应来接受升级请求，这是一个空相应，紧接着两者就可以发送HTTP/2的帧了(先前主要是SETTINGS设置帧)。<br>　　鉴于https在2017年将会大量代替http，且很多服务器都将http直接301重定向到https，所以https下的HTTP/2连接的建立比较普遍。在这种情况下需要先协商建立TLS连接，然后在TLS的应用层协议协商(ALPN)中得出支持h2协议。ALPN是TLS的一个扩展，允许客户端在TLS连接建立后协商接下来需要使用的协议类型，当客户端或者服务器端不支持ALPN时HTTP/1.1将会被使用，否则客户端会向服务器端发送自己支持的协议列表，服务器会决定接下来要选用的协议并发送响应，比如下图中选用h2代表使用HTTP/2协议。<br><img src="/post_images/images/201612/73cb3b0bac9aa53312ed78266c8bc82f.png" alt="http2-start"><br>　　当然还有比如客户端通过其他方式知道某些主机一定支持HTTP/2，或者叫做先验知识知道协议支持。<br>　　上面的任何情况下，每个端点(客户端和服务端)都需要发送一个固定的24个字节连接序言(Magic)作为HTTP/2协议的最终确认<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</div></pre></td></tr></table></figure></p>
<p>　　紧接着序言后面是一个设置帧，详细内容可以看上面的h2截图。</p>
<h1 id="三、HTTP/2_Frame帧结构">三、HTTP/2 Frame帧结构</h1><p><img src="/post_images/images/201612/5efd484de1faf2aa803318f932000426.png" alt="http2-frame"><br>　　所有的帧都是由9个字节的固定前缀打头的。Length指定了Payload长度，默认不超过2^14 (16,384)，除非设置了SETTINGS_MAX_FRAME_SIZE为更大的参数；Type指定了是前面某种帧的一种，比如SETTINGS、DATA等；Flags是一些bit的标志位；Stream Identifier用作后面的stream标识，0被保留用于表示连接相关的整体而不是一个具体的流。<br>　　关于流的长度，前面说道默认是2^14+9，任何的协议实现都必须能至少处理这个长度，通过SETTINGS_MAX_FRAME_SIZE可以最大扩展长度为2^24-1。任何接受到的帧太小而无法处理，或者操果设置值，应当返回FRAME_SIZE_ERROR。<br>　　HTTP/2的Header包含一个或者多个键值对，然后使用报头压缩序列化到header block中，然后他们会被分割成1个或多个header block fragments，并在HEADERS/PUSH_PROMISE/CONTINUATION中作为Payload部分传输。Cookie部分会被额外单独处理。如果fragment只有一份，那么只会在一个HEADERS/PUSH_PROMISE帧中传输，而且Flag的END_HEADERS会被置位，否则后面连续的PUSH_PROMISE/CONTINUATION只会在最后一个fragment处置位END_HEADERS，而且这些fragment必须作为一个连续的帧序列传输，没有任何类型或任何其他流的交错帧在中间。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议/">协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201612/http2-spec.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-google-grpc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201612/learn-note-of-google-grpc.html" class="article-date">
      <time datetime="2016-12-06T11:46:00.000Z" itemprop="datePublished">2016-12-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201612/learn-note-of-google-grpc.html">Google gRPC框架学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　其实gRPC算是比较年轻的项目，虽据说已在Google内部被大规模部署使用，但从GitHub上看是2016年8月19日打的v1.0.0的tag，而官方博客发布声明在2016年8月23日。正式发布也就意味着通信协议的确定、接口API已经稳定，而性能、压力、稳定性各项测试已经满足需求，可以部署到生产环境中，广大基佬们可以安心使用了。<br>　　与gRPC/Protobuf相对应的，莫过于当前最熟悉的传统经典HTTP/JSON模式了，传统开发的惯用手法就是：客户端发起请求、服务端接收请求、服务端解析请求、服务端进行业务逻辑处理、服务端打包响应、服务端发送响应、客户端解析响应。虽然现在的序列化库和网络开发框架漫山遍野多如牛毛，但是服务端和客户端开发还是需要不断地封装、解析数据，处理网络传输的各项细节。<br>　　RPC从本质上来说，就是通过客户端和服务器的协作，将客户端的本地调用转化成请求发送到服务端，服务端进行实际操作后，再将结果返回给客户端，所以从客户端的角度看来就和一个本地调用的效果一样，虽然实际上跨进程、跨主机的调用会遇见各种复杂的情况，但是RPC框架负责屏蔽这些细节信息，用户只需要专注于业务逻辑开发即可。从Wikipedia的资料看来，RPC的概念很早就已经被提出来，而最近风光无限的几个开源RPC框架基本都出自大厂之手，其源于在互联网环境下，大量的分布式应用或服务可以使用RPC的方式轻松解耦，增加了复用性，提高了开发效率。<br>　　此外还想罗嗦一句：gRPC/Protobuf不仅可以用于常规网络服务开发，甚至可以作为本地进程间通信方式使用，因为RPC本来就属于一种IPC手段。<br><img src="/post_images/images/201612/ba2490413b2c260f24d4a8f22e7c2cf0.jpg" alt="grpc"><br>　　gRPC和Protobuf天生有着紧密的联系，在gRPC中Protobuf不仅作为一种序列化的工具使用，而且用于定义服务端与客户端之间的RPC调用接口(IDL的效果)，然后通过protoc工具可以快速生成客户端和服务端的代码。gRPC允许通过Protobuf的插件，独立指定客户端和服务端生成的语言类型，这对于时下移动互联网时代的开发意义重大。Protobuf是一种重要的序列化工具，其编码效率和速率非常的高，而且在工程化的过程中Google考虑到前向兼容等各项事宜，简单的手册可以参见之前的<a href="/201609/learn-note-of-protobuf.html">《Protobuf数据交换格式的使用方法》</a>。无论以后用哪家的RPC，都建议好好学习熟练掌握它，因为当前一些新开源的框架库基本都默认用它作为数据交互格式。</p>
<p>　　下面借着gRPC官方的手册，流水帐般地过一下gRPC的相关东西。</p>
<h1 id="一、RPC生命周期">一、RPC生命周期</h1><p>　　gRPC支持四种服务类型：Unary RPCs、Server streaming RPCs、Client streaming RPCs和Bidirectional streaming RPCs，通过参数和返回类型是否有stream关键字来标识区分。最简单的是Unary RPC调用，客户端发送一个请求参数，服务端做出一个应答数据；Server stream RPC调用是服务端可以返回多个数据，客户端一般在while中一直读取结束；Client stream是客户端可以向服务端传输多个请求，告知服务端传输结束后等待服务端返回；而Bidirectional stream则是一个全双工的通信，两端可以在任意时刻发送和接收数据，互相独立互不干扰。<br>　　gRPC允许client提供额外的超时参数，在超时之后如果服务端还没有返回响应的话，则会返回DEADLINE_EXCEEDED错误。服务端可以查询请求的超时参数，以及该调用所剩余的完成时间值。
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201612/learn-note-of-google-grpc.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-tcp-connection-keep-alive" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201612/tcp-connection-keep-alive.html" class="article-date">
      <time datetime="2016-12-05T14:41:19.000Z" itemprop="datePublished">2016-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201612/tcp-connection-keep-alive.html">网络开发中客户端连接保鲜机制的实现方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　网络开发中的TCP连接分为长连接模式和短连接的模式，短连接就是在服务端接收到客户端请求，完成处理和应答后会主动关闭这个连接，而长连接顾名思义就是这个连接会一直存在着。一般来说，短链接的程序更容易编写和维护，因为一旦收到断开消息表明当前请求结束了，新的请求也会重新发起新的连接，而长连接需要处理拆包，粘包，错误累计飘移等各种复杂的问题。不过有得必有失，短链接最主要的问题是性能问题，每个请求都需要做三次握手和四次拆链操作，那么相同客户端和服务端交互的效率会因此大大的降低，尤其在网络连接慢的链路上会严重影响页面的加载速度。在后台局域网之中的主机高效通信，通常采用长连接的方式进行。<br>　　现在的网页做的是越来越复杂了，基本一个页面的渲染需要做到几十甚至上百次的请求才完成。HTTP协议中定义了Keep-Alive字段就是为此而定义的，现代的浏览器通常都会开6-8个长连接请求，而Apache和Nginx也可以打开配置选项支持这个特性。</p>
<h1 id="一、连接保活的原理和影响">一、连接保活的原理和影响</h1><h2 id="1-1_HTTP和TCP的KeepAlive">1.1 HTTP和TCP的KeepAlive</h2><p>　　除了HTTP协议中的Keep-Alive选项外，TCP中也有SO_KEEPALIVE这个选项。虽然名字类似，但是毕竟属于不同的网络层，所以他们之间是没有什么直接关系的。<br>　　HTTP协议中的Keep-Alive主要是在应用层实现对一个长连接的管理方式，其不需要周期性的检测这个连接是否可用，而是在每次服务端发送响应后重启一个time span的定时器，当定时器到点就表明这个time span没有数据交互，那么服务端就会主动关闭掉这个连接。TCP中的SO_KEEPALIVE是TCP协议支持的，其会在规定的时间内发送0负载的探测包给对端，正常情况下对端会返回ACK进行确定，以此探测TCP连接是否正常，在实际中这个选项可以用以：探测对端主机/服务是否活着；探测两者之间的网络连接是否正常。<br><img src="/post_images/images/201612/b77a07126d2c75f42a3920afe7c13cef.png" alt="keepalive"></p>
<h2 id="1-2_HTTP_KeepAlive对服务器的性能影响">1.2 HTTP KeepAlive对服务器的性能影响</h2><p>　　这段的内容在Nginx的手册中描述的十分清楚。因为HTTP KeepAlive的本质是一定时间内的长连接，所以这会大大降低服务端的并发量，而相比于Nginx基于事件驱动的服务端可以胜任大量的并发连接之外，Apache这种Prefork以及线程/线程池等传统型服务端模型会因为进程、线程的昂贵开销，并发量一般也就限制在几百的范围之内，一旦并发连接被KeepAlive占用后，服务器将不能再接受处理新的请求了。更加要命的是，不怀好心的人可以慢慢探测出KeepAlive的超时时间，从而更加高效地实现服务端的DDoS攻击。<br>　　KeepAlive对服务器的影响很难在测试环境中复现出来，而在线上环境运行后上面的矛盾才会显得比较的尖锐。因为测试环境一般是局域网环境，客户端和服务端都是高速本地网络连接，这时候短连接的建立、拆除连接对整个吞吐量的连接有限；而即使使用了KeepAlive的长连接，一般来说客户端的并发数目都会在服务端之下，而且快速的网络也会导致KeepAlive被大量的重用而不会超时。而且大多数测试工具都只报告成功的transactions，有些深入的特性很难挖掘出来。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201612/tcp-connection-keep-alive.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-design-patterns-(1)-creational" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201611/design-patterns-(1)-creational.html" class="article-date">
      <time datetime="2016-11-29T11:52:28.000Z" itemprop="datePublished">2016-11-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201611/design-patterns-(1)-creational.html">设计模式整理总结（一）：创建型模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　大多抽象于特定语言的东西都比较难，设计模式便是其中之一。大家都说设计模式是前人工程实践中的经验，所以多读历史多看看前辈走过的路可以少挖点、少踩点坑，而且对设计意图熟练掌握后，对于快速阅读代码融入项目也是很有帮助的。<br>　　据说设计模式最好使用范例ACE的源代码，不过对于这个“学之者生，用之者死”(了解到的华为、腾讯例外)的著名网络库，目前还没有接触的打算。其实之前自己也总结了一份wiki，但是感觉这东西用自然语言的方式来描述反而难以讲清楚，所以这里打算用starUML工具把这些设计模式重新画一下，配上GOF的经典定义和网络上的一些典型例子，便于大家快速查阅和回忆。<br>　　UML工具觉得starUML听轻巧好用的，其v1分支版本原来是开源的，但是后来作者抱怨缺少sponsor，所以新的v2已经闭源商业版了。其实starUML可以无限期的evaluate，而且网上所谓的破解就是简单粘贴几行代码，可见作者还是很良心大度的，目的也在于防君子不防小人了，经济自由的还是适当赞助这些慷慨的码农吧！<br>　　在使用starUML的过程中，甚至不需要了解UML语言本身，图形化的操作就可以快速设计出模型。在使用starUML的时候，建议安装C++插件，可以帮助reverse分析已有代码的设计，可以将当前的设计自动生成C++代码。<br><img src="/post_images/images/201611/8e70ac935449dec9a7ff12d8d2f26fce.jpg" alt="UML"><br>　　UML中的难点，是依赖(Dependency)、继承(Generalization)、关联(Assosiciation)、聚合(Aggregation)、组合(Composition)这几种关系Relationships的理解和区分，其实粗分类来也就前三种，聚合和组合是关联关系特化一些条件的结果。<br>　　(1) <strong>Dependency</strong><br>　　体现的是一种<strong><em>using</em></strong>的类与类之间的关系，而且这种关系是单向的。这种依赖关系体现在对一个被依赖类的结构或者行为改变，会影响到依赖于它的类。<br>　　(2) <strong>Generalization</strong><br>　　体现的是一种<strong><em>is-a-kind-of</em></strong>或者<strong><em>is-a</em></strong>的关系，即常见的派生/继承关系。<br>　　(3) <strong>Assosiciation</strong><br>　　表述的是除了上面两种方式之外类与类的联系，可以是一对多、多对一、一对一、多对多的关系，而且这种关系体现没有拥有的联系。如果在设计中不能确定区分出下面的Aggregation、Composition，可以模糊地使用Assosiciation表示。<br>　　(4) <strong>Aggregation</strong><br>　　特例化的Assosiciation关系，体现的<strong><em>has-a</em></strong>的ownership关系，部分可以离开整体而单独存在。<br>　　(5) <strong>Composition</strong><br>　　特例化的Aggregation关系，部分不能离开整体而单独存在，所以是一种Strong/Dead的依赖关系。</p>
<p>　　设计模式共分为三类：创建型、结构型、设计型。一篇文章整理起来比较冗长，所以分成了三篇。<br>　　创建型模式主要包括：抽象工厂(Abstract Factory)、生成器/建造者(Builder)、工厂方法(Factory Method)、原型(Prototype)、单件(Singleton)五种类型。<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发基础/">开发基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发基础/">开发基础</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201611/design-patterns-(1)-creational.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-forkp-mulit-process-manage-framework" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201611/forkp-mulit-process-manage-framework.html" class="article-date">
      <time datetime="2016-11-27T08:37:31.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201611/forkp-mulit-process-manage-framework.html">forkp多进程程序管理库的轮子</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　是前两天写的一个小工具，主要目的是实现Linux平台下master进程对worker子进程的监控和管理，并且必要情况下自动重启worker进程以实现保活的功能，这应该算是运维人员最喜欢的东西了吧。<br>　　本人在之前的文章<a href="/201611/about-multi-process-thread-dev-manage.html">《浅谈多进程程序的控制和管理》</a>中介绍了Nginx中master process和worker process的工作原理，其实这基本也可以作为多进程程序的开发范例来使用，虽然通常情况下的业务需求不用像Nginx做的那么复杂和完整，比如支持二进制程序不停服务平滑升级等，但是master进程对子进程进行监测并异常情况下自动重启服务的功能还是比较有用的。这种情况下，本人就萌生了写一个多进程程序开发的框架的想法，以后写多进程程序就不用重头做起了。<br>　　在Linux中进程管理的基本方式基本都是通过信号来实现的，因为子进程正常或者异常退出后，会由操作系统保证向其父进程发送SIGCHLD信号，所以父进程可以通过监听SIGCHLD的方式，高效异步的获取子进程退出的通知并对应做出相应地处理。如果只想让子进程保活，那么父进程只需要自定义处理SIGCHLD信号，并进行waitpid调用释放子进程的资源，然后重启子进程就可以了。不过既然想做一个通用点的库或者框架，那么还有一些细节的地方需要注意和完善，同时增加一些便利的功能还是很实际的。<br>　　forkp的子进程以两种方式工作：Process库和Exec管理服务，在同一个forkp实例中，同时对这两种方式提供了支持。<br>　　<strong>(1) Process库</strong><br>　　这种模式实际就是将Nginx的子进程管理模块抽象出来的效果，在新开发的多进程项目中，子进程的服务以可调用对象的方式注册启动。Nginx的配置文件可以设置worker process的进程数量，但这也假设了产生的所有worker process都是同构的，但是实际上多进程的子进程有可能会是异构的，因此在设计的时候，forkp会严格完全按照启动时候调用spawnWorkers的种类和次数来监测子进程。<br>　　master进程除了接收和处理SIGCHLD信号之外，还借助看门狗的模式来监测子进程，虽然实际上我不确定这有实际的意义，比如出现worker进程还没挂掉但是已经不能正常工作了的情况，因为通常程序错误或者跑飞了都会挂掉的。master进程和worker进程之间建立了匿名管道，master进程以1sec间隔向worker进程发送SIGWINCH信号，worker进程接收到该信号后通过匿名管道发回一个字节，如果master连续错过3个回应，就会发送kill杀死该子进程。这个功能是通过子进程屏蔽SIGWINCH信号来测试的。<br>　　需要额外说明的是，这里不要期待master进程做过多业务相关的内容。通常，master进程创建了侦听套接字后，所有的worker进程也继承了这个侦听套接字，而内核可以直接将侦听套接字的连接请求自动分发到worker进程中去，如果使用forkp开发类似Nginx这类程序，就可以很容易采用这种模式来满足需求。如果要期待master进程做过多的事情，由于master进程已经集成了一个epoll异步事件框架，那么程序可能要大改，还需三思。另外一点，就是master进程如果出错，所有的子进程都会退出，让master处理过多的任务，无异于增加了单点风险。<br>　　<strong>(2) Exec管理服务</strong><br>　　这种工作模式是对于已经存在的二进制程序，此时master进程fork出worker进程后，worker进程通过execv系统调用执行新的二进制程序，这个时候我把子进程调用exec后的实体叫做 <strong>子程序</strong>。由于exec系统调用重新执行一个二进制程序，所以此时master进程和worker进程除了通常的父子进程之外没有什么其他联系了，唯一的便捷就是可以同现有的所有程序方便的集成。此时像上面看门狗的形式就不能工作了，而是通过kill不发送任何具体信号的方式，来侦测指定pid的子进程是否存在。<br>　　事先说明最好还是把程序和服务写稳定一些，这只是作为一个补救措施，不可过度依赖这种机制。还有就是，比如我的ss5服务器偶尔会挂掉，此时通过forkp调用，就会在退出后自动重启服务了。<br>　　当然，工业上有现成的zabbix等更加成熟、可靠的开源方案……<br>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/运维/">运维</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作相关/">工作相关</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务运维/">服务运维</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/造轮子/">造轮子</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201611/forkp-mulit-process-manage-framework.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-distributed-system-(3)-see-paxos-from-phxpaxos" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201611/learn-note-of-distributed-system-(3)-see-paxos-from-phxpaxos.html" class="article-date">
      <time datetime="2016-11-18T14:57:24.000Z" itemprop="datePublished">2016-11-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201611/learn-note-of-distributed-system-(3)-see-paxos-from-phxpaxos.html">分布式系统入门笔记（三）：从PhxPaxos中再看Paxos协议工程实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　Phxpaxos已经开源了，且他们号称开源和内部使用的是同一套代码，那么作为小厂的程序员可有福了，可以一睹研究一下生产环境下大规模分布式系统是怎样练成的。初看代码可能会比较犯晕，果真生产环境的实现跟<a href="http://www.inf.usi.ch/faculty/pedone/MScThesis/marco.pdf">《Paxos made code》</a>的复杂度不是一个数量级的，可是复杂归复杂，但毕竟代码中没有用到复杂的Moden C++特性、大量的模板元编程和晦涩难懂的编码技巧，所以只要功夫下到位相信还是肯定能搞明白其内部流程的。<br>　　本文就是通过Phxpaxos中所附带的简单例子，摸索了解Phxpaxos中对Paxos算法的实现，算是验证一下前面对Paxos算法的学习吧。当然之前也说过，Phxpaxos同Lamport老爷爷的原版Multi-Paxos相比已经修改了很多，毕竟老爷爷的文章比较的偏理论化，所以理论上不修改的Multi-Paxos是不可能满足线上分布式系统的可用性和可靠性需求的，具体对于遇到的修改再行另表吧。</p>
<h1 id="一、预备操作">一、预备操作</h1><p>　　默认情况下Phxpaxos的存储模块使用的是glog，但不知道怎么回事，在我MacOS下VMware Fusion虚拟机Ubuntu-1604的环境下，严格按照<a href="https://github.com/tencent-wechat/phxpaxos/wiki/%E4%B8%AD%E6%96%87%E8%AF%A6%E7%BB%86%E7%BC%96%E8%AF%91%E6%89%8B%E5%86%8C">《编译安装手册》</a>还是会报无法创建log文件的错误，不知道是不是因为目录使用NFS挂载的原因，因为在实体机上面本地存储没有发现这个问题，此处也不详究了。其实Phxpaxos的实现中，很多地方都有详细的且分好等级的日志信息，查看代码发现只要设置了pLogFunc函数指针，就可以在所有log记录之前执行这个hook函数，于是乎可以在sample中设置这个option，那么整个系统的运行路径和运行状态也就一览无余了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">custLog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iLogLevel, <span class="keyword">const</span> <span class="keyword">char</span> * pcFormat, va_list args)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> sBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    vsnprintf(sBuf, <span class="keyword">sizeof</span>(sBuf), pcFormat, args);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; sBuf &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">oOptions.pLogFunc = custLog;</div></pre></td></tr></table></figure></p>
<p>　　Phxpaxos的代码虽然是多，但是当除掉存储模块、网络模块、CheckPoint模块、Benchmark和单元测试等部分代码后，核心代码其实也是十分有限的，而且和Paxos算法相关的部分都单独放在algorithm目录中了，查看这个文件夹中的文件名，赫然醒目的acceptor、proposer、learner、instance，就让我们估计道知道他们是什么角色履行的职责了。</p>
<h1 id="二、附带phxelection选主例程解析">二、附带phxelection选主例程解析</h1><p>　　Phxpaxos附带的两个sample详细构建过程都在<a href="https://github.com/tencent-wechat/phxpaxos/blob/master/README.zh_CN.md">《README》</a>中描述清楚了，本来是想phxelection和phxecho两个例子都一起跟踪的，但是后面看着看着发现，phxelection流程走完基本就定型了，phxecho和前者的差异主要就是传递了自定义的StateMachine，所以在Paxos算法Chosen Value之后，会额外的执行客户提供的状态机转移函数Execute()，这其实和phxelection在原理上没有本质的差异，因为后者算是对于选主的特殊情况，预先定义了MasterStateMachine状态机而已。不过phxecho的日志量要小一些，可以两个例程结合起来看。
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/分布式/">分布式</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/互联网/">互联网</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201611/learn-note-of-distributed-system-(3)-see-paxos-from-phxpaxos.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
    <article id="post-learn-note-of-tencent-libco-coroutine" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/201611/learn-note-of-tencent-libco-coroutine.html" class="article-date">
      <time datetime="2016-11-18T14:56:58.000Z" itemprop="datePublished">2016-11-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/201611/learn-note-of-tencent-libco-coroutine.html">腾讯libco协程库学习使用笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>　　在跟踪libco库时候发现一位网友提的issue，实在是看不下去了，哔了狗了。人家说程序员最喜欢的事是别人的项目有详细的wiki或文档，最讨厌的事情就是自己写文档，看来果真如此啊。不过libco自带了好几个例子，算是把libco的功能都展示了出来，过一遍也就知道怎么使用了。<br><img src="/post_images/images/201611/8064b68a1b41936d255f92f5a91eb647.png" alt="libco"><br>　　libco算是一个比较轻巧的协程库吧，看着代码不多，都是用朴实的C语言写的，而且完全不依赖于外部的ucontext或Boost.Context库，就想着读下代码彻底了解一下这个腾讯内部大规模用的协程库是怎么炼成的。从背景资料看来，一般对于新立项开发的系统，很多公司可能选择异步的方式来搞定，但是对于历史遗留的大规模同步模型的业务，异步化改造将会极具挑战性的事情，因为异步的方式需要代码分割重布，算是大换血的手术了；而如果采用协程和hook阻塞调用的方式，可以对传统同步类型业务基本无侵入的情况下享受异步带来的好处，这种手段确实很诱人。<br>　　额外想说的是，人家说隔行如隔山，其实当前在分工这么明确的环境下，隔业也同隔山啊，据说协程在游戏引擎行业早就大规模的被应用了以至于游戏开发者都不屑于提及这些，反而在互联网的后台压力越来越大的情况下，传统搞后台的兴起这个概念出来了。还有一点好奇的是，代码里面居然用了<strong>APPLE</strong>关键字和对kqueue异步的支持，腾讯不是一直是SuSE的粉丝么，难道后台也用到了很多BSD的服务器？</p>
<h1 id="一、协程的创建和调度">一、协程的创建和调度</h1><p>　　libco支持的协程原语包括：co_create、co_resume、co_yield、co_yield_ct、co_release。</p>
<h1 id="1-1_协程的创建管理">1.1 协程的创建管理</h1><p>　　(1). co_create()：创建一个协程。因为协程寄生于线程中的，所以每个线程需要有自己线程级别的资源来维护管理自己的协程。这里程序没有使用到线程局部存储TLS的方式，而是采用全局的stCoRoutineEnv_t类型的指针数组，然后采用线程tid进行索引的方式获取线程独立的存储结构。虽然定义上pid_t一般是int类型，但是系统一般不会用到这么大的范围，如果没有额外配置系统，默认最大的线程ID值定义在/proc/sys/kernel/pid_max为32768，所以这里使用上没什么问题，且空间浪费也不是很大。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stCoRoutineEnv_t &#123;</div><div class="line">	stCoRoutine_t *pCallStack[ <span class="number">128</span> ];</div><div class="line">	<span class="keyword">int</span> iCallStackSize;</div><div class="line">	stCoEpoll_t *pEpoll;</div><div class="line">	stCoRoutine_t* pending_co; stCoRoutine_t* ocupy_co;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在创建上述线程相关资源的时候，还会自动创建一个没有执行体的主协程，同时线程中还会创建一个stCoEpoll_t结构用于异步事件相关的操作，默认侦听fd数目最多为1024x10，同时在pTimeout-&gt;pItem上还创建了60x1000个stTimeoutItemLink_t结构(但是事件最大支持20s的超时，注释说40s，这里实际是60s!!!)，且后续在事件循环中，根据fd的事件状态会挂载到pstActiveList和pstTimeoutList链表上面去。
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/开发进阶/">开发进阶</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-与Boost/">C++与Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/后台开发/">后台开发</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/201611/learn-note-of-tencent-libco-coroutine.html#more">阅读全文 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
  
</article>










  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2017 taozj
            </div>
            <div class="footer-right">
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="nofollow">
                    <img src="/post_images/icons/icp_min.png" alt="粤ICP备17002382号-1">粤ICP备17002382号-1
                </a>
                <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258402767'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/stat.php%3Fid%3D1258402767%26online%3D2' type='text/javascript'%3E%3C/script%3E"));
                </script>
                Powered by <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>, theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a>  enhanced by Nicol <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
    </div>
</footer>

    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>
<script src="/js/search.js"></script> 


    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 10;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

    <script src="//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js"></script>


   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</script>

  </div>
</body>
</html>